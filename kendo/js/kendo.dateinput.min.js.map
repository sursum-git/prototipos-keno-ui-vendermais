{"version":3,"file":"kendo.dateinput.min.js","names":["MS_PER_MINUTE","MS_PER_MINUTE","DateInput","DateInputCommon"],"sources":["../../node_modules/@progress/kendo-date-math/dist/es2015/clone-date.js","../../node_modules/@progress/kendo-date-math/dist/es2015/adjust-dst.js","../../node_modules/@progress/kendo-date-math/dist/es2015/add-days.js","../../node_modules/@progress/kendo-date-math/dist/es2015/create-date.js","../../node_modules/@progress/kendo-date-math/dist/es2015/last-day-of-month.js","../../node_modules/@progress/kendo-date-math/dist/es2015/add-months.js","../../node_modules/@progress/kendo-date-math/dist/es2015/set-year.js","../../node_modules/@progress/kendo-date-math/dist/es2015/add-years.js","../../node_modules/@progress/kendo-date-math/dist/es2015/add-centuries.js","../../node_modules/@progress/kendo-date-math/dist/es2015/add-decades.js","../../node_modules/@progress/kendo-date-math/dist/es2015/add-weeks.js","../../node_modules/@progress/kendo-date-math/dist/es2015/constants.js","../../node_modules/@progress/kendo-date-math/dist/es2015/direction.enum.js","../../node_modules/@progress/kendo-date-math/dist/es2015/day-of-week.js","../../node_modules/@progress/kendo-date-math/dist/es2015/day.enum.js","../../node_modules/@progress/kendo-date-math/dist/es2015/normalize-year.js","../../node_modules/@progress/kendo-date-math/dist/es2015/first-decade-of-century.js","../../node_modules/@progress/kendo-date-math/dist/es2015/duration-in-centuries.js","../../node_modules/@progress/kendo-date-math/dist/es2015/first-year-of-decade.js","../../node_modules/@progress/kendo-date-math/dist/es2015/duration-in-decades.js","../../node_modules/@progress/kendo-date-math/dist/es2015/duration-in-months.js","../../node_modules/@progress/kendo-date-math/dist/es2015/duration-in-years.js","../../node_modules/@progress/kendo-date-math/dist/es2015/first-day-in-week.js","../../node_modules/@progress/kendo-date-math/dist/es2015/first-day-of-month.js","../../node_modules/@progress/kendo-date-math/dist/es2015/set-month.js","../../node_modules/@progress/kendo-date-math/dist/es2015/first-month-of-year.js","../../node_modules/@progress/kendo-date-math/dist/es2015/get-date.js","../../node_modules/@progress/kendo-date-math/dist/es2015/is-equal.js","../../node_modules/@progress/kendo-date-math/dist/es2015/is-equal-date.js","../../node_modules/@progress/kendo-date-math/dist/es2015/last-decade-of-century.js","../../node_modules/@progress/kendo-date-math/dist/es2015/last-month-of-year.js","../../node_modules/@progress/kendo-date-math/dist/es2015/last-year-of-decade.js","../../node_modules/@progress/kendo-date-math/dist/es2015/next-day-of-week.js","../../node_modules/@progress/kendo-date-math/dist/es2015/prev-day-of-week.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/timezones.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/rule-to-date.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/find-rule.js","../../node_modules/@progress/kendo-date-math/dist/es2015/errors.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/get-zone.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/find-zone.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/zone-and-rule.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/pad-number.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/abbr-timezone.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/load-timezone.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/offset.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/timezone-group-names.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/timezone-names.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/timezone-title.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/to-local-date.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/zoned-date.js","../../node_modules/@progress/kendo-date-math/dist/es2015/tz/zones-per-group.js","../../node_modules/@progress/kendo-date-math/dist/es2015/week-in-year.js","../../node_modules/@progress/kendo-dateinputs-common/dist/es2015/common/mask.js","../../node_modules/@progress/kendo-dateinputs-common/dist/es2015/common/constants.js","../../node_modules/@progress/kendo-dateinputs-common/dist/es2015/common/key.js","../../node_modules/@progress/kendo-dateinputs-common/dist/es2015/dateinput/utils.js","../../node_modules/@progress/kendo-dateinputs-common/dist/es2015/common/utils.js","../../node_modules/@progress/kendo-dateinputs-common/dist/es2015/common/dateobject.js","../../node_modules/@progress/kendo-dateinputs-common/dist/es2015/common/keycode.js","../../node_modules/@progress/kendo-dateinputs-common/dist/es2015/common/observable.js","../../node_modules/@progress/kendo-dateinputs-common/dist/es2015/dateinput/interaction-mode.js","../../node_modules/@progress/kendo-dateinputs-common/dist/es2015/dateinput/dateinput.js","../../src/kendo.dateinput.js"],"sourcesContent":["/**\n * A function that clones the passed date. The parameter could be `null`.\n *\n * @param date - The initial date value.\n * @returns - A new `Date` instance.\n *\n * @example\n * ```ts-no-run\n * cloneDate(new Date(2016, 0, 1)); // returns new Date(2016, 0, 1);\n * cloneDate(null); // returns null\n * ```\n */\nexport const cloneDate = (date) => date ? new Date(date.getTime()) : null;\n","import { cloneDate } from './clone-date';\n/**\n * @hidden\n */\nexport const adjustDST = (date, hour) => {\n    const newDate = cloneDate(date);\n    if (hour === 0 && newDate.getHours() === 23) {\n        newDate.setHours(newDate.getHours() + 2);\n    }\n    return newDate;\n};\n","import { adjustDST } from './adjust-dst';\nimport { cloneDate } from './clone-date';\n/**\n * A function that adds and subtracts days from a `Date` object.\n *\n * @param date - The initial date value.\n * @param offset - The number of days to add and subtract from the date.\n * @returns - A new `Date` instance.\n *\n * @example\n * ```ts-no-run\n * addDays(new Date(2016, 0, 1), 5); // 2016-1-6\n * addDays(new Date(2016, 0, 1), -5); // 2015-12-26\n * ```\n */\nexport const addDays = (date, offset) => {\n    const newDate = cloneDate(date);\n    newDate.setDate(newDate.getDate() + offset);\n    return adjustDST(newDate, date.getHours());\n};\n","import { adjustDST } from './adjust-dst';\n/**\n * A function which returns a new `Date` instance.\n *\n * @param year - The year value.\n * @param month - The month value.\n * @param day - The day value.\n * @param hours - The hours value.\n * @param minutes - The minutes value.\n * @param seconds - The seconds value.\n * @param milliseconds - milliseconds value.\n * @returns The date instance.\n *\n * @example\n * ```ts-no-run\n * createDate(2016, 0, 15); // 2016-01-15 00:00:00\n * createDate(2016, 0, 15, 22, 22, 20); // 2016-01-15 22:22:20\n * ```\n */\nexport const createDate = (year, month, day, hours = 0, minutes = 0, seconds = 0, milliseconds = 0) => {\n    const date = new Date(year, month, day, hours, minutes, seconds, milliseconds);\n    if (year > -1 && year < 100) {\n        date.setFullYear(date.getFullYear() - 1900);\n    }\n    return adjustDST(date, hours);\n};\n","import { addDays } from './add-days';\nimport { createDate } from './create-date';\n/**\n * A function which returns the last date of the month.\n *\n * @param date - The initial date.\n * @returns - The last date of the initial date month.\n *\n * @example\n * ```ts-no-run\n * lastDayOfMonth(new Date(2016, 0, 15)); // 2016-01-31\n * ```\n */\nexport const lastDayOfMonth = (date) => {\n    const newDate = createDate(date.getFullYear(), date.getMonth() + 1, 1, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n    return addDays(newDate, -1);\n};\n","import { adjustDST } from './adjust-dst';\nimport { cloneDate } from './clone-date';\nimport { lastDayOfMonth } from './last-day-of-month';\nconst MONTHS_LENGTH = 12;\nconst normalize = (date, expectedMonth) => (date.getMonth() !== expectedMonth ? lastDayOfMonth(addMonths(date, -1)) : date //tslint:disable-line:no-use-before-declare\n);\n/**\n * A function that adds and subtracts months from a `Date` object.\n *\n * @param date - The initial date value.\n * @param offset - The number of months to add or subtract from the date.\n * @returns - A new `Date` instance.\n *\n * @example\n * ```ts-no-run\n * addMonths(new Date(2016, 5, 1), 5); // 2016-11-1\n * addMonths(new Date(2016, 5, 1), -5); // 2015-1-1\n * ```\n */\nexport const addMonths = (date, offset) => {\n    const newDate = cloneDate(date);\n    const diff = (newDate.getMonth() + offset) % MONTHS_LENGTH;\n    const expectedMonth = (MONTHS_LENGTH + diff) % MONTHS_LENGTH;\n    newDate.setMonth(newDate.getMonth() + offset);\n    return normalize(adjustDST(newDate, date.getHours()), expectedMonth);\n};\n","import { addMonths } from './add-months';\nimport { createDate } from './create-date';\nimport { lastDayOfMonth } from './last-day-of-month';\n/**\n * @hidden\n */\nexport const setYear = (value, year) => {\n    const month = value.getMonth();\n    const candidate = createDate(year, month, value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());\n    return candidate.getMonth() === month ? candidate : lastDayOfMonth(addMonths(candidate, -1));\n};\n","import { adjustDST } from './adjust-dst';\nimport { setYear } from './set-year';\n/**\n * A function that adds and subtracts years from a `Date` object.\n *\n * @param date - The initial date value.\n * @param offset - The number of years to add or subtract from the date.\n * @returns - A new `Date` instance.\n *\n * @example\n * ```ts-no-run\n * addYears(new Date(2016, 5, 1), 5); // 2011-6-1\n * addYears(new Date(2016, 5, 1), -5); // 2021-6-1\n * ```\n */\nexport const addYears = (value, offset) => {\n    return adjustDST(setYear(value, value.getFullYear() + offset), value.getHours());\n};\n","import { addYears } from './add-years';\n/**\n * A function that adds and subtracts centuries from a `Date` object.\n *\n * @param date - The initial date value.\n * @param offset - The number of centuries to add or subtract from the date.\n * @returns - A new `Date` instance.\n *\n * @example\n * ```ts-no-run\n * addCenturies(new Date(2016, 5, 1), 5); // 2516-6-1\n * addCenturies(new Date(2016, 5, 1), -5); // 1516-6-1\n * ```\n */\nexport const addCenturies = (value, offset) => {\n    return addYears(value, 100 * offset);\n};\n","import { addYears } from './add-years';\n/**\n * A function that adds and subtracts decades from a `Date` object.\n *\n * @param date - The initial date value.\n * @param offset - The number of decades to add or subtract from the date.\n * @returns - A new `Date` instance.\n *\n * @example\n * ```ts-no-run\n * addDecades(new Date(2016, 5, 1), 5); // 2066-6-1\n * addDecades(new Date(2016, 5, 1), -5); // 1966-6-1\n * ```\n */\nexport const addDecades = (value, offset) => {\n    return addYears(value, 10 * offset);\n};\n","import { addDays } from './add-days';\n/**\n * A function that adds and subtracts weeks from a Date object.\n *\n * @param date - The initial date value.\n * @param offset - The number of weeks to add/subtract from the date.\n * @returns - A new `Date` instance.\n *\n * @example\n * ```ts-no-run\n * addWeeks(new Date(2016, 5, 1), 3); // 2016-6-22\n * addWeeks(new Date(2016, 5, 1), -3); // 2015-5-11\n * ```\n */\nexport const addWeeks = (date, offset) => {\n    return addDays(date, offset * 7);\n};\n","/**\n * The number of milliseconds in one minute.\n */\nexport const MS_PER_MINUTE = 60000;\n/**\n * The number of milliseconds in one hour.\n */\nexport const MS_PER_HOUR = 3600000;\n/**\n * The number of milliseconds in one standard day.\n */\nexport const MS_PER_DAY = 86400000;\n","// tslint:disable:max-line-length\n/**\n * An enumeration which represents the horizontal direction. The `Forward` option moves forward. The `Backward` option moves backward.\n */\nexport var Direction;\n(function (Direction) {\n    /**\n     * The `Forward` value with an underlying `1` number value.\n     */\n    Direction[Direction[\"Forward\"] = 1] = \"Forward\";\n    /**\n     * The `Backward` value with an underlying `-1` (minus one) number value.\n     */\n    Direction[Direction[\"Backward\"] = -1] = \"Backward\";\n})(Direction || (Direction = {}));\n// tslint:enable:max-line-length\n","import { Direction } from \"./direction.enum\";\nimport { adjustDST } from \"./adjust-dst\";\nimport { cloneDate } from './clone-date';\n/**\n * @hidden\n *\n * A function which returns the next or previous date for a specific week day. For example, `Day.Monday`.\n *\n * @param date - The date to calculate from.\n * @param weekDay - The `Day` enum specifying the desired week day.\n * @param direction - The `Direction` enum specifying the calculation direction.\n * @returns - A `Date` instance.\n *\n * @example\n * ```ts-no-run\n * dayOfWeek(new Date(2016, 0, 1), Day.Wednesday, Direction.Forward); // 2016-01-06, Wednesday\n * dayOfWeek(new Date(2016, 0, 1), Day.Wednesday, Direction.Backward); // 2015-12-30, Wednesday\n * ```\n */\nexport const dayOfWeek = (date, weekDay, direction = Direction.Forward) => {\n    const newDate = cloneDate(date);\n    const newDay = ((weekDay - newDate.getDay()) + (7 * direction)) % 7;\n    newDate.setDate(newDate.getDate() + newDay);\n    return adjustDST(newDate, date.getHours());\n};\n","/**\n * Enumeration which represents the week days.\n */\nexport var Day;\n(function (Day) {\n    /**\n     * The Sunday value with an underlying `0` number value.\n     */\n    Day[Day[\"Sunday\"] = 0] = \"Sunday\";\n    /**\n     * The Monday value with an underlying `1` number value.\n     */\n    Day[Day[\"Monday\"] = 1] = \"Monday\";\n    /**\n     * The Tuesday value with an underlying `2` number value.\n     */\n    Day[Day[\"Tuesday\"] = 2] = \"Tuesday\";\n    /**\n     * The Wednesday value with an underlying `3` number value.\n     */\n    Day[Day[\"Wednesday\"] = 3] = \"Wednesday\";\n    /**\n     * The Thursday value with an underlying `4` number value.\n     */\n    Day[Day[\"Thursday\"] = 4] = \"Thursday\";\n    /**\n     * The Friday value with an underlying `5` number value.\n     */\n    Day[Day[\"Friday\"] = 5] = \"Friday\";\n    /**\n     * The Saturday value with an underlying `6` number value.\n     */\n    Day[Day[\"Saturday\"] = 6] = \"Saturday\";\n})(Day || (Day = {}));\n","import { setYear } from './set-year';\n/**\n * @hidden\n */\n// eslint-disable-next-line\nexport const normalizeYear = (value, year) => (setYear(value, year(value.getFullYear())));\n","import { normalizeYear } from './normalize-year';\n/**\n * A function that returns a `Date` object of the first decade in a century.\n *\n * @param date - The start date value.\n * @returns - The first year in a century.\n *\n * @example\n * ```ts-no-run\n * firstDecadeOfCentury(new Date(2017, 0, 1)); // 2000-1-1\n * firstDecadeOfCentury(new Date(2007, 10, 22)); // 2000-11-22\n * firstDecadeOfCentury(new Date(2126, 0, 1)); // 2100-1-1\n * ```\n */\nexport const firstDecadeOfCentury = (value) => (normalizeYear(value, (y) => y - (y % 100)));\n","import { firstDecadeOfCentury } from './first-decade-of-century';\n/**\n * A function that calculates duration in centuries between two `Date` objects.\n *\n * @param start - The start date value.\n * @param end - The end date value.\n * @returns - The duration in months.\n *\n * @example\n * ```ts-no-run\n * durationInCenturies(new Date(2016, 0, 1), new Date(3216, 0, 1)); // 12\n * durationInCenturies(new Date(2016, 6, 1), new Date(2617, 0, 1)); // 6\n * durationInCenturies(new Date(2016, 0, 1), new Date(2016, 0, 1)); // 0\n * ```\n */\nexport const durationInCenturies = (start, end) => ((firstDecadeOfCentury(end).getFullYear() - firstDecadeOfCentury(start).getFullYear()) / 100);\n","import { normalizeYear } from './normalize-year';\n/**\n * A function that returns a `Date` object of the first year in a decade.\n *\n * @param date - The start date value.\n * @returns - The first year in a decade.\n *\n * @example\n * ```ts-no-run\n * firstYearOfDecade(new Date(2017, 0, 1)); // 2010-1-1\n * firstYearOfDecade(new Date(2007, 10, 22)); // 2000-11-22\n * firstYearOfDecade(new Date(2026, 0, 1)); // 2020-1-1\n * ```\n */\nexport const firstYearOfDecade = (value) => (normalizeYear(value, (y) => y - (y % 10)));\n","import { firstYearOfDecade } from './first-year-of-decade';\n/**\n * A function that calculates duration in decades between two `Date` objects.\n *\n * @param start - The start date value.\n * @param end - The end date value.\n * @returns - The duration in months.\n *\n * @example\n * ```ts-no-run\n * durationInDecades(new Date(2016, 0, 1), new Date(2136, 0, 1)); // 12\n * durationInDecades(new Date(2016, 0, 1), new Date(2016, 0, 1)); // 0\n * ```\n */\nexport const durationInDecades = (start, end) => ((firstYearOfDecade(end).getFullYear() - firstYearOfDecade(start).getFullYear()) / 10);\n","/**\n * A function that calculates duration in months between two `Date` objects.\n *\n * @param start - The start date value.\n * @param end - The end date value.\n * @returns - The duration in months.\n *\n * @example\n * ```ts-no-run\n * durationInMonths(new Date(2016, 0, 1), new Date(2017, 0, 1)); // 12\n * durationInMonths(new Date(2016, 6, 1), new Date(2017, 0, 1)); // 6\n * durationInMonths(new Date(2016, 0, 1), new Date(2016, 0, 1)); // 0\n * ```\n */\nexport const durationInMonths = (start, end) => (((end.getFullYear() - start.getFullYear())) * 12 + (end.getMonth() - start.getMonth()));\n","/**\n * A function that calculates duration in years between two `Date` objects.\n *\n * @param start - The start date value.\n * @param end - The end date value.\n * @returns - The duration in years.\n *\n * @example\n * ```ts-no-run\n * durationInYears(new Date(2016, 0, 1), new Date(2028, 0, 1)); // 12\n * durationInYears(new Date(2016, 0, 1), new Date(2022, 0, 1)); // 6\n * durationInYears(new Date(2016, 0, 1), new Date(2016, 0, 1)); // 0\n * ```\n */\nexport const durationInYears = (start, end) => (end.getFullYear() - start.getFullYear());\n","import { cloneDate } from './clone-date';\nimport { Day } from './day.enum';\n/**\n *  A function which returns the first date of the current week.\n *\n * @param date - The initial date.\n * @param weekStartDay [default: Day.Sunday] - The first day of the week.\n * @returns - The first date of the current week.\n *\n * @example\n * ```ts-no-run\n * firstDayInWeek(new Date(2016, 0, 15)); // 2016-01-10\n * firstDayInWeek(new Date(2016, 0, 15), Day.Monday); // 2016-01-11\n * ```\n */\nexport const firstDayInWeek = (date, weekStartDay = Day.Sunday) => {\n    const first = cloneDate(date);\n    while (first.getDay() !== weekStartDay) {\n        first.setDate(first.getDate() - 1);\n    }\n    return first;\n};\n","import { createDate } from './create-date';\n/**\n * A function which returns the first date of the month.\n *\n * @param date - The initial date.\n * @returns - The first date of the initial date month.\n *\n * @example\n * ```ts-no-run\n * firstDayOfMonth(new Date(2016, 0, 15)); // 2016-01-01\n * ```\n */\nexport const firstDayOfMonth = (date) => {\n    return createDate(date.getFullYear(), date.getMonth(), 1, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n};\n","import { addMonths } from './add-months';\nimport { createDate } from './create-date';\nimport { lastDayOfMonth } from './last-day-of-month';\n/**\n * @hidden\n */\nexport const setMonth = (value, month) => {\n    const day = value.getDate();\n    const candidate = createDate(value.getFullYear(), month, day, value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());\n    return candidate.getDate() === day ? candidate : lastDayOfMonth(addMonths(candidate, -1));\n};\n","import { setMonth } from './set-month';\n/**\n * A function that returns a `Date` object of the first month in a year.\n *\n * @param date - The start date value.\n * @returns - The first month in a year.\n *\n * @example\n * ```ts-no-run\n * firstMonthOfYear(new Date(2017, 11, 1)); // 2017-1-1\n * firstMonthOfYear(new Date(2017, 0, 1)); // 2017-1-1\n * ```\n */\nexport const firstMonthOfYear = (value) => setMonth(value, 0);\n","import { createDate } from './create-date';\n/**\n * A function which returns the passed date with a midnight time portion.\n *\n * @param date - The initial date.\n * @returns - The date with a midnight time portion.\n *\n * @example\n * ```ts-no-run\n * getDate(new Date(2016, 0, 15, 14, 30, 30)); // 2016-01-15 00:00:00\n * ```\n */\nexport const getDate = (date) => {\n    return createDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n};\n","/**\n * A function that compares two dates. The comparison also includes the time portion.\n *\n * @param candidate - The candidate date.\n * @param expected - The expected date.\n * @returns - A Boolean value indicating whether the values are equal.\n *\n * @example\n * ```ts-no-run\n * isEqual(new Date(2016, 0, 1), new Date(2016, 0, 1)); // true\n * isEqual(new Date(2016, 0, 1), new Date(2016, 0, 2)); // false\n * isEqual(new Date(2016, 0, 1, 10), new Date(2016, 0, 1, 20)); // false\n * ```\n */\nexport const isEqual = (candidate, expected) => {\n    if (!candidate && !expected) {\n        return true;\n    }\n    return candidate && expected && candidate.getTime() === expected.getTime();\n};\n","import { getDate } from './get-date';\nimport { isEqual } from './is-equal';\n/**\n * A function that compares the date portions of 2 dates.\n *\n * @param candidate - The candidate date.\n * @param expected - The expected date.\n * @returns - A Boolean value whether the values are equal.\n *\n * @example\n * ```ts-no-run\n * isEqualDate(new Date(2016, 0, 1, 10), new Date(2016, 0, 1, 20)); // true\n * isEqualDate(new Date(2016, 0, 1, 10), new Date(2016, 0, 2, 10)); // false\n * ```\n */\nexport const isEqualDate = (candidate, expected) => {\n    if (!candidate && !expected) {\n        return true;\n    }\n    return candidate && expected && isEqual(getDate(candidate), getDate(expected));\n};\n","import { normalizeYear } from './normalize-year';\n/**\n * A function that returns a `Date` object of the last decade in a century.\n *\n * @param date - The start date value.\n * @returns - The last year in a decade.\n *\n * @example\n * ```ts-no-run\n * lastDecadeOfCentury(new Date(2017, 0, 1)); // 2090-1-1\n * lastDecadeOfCentury(new Date(2007, 10, 22)); // 2090-11-22\n * lastDecadeOfCentury(new Date(2126, 0, 1)); // 2190-1-1\n * ```\n */\nexport const lastDecadeOfCentury = (value) => (normalizeYear(value, (y) => y - (y % 100) + 90));\n","import { setMonth } from './set-month';\n/**\n * A function that returns a `Date` object of the last month in a year.\n *\n * @param date - The start date value.\n * @returns - The last month in a year.\n *\n * @example\n * ```ts-no-run\n * lastMonthOfYear(new Date(2017, 5, 3)); // 2017-12-3\n * lastMonthOfYear(new Date(2017, 11, 3)); // 2017-12-3\n * ```\n */\nexport const lastMonthOfYear = (value) => setMonth(value, 11);\n","import { normalizeYear } from './normalize-year';\n/**\n * A function that returns a `Date` object of the last year in a decade.\n *\n * @param date - The start date value.\n * @returns - The last year in a decade.\n *\n * @example\n * ```ts-no-run\n * lastYearOfDecade(new Date(2017, 0, 1)); // 2019-1-1\n * lastYearOfDecade(new Date(2007, 10, 22)); // 2009-11-22\n * lastYearOfDecade(new Date(2026, 0, 1)); // 2029-1-1\n * ```\n */\nexport const lastYearOfDecade = (value) => (normalizeYear(value, (y) => y - (y % 10) + 9));\n","import { Direction } from \"./direction.enum\";\nimport { dayOfWeek } from './day-of-week';\n/**\n * A function which returns a date by a specific week name. For example, `Day.Monday`.\n *\n * @param date - The date to calculate from.\n * @param weekDay - The `Day` enum specifying the desired week day.\n * @returns - A `Date` instance.\n *\n * @example\n * ```ts-no-run\n * nextDayOfWeek(new Date(2016, 0, 1), Day.Wednesday); // 2016-01-06, Wednesday\n * ```\n */\nexport const nextDayOfWeek = (date, weekDay) => {\n    return dayOfWeek(date, weekDay, Direction.Forward);\n};\n","import { Direction } from \"./direction.enum\";\nimport { dayOfWeek } from './day-of-week';\n/**\n * A function which returns a date by a specific week name. For example, `Day.Monday`.\n *\n * @param date - The date to calculate from.\n * @param weekDay - The `Day` enum specifying the desired week day.\n * @returns - A `Date` instance.\n *\n * @example\n * ```ts-no-run\n * prevDayOfWeek(new Date(2016, 0, 1), Day.Wednesday); // 2015-12-30, Wednesday\n * ```\n */\nexport const prevDayOfWeek = (date, weekDay) => {\n    return dayOfWeek(date, weekDay, Direction.Backward);\n};\n","/**\n * @hidden\n *\n * An object which contains the information about the cities within the timezone.\n */\nexport const timezones = {\n    rules: {},\n    titles: {},\n    zones: {}\n};\n","const MONTHS = { Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5, Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11 };\nconst DAYS = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };\nconst MS_PER_MINUTE = 60000;\n/**\n * @hidden\n *\n * A function that finds zone rules which become applicable after a specific time.\n *\n * @param year - The value of the year.\n * @param rule - A specific zone rule.\n * @param zone - The definition of the zone.\n *\n * @return - Returns an extended rule.\n *\n * @example\n * ```ts-no-run\n * ruleToDate(2018, rule); // A rule that contains {'2018': |2018 DST date| }\n * ```\n */\nexport const ruleToDate = (year, rule, zoneOffset) => {\n    const month = rule[3];\n    const on = rule[4];\n    const time = rule[5];\n    let date;\n    const ruleOffset = time[3] === 'u' ? -zoneOffset * MS_PER_MINUTE : 0;\n    if (!isNaN(on)) {\n        date = new Date(Date.UTC(year, MONTHS[month], on, time[0], time[1], time[2]) + ruleOffset);\n    }\n    else if (on.indexOf('last') === 0) {\n        date = new Date(Date.UTC(year, MONTHS[month] + 1, 1, time[0] - 24, time[1], time[2]) + ruleOffset);\n        const targetDay = DAYS[on.substr(4, 3)];\n        const ourDay = date.getUTCDay();\n        date.setUTCDate(date.getUTCDate() + targetDay - ourDay - (targetDay > ourDay ? 7 : 0));\n    }\n    else if (on.indexOf('>=') >= 0) {\n        date = new Date(Date.UTC(year, MONTHS[month], on.substr(5), time[0], time[1], time[2], 0) + ruleOffset);\n        const targetDay = DAYS[on.substr(0, 3)];\n        const ourDay = date.getUTCDay();\n        date.setUTCDate(date.getUTCDate() + targetDay - ourDay + (targetDay < ourDay ? 7 : 0));\n    }\n    return date;\n};\n","import { timezones } from './timezones';\nimport { ruleToDate } from './rule-to-date';\nconst CURRENT_UTC_TIME = (new Date()).getTime();\n/**\n * @hidden\n *\n * A function that finds zone rules which become applicable after a specific time.\n *\n * @param timezone - The timezone name. For example, `America/Chicago`, `Europe/Sofia`.\n * @param utcTime - The UTC time boundary for a zone rule. Defaults to the current UTC time.\n *\n * @return - Returns a zone rule for the specific zone name.\n *\n * @example\n * ```ts-no-run\n * findZone('Europe/Sofia'); //[-120,\"EU\",\"EE%sT\",null]\n * ```\n */\nexport const findRule = (zoneRule, utcTime = CURRENT_UTC_TIME, zoneOffset = 0) => {\n    let rules = timezones.rules[zoneRule];\n    if (!rules) {\n        const time = zoneRule.split(\":\");\n        let offset = 0;\n        if (time.length > 1) {\n            offset = time[0] * 60 + Number(time[1]);\n        }\n        return [-1000000, 'max', '-', 'Jan', 1, [0, 0, 0], offset, '-'];\n    }\n    const year = new Date(utcTime).getUTCFullYear();\n    rules = rules.filter((currentRule) => {\n        const from = currentRule[0];\n        const to = currentRule[1];\n        return from <= year && (to >= year || (from === year && to === \"only\") || to === \"max\");\n    });\n    rules.push(utcTime);\n    rules.sort((a, b) => {\n        if (typeof a !== \"number\") {\n            a = Number(ruleToDate(year, a, zoneOffset));\n        }\n        if (typeof b !== \"number\") {\n            b = Number(ruleToDate(year, b, zoneOffset));\n        }\n        return a - b;\n    });\n    const rule = rules[rules.indexOf(utcTime) - 1] || rules[rules.length - 1];\n    return isNaN(rule) ? rule : null;\n};\n","/** @hidden */\nexport const NO_TZ_INFO = 'The required {0} timezone information is not provided!';\n/** @hidden */\nexport const INVALID_TZ_STRUCTURE = 'The provided timezone information has invalid stucture!';\nconst formatRegExp = /\\{(\\d+)}?\\}/g;\nconst flatten = (arr) => arr.reduce((a, b) => a.concat(b), []);\n/** @hidden */\nexport const formatMessage = (message, ...values) => {\n    const flattenValues = flatten(values);\n    return message.replace(formatRegExp, (_, index) => flattenValues[parseInt(index, 10)]);\n};\n","import { timezones } from './timezones';\nimport { formatMessage, NO_TZ_INFO } from '../errors';\n/**\n * @hidden\n *\n * A function that gets all zone rules for a specific zone.\n *\n * @param timezone - The timezone name. For example, `America/Chicago`, `Europe/Sofia`.\n *\n * @return - Returns all zone rules for the specific zone name.\n *\n * @example\n * ```ts-no-run\n * findZone('Europe/Sofia'); //[[-120,\"E-Eur\",\"EE%sT\",883526400000], [-120,\"EU\",\"EE%sT\",null]]\n * ```\n */\nexport const getZoneRules = (timezone) => {\n    const zones = timezones.zones;\n    if (!zones) {\n        throw new Error(formatMessage(NO_TZ_INFO, timezone));\n    }\n    const zoneRules = zones[timezone];\n    const result = typeof zoneRules === \"string\" ? zones[zoneRules] : zoneRules;\n    if (!result) {\n        throw new Error(formatMessage(NO_TZ_INFO, timezone));\n    }\n    return result;\n};\n","import { getZoneRules } from './get-zone';\nimport { formatMessage, NO_TZ_INFO } from '../errors';\n/**\n * @hidden\n *\n * A function that finds zone rules which become applicable after specific time.\n */\nexport const findZone = (timezone, utcTime = new Date().getTime()) => {\n    if (timezone === 'Etc/UTC' || timezone === 'Etc/GMT') {\n        return [0, \"-\", \"UTC\", null];\n    }\n    const zoneRules = getZoneRules(timezone);\n    let idx = zoneRules.length - 1;\n    for (; idx >= 0; idx--) {\n        const until = zoneRules[idx][3];\n        if (until && utcTime > until) {\n            break;\n        }\n    }\n    const zone = zoneRules[idx + 1];\n    if (!zone) {\n        throw new Error(formatMessage(NO_TZ_INFO, timezone));\n    }\n    return zone;\n};\n","import { findRule } from './find-rule';\nimport { findZone } from './find-zone';\n/**\n * @hidden\n *\n * A function that gets the information about the zone and the rule for a specific timezone.\n *\n */\nexport const zoneAndRule = (timezone, date) => {\n    const utcTime = date.getTime();\n    const zone = findZone(timezone, utcTime);\n    return {\n        rule: findRule(zone[1], utcTime, zone[0]),\n        zone: zone\n    };\n};\n","/**\n * @hidden\n */\nexport const padNumber = (num, len = 2) => {\n    const sign = num < 0 ? '-' : '';\n    return sign + new Array(len).concat([Math.abs(num)]).join('0').slice(-len);\n};\n","import { zoneAndRule } from './zone-and-rule';\nimport { padNumber } from './pad-number';\n// tslint:disable:max-line-length\n/**\n * A function which returns the abbreviated name of the timezone. You can specify an optional date for returning the timezone name at a different point in time. The corresponding UTC date is used for locating the relevant rule. Timezone names change both historically and when they reflect the Daylight Savings Time rules.\n *\n * @param timezone - The timezone name. For example, `America/Chicago`, `Europe/Sofia`.\n * @param date - A date for which to locate the zone rule. By default, the current time is used.\n *\n * @return - The abbreviated name of the timezone at the specified date or, if not set, returns now.\n *\n * @example\n * ```ts-no-run\n * import { abbrTimezone } from '@progress/kendo-date-math';\n * import '@progress/kendo-date-math/tz/Europe/Sofia';\n *\n * const dstDate = new Date('2018-04-01T00:00:00Z');\n * console.log(abbrTimezone('Europe/Sofia', dstDate)); // EEST\n *\n * const date = new Date('2018-01-01T00:00:00Z');\n * console.log(abbrTimezone('Europe/Sofia', date)); // EET\n * ```\n */\n// tslint:enable:max-line-length\nexport const abbrTimezone = (timezone, date = new Date()) => {\n    if (timezone === \"Etc/UTC\") {\n        return 'UTC';\n    }\n    if (timezone === \"Etc/GMT\") {\n        return 'GMT';\n    }\n    if (timezone === '') {\n        return '';\n    }\n    const { zone, rule } = zoneAndRule(timezone, date);\n    const base = zone[2];\n    if (base.indexOf(\"/\") >= 0) {\n        return base.split(\"/\")[rule && +rule[6] ? 1 : 0];\n    }\n    else if (base.indexOf(\"%s\") >= 0) {\n        return base.replace(\"%s\", (!rule || rule[7] === \"-\") ? '' : rule[7]);\n    }\n    else if (base.indexOf(\"%z\") >= 0) {\n        const hours = -1 * Math.trunc(zone[0] / 60);\n        const hoursPart = padNumber(hours, 2);\n        const signPart = hours > 0 ? '+' : '';\n        const minutes = Math.abs(Math.trunc(zone[0] % 60));\n        const minutesPart = minutes === 0 ? '' : padNumber(minutes, 2);\n        return base.replace(\"%z\", `${signPart}${hoursPart}${minutesPart}`);\n    }\n    return base;\n};\n","import { timezones } from './timezones';\nimport { formatMessage, NO_TZ_INFO, INVALID_TZ_STRUCTURE } from '../errors';\n// tslint:disable:max-line-length\n/**\n * A function that loads the information about the provided timezone. The details for the loaded timezone will be available to all functions that are related to the manipulation of the timezone.\n *\n * @param timezoneInfo - The information about the timezone that will be loaded.\n *\n * @example\n * ```ts-no-run\n * loadTimezone({ zones: [...], rules: [...]});\n * ```\n */\n// tslint:enable:max-line-length\nexport const loadTimezone = (tzInfo) => {\n    if (!tzInfo) {\n        throw new Error(formatMessage(NO_TZ_INFO, ''));\n    }\n    const { rules, titles, zones } = tzInfo;\n    if (rules === undefined || zones === undefined) {\n        throw new Error(INVALID_TZ_STRUCTURE);\n    }\n    Object.assign(timezones.rules, rules);\n    Object.assign(timezones.titles, titles || {});\n    Object.assign(timezones.zones, zones);\n};\n","import { zoneAndRule } from './zone-and-rule';\n/**\n * @hidden\n *\n * A function that calculates the time offset based on zone name.\n *\n * @param timezone - The timezone name. For example, `America/Chicago`, `Europe/Sofia`.\n * @param date - A date for which the zone rule will be located.\n *\n * @return - Returns the timezone offset in minutes at the specified time.\n */\nexport const offset = (timezone, date = new Date()) => {\n    if (timezone === 'Etc/UTC' || timezone === 'Etc/GMT') {\n        return 0;\n    }\n    if (timezone === '') {\n        return date.getTimezoneOffset();\n    }\n    const { rule, zone } = zoneAndRule(timezone, date);\n    return parseFloat(rule ? zone[0] - rule[6] : zone[0]);\n};\n","import { timezones } from './timezones';\n/**\n * A function that returns a list of grouped timezone names.\n *\n * @return - Returns a list of grouped timezone names.\n *\n * @example\n * ```ts-no-run\n * import '@progress/kendo-date-math/timezones/europe-berlin';\n * import '@progress/kendo-date-math/timezones/europe-sofia';\n *\n * timezoneGroupNames(); // ['(GMT+01:00) Amsterdam, Berlin, ...', '(GMT+02:00) Sofia, Tallinn...']\n * ```\n */\nexport const timezoneGroupNames = () => {\n    const groups = Object.keys(timezones.titles).reduce((tmp, t) => {\n        const group = timezones.titles[t].group;\n        tmp[group] = group;\n        return tmp;\n    }, {});\n    return Object.keys(groups);\n};\n","import { timezones } from './timezones';\n/**\n * A function that returns the list of all timezones that are loaded.\n *\n * @return - Returns the list of all timezones that are loaded.\n *\n * @example\n * ```ts-no-run\n * import '@progress/kendo-date-math/timezones/europe-berlin';\n * import '@progress/kendo-date-math/timezones/europe-sofia';\n *\n * timezoneNames(); // ['Europe/Berlin', 'Europe/Sofia']\n * ```\n */\nexport const timezoneNames = () => Object.keys(timezones.zones);\n","import { timezones } from './timezones';\n/**\n * A function that returns the full name of the timezone.\n *\n * @param timezone - The timezone name. For example, `America/Chicago`, `Europe/Sofia`.\n *\n * @return - Returns the full names of the timezone and the group.\n *\n * @example\n * ```ts-no-run\n * timezoneTitle('America/Chicago'); // Central Standard Time\n * ```\n */\nexport const timezoneTitle = (timezone) => {\n    const { titles } = timezones;\n    const info = titles[timezone] || {};\n    return info.long || timezone;\n};\n","/**\n * A function that creates a local date from the UTC date parts of the input.\n *\n * @param date - The date value that will be converted. Only the UTC date parts are read.\n * @return Date - A local date with the UTC time parts of the supplied date.\n *\n * @example\n * ```ts-no-run\n * import { toLocalDate } from '@progress/kendo-date-math'\n *\n * const date = new Date('2016-11-05');\n * const local = toLocalDate(date);\n *\n * // For example, if the browser is in GMT+0200,\n * // the local date will be shifted 2 hours back:\n * //\n * // \"Fri Nov 04 2016 22:00:00 GMT+0200\"\n * console.log(local);\n *\n * // This is the same as the UTC parts of the input date:\n * //\n * // \"2016-11-05T22:00:00.000Z\"\n * console.log(date.toISOString());\n * ```\n */\nexport function toLocalDate(date) {\n    return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());\n}\n","import { MS_PER_HOUR, MS_PER_MINUTE } from '../constants';\nimport { cloneDate } from '../clone-date';\nimport { abbrTimezone } from './abbr-timezone';\nimport { offset } from './offset';\nimport { toLocalDate } from './to-local-date';\nimport { padNumber } from './pad-number';\nconst addMinutes = (date, minutes) => new Date(date.getTime() + minutes * MS_PER_MINUTE);\nconst addHours = (date, hours) => new Date(date.getTime() + hours * MS_PER_HOUR);\nconst dayAbbr = [\n    'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'\n];\nconst monthAbbr = [\n    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'\n];\nconst datePrefix = (utcDate) => dayAbbr[utcDate.getUTCDay()] + ' ' + monthAbbr[utcDate.getUTCMonth()];\nfunction isZoneMissingHour(date, timezone) {\n    const currentOffset = offset(timezone, date);\n    const prevHour = addHours(date, -1);\n    const prevOffset = offset(timezone, prevHour);\n    return currentOffset < prevOffset;\n}\nfunction shiftZoneMissingHour(utcDate, timezone) {\n    // Adjust for missing hour during DST transition in timezone.\n    const dstOffset = isZoneMissingHour(utcDate, timezone) ? 1 : 0;\n    return addHours(utcDate, dstOffset);\n}\nfunction convertTimezoneUTC(utcLocal, fromTimezone, toTimezone) {\n    if (fromTimezone === toTimezone) {\n        return utcLocal;\n    }\n    const fromOffset = offset(fromTimezone, utcLocal);\n    const toOffset = offset(toTimezone, utcLocal);\n    const baseDiff = fromOffset - toOffset;\n    const midDate = addMinutes(utcLocal, baseDiff);\n    const midOffset = offset(toTimezone, midDate);\n    const dstDiff = toOffset - midOffset;\n    return addMinutes(utcLocal, baseDiff + dstDiff);\n}\nfunction formatOffset(tzOffset) {\n    const sign = tzOffset <= 0 ? '+' : '-';\n    const value = Math.abs(tzOffset);\n    const hours = padNumber(Math.floor(value / 60));\n    const minutes = padNumber(value % 60);\n    return `GMT${sign}${hours}${minutes}`;\n}\n/**\n * Represents a local date in a specified timezone.\n *\n * The following example demonstrates how to convert a local date to the specified timezone.\n *\n * @example\n * ```ts-no-run\n * import { ZonedDate } from '@progress/kendo-date-math';\n * import '@progress/kendo-date-math/tz/America/New_York';\n *\n * const date = new Date('2018-03-13T00:00:00Z');\n * const tzDate = ZonedDate.fromLocalDate(date, 'America/New_York');\n *\n * // If you run this example in GMT+0200,\n * // the output will be '2018-03-12T22:00:00.000Z'.\n * console.log(tzDate.toISOString());\n * ```\n *\n * The following example demonstrates how to convert between timezones.\n *\n * @example\n * ```ts-no-run\n * import { ZonedDate } from '@progress/kendo-date-math';\n * import '@progress/kendo-date-math/tz/America/New_York';\n * import '@progress/kendo-date-math/tz/America/Los_Angeles';\n *\n * // Note the \"Z\" suffix for UTC dates.\n * const date = new Date('2018-03-12T22:00:00Z');\n *\n * const tzDate = ZonedDate.fromLocalDate(date, 'America/New_York');\n * const result = tzDate.toTimezone('America/Los_Angeles');\n *\n * // Regardless of the browser timezone\n * // the output will be '2018-03-12T15:00:00.000Z'.\n * console.log(tzDate.toUTCDate());\n * ```\n */\nexport class ZonedDate {\n    /**\n     * Returns a cached local date that denotes the exact time in the set timezone.\n     *\n     * @return Date - A local date that denotes the exact time in the set timezone.\n     *\n     * This property is an alternative to `toLocalDate()` that returns a cached value instead of cloning it.\n     *\n     * > Modifying the returned instance will corrupt the `ZonedDate` state.\n     */\n    get cachedLocalDate() {\n        return this._localDate;\n    }\n    /**\n     * Returns a cached `Date` instance with UTC date parts that are set to the local time in the set timezone.\n     *\n     * @returns Date - A `Date` with UTC date parts that are set to the local time in the set timezone.\n     *\n     * This property is an alternative to `toUTCDate()` that returns a cached value instead of cloning it.\n     *\n     * > Modifying the returned instance will corrupt the `ZonedDate` state.\n     */\n    get cachedUTCDate() {\n        return this._utcDate;\n    }\n    // tslint:disable:max-line-length\n    /**\n     * Converts an existing date to a specified timezone.\n     *\n     * If the `timezone` parameter is omitted, the `ZonedDate` defaults to the timezone of the browser. This concept is known as \"floating date\" because it does not represent a particular moment in time. Instead, its actual value depends on the current timezone of the browser.\n     *\n     * @param date - The local date that represents the actual time instance.\n     * @param timezone - The ID of the timezone that will be assumed. For example, `Europe/Sofia`.\n     * @return ZonedDate - The date in the specified timezone.\n     *\n     * @example\n     * ```ts-no-run\n     * import { ZonedDate } from '@progress/kendo-date-math';\n     * import '@progress/kendo-date-math/tz/America/New_York';\n     *\n     * const date = new Date('2018-03-13T00:00:00');\n     * const tzDate = ZonedDate.fromLocalDate(date, 'America/New_York');\n     *\n     * // If you run this example in GMT+0200,\n     * // the output will be 'Mon Mar 12 2018 18:00:00 GMT+0200 (EET)'.\n     * console.log(tzDate.toString());\n     *\n     * // If you run this example in UTC,\n     * // the output will be '2018-03-12T22:00:00.000Z'.\n     * console.log(tzDate.toISOString());\n     * ```\n     */\n    // tslint:enable:max-line-length\n    static fromLocalDate(date, timezone = '') {\n        const utcDate = convertTimezoneUTC(date, 'Etc/UTC', timezone);\n        const shiftZone = isZoneMissingHour(utcDate, timezone);\n        const zoneOffset = offset(timezone, utcDate);\n        let fixedOffset = 0;\n        if (shiftZone) {\n            // Adjust for the missing hour during the DST transition in the timezone.\n            fixedOffset = zoneOffset > 0 ? -1 : 1;\n        }\n        const adjDate = addHours(utcDate, fixedOffset);\n        return ZonedDate.fromUTCDate(adjDate, timezone);\n    }\n    // tslint:disable:max-line-length\n    /**\n     * Creates a date in a specific timezone from the UTC date parts of the supplied `Date`.\n     *\n     * If the `timezone` parameter is omitted, the `ZonedDate` defaults to the timezone of the browser. This concept is known as \"floating date\" because it does not represent a particular moment in time. Instead, its actual value depends on the current timezone of the browser.\n     *\n     * @param date - The UTC date that represents the time in the target zone. This time is not the actual time instant in UTC.\n     * @param timezone - The ID of the timezone that will be assumed. For example, `Europe/Sofia`.\n     * @return ZonedDate - The date in the specified timezone.\n     *\n     * @example\n     * ```ts-no-run\n     * import { ZonedDate } from '@progress/kendo-date-math';\n     * import '@progress/kendo-date-math/tz/America/New_York';\n     *\n     * // Note the \"Z\" suffix for UTC dates.\n     * const date = new Date('2018-03-12T18:00:00Z');\n     *\n     * // Alternative syntax using Date.UTC\n     * // const date = new Date(Date.UTC(2018, 2, 12, 18, 0));\n     *\n     * const tzDate = ZonedDate.fromUTCDate(date, 'America/New_York');\n     *\n     * // Regardless of the browser timezone\n     * // the output will be 'Mon Mar 12 2018 18:00:00 GMT+0200 (EET)'.\n     * console.log(tzDate.toString());\n     *\n     * // Regardless of the browser timezone\n     * // the output in UTC will be '2018-03-12T22:00:00.000Z'.\n     * console.log(tzDate.toISOString());\n     * ```\n     */\n    // tslint:enable:max-line-length\n    static fromUTCDate(utcDate, timezone = '') {\n        return new ZonedDate(utcDate, timezone);\n    }\n    /**\n     * Returns a local date that denotes the exact time in the set timezone.\n     *\n     * @return Date - A local date that denotes the exact time in the set timezone.\n     *\n     * @example\n     * ```ts-no-run\n     * import { ZonedDate } from '@progress/kendo-date-math';\n     * import '@progress/kendo-date-math/tz/America/New_York';\n     *\n     * // Note the \"Z\" suffix for UTC dates.\n     * const date = new Date('2018-03-12T18:00:00Z');\n     * const tzDate = ZonedDate.fromUTCDate(date, 'America/New_York');\n     *\n     * // The local date represents the same moment in time as the ZonedDate:\n     * // `2018-03-12T22:00:00.000Z`.\n     * console.log(tzDate.toLocalDate().toISOString());\n     *\n     * // The local date will apply the timezone of the browser. For example,\n     * // `Tue Mar 13 2018 00:00:00 GMT+0200 (Eastern European Standard Time)`.\n     * console.log(tzDate.toLocalDate().toString())\n     * ```\n     */\n    toLocalDate() {\n        return cloneDate(this._localDate);\n    }\n    /**\n     * Returns a `Date` instance with UTC date parts that are set to the local time in the set timezone.\n     *\n     * @returns Date - A `Date` with UTC date parts that are set to the local time in the set timezone.\n     *\n     * @example\n     * ```ts-no-run\n     * import { ZonedDate } from '@progress/kendo-date-math';\n     * import '@progress/kendo-date-math/tz/America/New_York';\n     *\n     * // Note the \"Z\" suffix for UTC dates.\n     * const date = new Date('2018-03-12T18:00:00Z');\n     * const tzDate = ZonedDate.fromUTCDate(date, 'America/New_York');\n     *\n     * // Regardless of the browser timezone\n     * // the output will be '2018-03-12T18:00:00.000Z'.\n     * console.log(tzDate.toUTCDate());\n     * ```\n     */\n    toUTCDate() {\n        return cloneDate(this._utcDate);\n    }\n    /**\n     * Converts the date to the specified timezone.\n     *\n     * @param toTimezone - The timezone to which the values will be converted. For example, `America/Los_Angeles`.\n     * @returns ZonedDate - The resulting zoned date.\n     *\n     * @example\n     * ```ts-no-run\n     * import { ZonedDate } from '@progress/kendo-date-math';\n     * import '@progress/kendo-date-math/tz/America/New_York';\n     * import '@progress/kendo-date-math/tz/America/Los_Angeles';\n     *\n     * // Note the \"Z\" suffix for UTC dates.\n     * const date = new Date('2018-03-12T22:00:00Z');\n     *\n     * const tzDate = ZonedDate.fromLocalDate(date, 'America/New_York');\n     * const result = tzDate.toTimezone('America/Los_Angeles');\n     *\n     * // Regardless of the browser timezone\n     * // the output will be '2018-03-12T15:00:00.000Z'.\n     * console.log(tzDate.toUTCDate());\n     * ```\n     */\n    toTimezone(toTimezone) {\n        if (this.timezone === toTimezone) {\n            return this.clone();\n        }\n        const tzOffset = offset(this.timezone, this._utcDate);\n        const date = addMinutes(this._utcDate, tzOffset);\n        return ZonedDate.fromLocalDate(date, toTimezone);\n    }\n    /**\n     * Returns a new instance that represents the same date.\n     *\n     * @returns Date - A copy of the instance of the current zoned date.\n     */\n    clone() {\n        return ZonedDate.fromUTCDate(this._utcDate, this.timezone);\n    }\n    // tslint:disable:max-line-length\n    /**\n     * Adds the specified number of days and returns a new instance with the resulting date in the same timezone.\n     *\n     * @param days - The number of days that will be added.\n     * @returns ZonedDate - The resulting date.\n     */\n    // tslint:enable:max-line-length\n    addDays(days) {\n        const newDate = new Date(this._utcDate.getTime());\n        newDate.setUTCDate(newDate.getUTCDate() + days);\n        return ZonedDate.fromUTCDate(newDate, this.timezone);\n    }\n    // tslint:disable:max-line-length\n    /**\n     * Adds the specified number of milliseconds and returns a new instance with the resulting date in the same timezone.\n     *\n     * The method compensates for DST transitions and ensures that the resulting date occurs exactly after the set amount of time in the timezone.\n     *\n     * @param milliseconds - The number of days that will be added.\n     * @returns ZonedDate - The resulting date.\n     */\n    // tslint:enable:max-line-length\n    addTime(milliseconds) {\n        const utcDate = new Date(this._utcDate.getTime());\n        const utcMid = shiftZoneMissingHour(utcDate, this.timezone);\n        utcMid.setTime(utcMid.getTime() + milliseconds);\n        const utcResult = shiftZoneMissingHour(utcMid, this.timezone);\n        return ZonedDate.fromUTCDate(utcResult, this.timezone);\n    }\n    // tslint:disable:max-line-length\n    /**\n     * Returns a new instance of the same zoned date having its time parts set to `00:00:00.000`.\n     *\n     * @returns ZonedDate - The same date having its time parts set to `00:00:00.000`.\n     */\n    // tslint:enable:max-line-length\n    stripTime() {\n        const date = this._utcDate;\n        const ticks = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);\n        return ZonedDate.fromUTCDate(new Date(ticks), this.timezone);\n    }\n    /**\n     * @hidden\n     */\n    getTime() {\n        return this._localDate.getTime();\n    }\n    /**\n     * @hidden\n     */\n    getTimezoneOffset() {\n        return this.timezoneOffset;\n    }\n    /**\n     * @hidden\n     */\n    getFullYear() {\n        return this._utcDate.getUTCFullYear();\n    }\n    /**\n     * @hidden\n     */\n    getMonth() {\n        return this._utcDate.getUTCMonth();\n    }\n    /**\n     * @hidden\n     */\n    getDate() {\n        return this._utcDate.getUTCDate();\n    }\n    /**\n     * @hidden\n     */\n    getDay() {\n        return this._utcDate.getUTCDay();\n    }\n    /**\n     * @hidden\n     */\n    getHours() {\n        return this._utcDate.getUTCHours();\n    }\n    /**\n     * @hidden\n     */\n    getMinutes() {\n        return this._utcDate.getUTCMinutes();\n    }\n    /**\n     * @hidden\n     */\n    getSeconds() {\n        return this._utcDate.getUTCSeconds();\n    }\n    /**\n     * @hidden\n     */\n    getMilliseconds() {\n        return this._utcDate.getUTCMilliseconds();\n    }\n    // The local date UTC parts represent actual UTC time\n    /**\n     * @hidden\n     */\n    getUTCDate() {\n        return this._localDate.getUTCDate();\n    }\n    /**\n     * @hidden\n     */\n    getUTCDay() {\n        return this._localDate.getUTCDay();\n    }\n    /**\n     * @hidden\n     */\n    getUTCFullYear() {\n        return this._localDate.getUTCFullYear();\n    }\n    /**\n     * @hidden\n     */\n    getUTCHours() {\n        return this._localDate.getUTCHours();\n    }\n    /**\n     * @hidden\n     */\n    getUTCMilliseconds() {\n        return this._localDate.getUTCMilliseconds();\n    }\n    /**\n     * @hidden\n     */\n    getUTCMinutes() {\n        return this._localDate.getUTCMinutes();\n    }\n    /**\n     * @hidden\n     */\n    getUTCMonth() {\n        return this._localDate.getUTCMonth();\n    }\n    /** @hidden */\n    getUTCSeconds() {\n        return this._localDate.getUTCSeconds();\n    }\n    /** @hidden */\n    setTime(time) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setMilliseconds(ms) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setUTCMilliseconds(ms) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setSeconds(sec, ms) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setUTCSeconds(sec, ms) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setMinutes(min, sec, ms) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setUTCMinutes(min, sec, ms) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setHours(hours, min, sec, ms) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setUTCHours(hours, min, sec, ms) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setDate(date) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setUTCDate(date) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setMonth(month, date) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setUTCMonth(month, date) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setFullYear(year, month, date) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @hidden */\n    setUTCFullYear(year, month, date) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /**\n     * @hidden\n     */\n    toISOString() {\n        return this._localDate.toISOString();\n    }\n    /**\n     * @hidden\n     */\n    toJSON() {\n        return this._localDate.toJSON();\n    }\n    /**\n     * @hidden\n     */\n    toString() {\n        const dateString = datePrefix(this._utcDate);\n        const timeString = this.toTimeString();\n        return `${dateString} ${this.getDate()} ${this.getFullYear()} ${timeString}`;\n    }\n    /** @hidden */\n    toDateString() {\n        return toLocalDate(this._utcDate).toDateString();\n    }\n    /** @hidden */\n    toTimeString() {\n        const hours = padNumber(this.getHours());\n        const minutes = padNumber(this.getMinutes());\n        const seconds = padNumber(this.getSeconds());\n        const time = `${hours}:${minutes}:${seconds}`;\n        const tzOffset = formatOffset(this.timezoneOffset);\n        let abbrev = abbrTimezone(this.timezone, this._utcDate);\n        if (abbrev) {\n            abbrev = ` (${abbrev})`;\n        }\n        return `${time} ${tzOffset}${abbrev}`;\n    }\n    toLocaleString(locales, options) {\n        return this._localDate.toLocaleString(locales, options);\n    }\n    toLocaleDateString(locales, options) {\n        return this._localDate.toLocaleDateString(locales, options);\n    }\n    toLocaleTimeString(locales, options) {\n        return this._localDate.toLocaleTimeString(locales, options);\n    }\n    /** @hidden */\n    toUTCString() {\n        return this.toTimezone('Etc/UTC').toString();\n    }\n    /**\n     * @returns - A primitive value.\n    */\n    [Symbol.toPrimitive](hint) {\n        if (hint === 'string' || hint === 'default') {\n            return this.toString();\n        }\n        return this._localDate.getTime();\n    }\n    /** @hidden */\n    valueOf() {\n        return this.getTime();\n    }\n    /** @hidden */\n    getVarDate() {\n        throw new Error('Not implemented.');\n    }\n    /** @hidden */\n    format(_) {\n        throw new Error('Not implemented.');\n    }\n    /** @hidden */\n    formatUTC(_) {\n        throw new Error('Not implemented.');\n    }\n    // The constructor is aliased as a static fromUTCDate method\n    // to clarify the meaning of the utcDate parameter.\n    //\n    // It can be confused for a local date time while it is in fact\n    // treated as a UTC date that represents the local date in the timezone.\n    constructor(utcDate, timezone) {\n        this._utcDate = cloneDate(utcDate);\n        this.timezone = timezone;\n        const tzOffset = offset(timezone, utcDate);\n        this.timezoneOffset = tzOffset;\n        const localDate = shiftZoneMissingHour(utcDate, timezone);\n        this._localDate = convertTimezoneUTC(localDate, timezone, 'Etc/UTC');\n    }\n}\n","import { timezones } from './timezones';\n/**\n * A function that returns all timezones which match the title of the zone.\n *\n * @param group - The fully qualified zone title. For example, Central Standard Time.\n *\n * @return - Returns the list of all matching timezone names. For example, `[America/Chicago, ...]`.\n *\n * @example\n * ```ts-no-run\n * zonesPerGroup('(GMT+01:00) Amsterdam, Berlin'); // ['Europe/Amsterdam', 'Europe/Berlin'...]\n * ```\n */\nexport const zonesPerGroup = (group) => {\n    const { titles } = timezones;\n    return Object.keys(titles).reduce((result, title) => {\n        const info = titles[title] || {};\n        return info.group === group ? result.concat(title.split(' ')) : result;\n    }, []);\n};\n","import { Day } from './day.enum';\nimport { addDays } from './add-days';\nimport { createDate } from './create-date';\nimport { prevDayOfWeek } from './prev-day-of-week';\nimport { MS_PER_DAY } from './constants';\nimport { getDate } from './get-date';\nconst moveDateToWeekStart = (date, weekStartDay) => {\n    if (weekStartDay !== Day.Monday) {\n        return addDays(prevDayOfWeek(date, weekStartDay), 4);\n    }\n    return addDays(date, (4 - (date.getDay() || 7)));\n};\nconst calcWeekInYear = (date, weekStartDay) => {\n    const firstWeekInYear = createDate(date.getFullYear(), 0, 1, -6);\n    const newDate = moveDateToWeekStart(date, weekStartDay);\n    const diffInMS = newDate.getTime() - firstWeekInYear.getTime();\n    const days = Math.floor(diffInMS / MS_PER_DAY);\n    return 1 + Math.floor(days / 7);\n};\n/**\n * A function that returns the number of the week within a year, which is calculated in relation to the date.\n *\n * For more information, refer to the [**ISO week date**](https://en.wikipedia.org/wiki/ISO_week_date) article.\n *\n * @param date - The date used for the week number calculation.\n * @param weekStartDay - The first day of the week. By default, the first week day is Monday.\n * @returns - The number of the week within the year.\n *\n * @example\n * ```ts-no-run\n * weekInYear(new Date(2016, 0, 1)); // Week 53, 2015\n * weekInYear(new Date(2016, 0, 5)); // Week 1, 2016\n * weekInYear(new Date(2017, 0, 1)); // Week 52, 2016\n * weekInYear(new Date(2017, 0, 2)); // Week 1, 2017\n * ```\n */\nexport const weekInYear = (date, weekStartDay = Day.Monday) => {\n    date = getDate(date);\n    const prevWeekDate = addDays(date, -7);\n    const nextWeekDate = addDays(date, 7);\n    const weekNumber = calcWeekInYear(date, weekStartDay);\n    if (weekNumber === 0) {\n        return calcWeekInYear(prevWeekDate, weekStartDay) + 1;\n    }\n    if (weekNumber === 53 && calcWeekInYear(nextWeekDate, weekStartDay) > 1) {\n        return 1;\n    }\n    return weekNumber;\n};\n","export class Mask {\n    constructor() {\n        this.symbols = '';\n        this.partMap = [];\n    }\n}\n","export const Constants = {\n    formatSeparator: \"_\",\n    twoDigitYearMax: 68,\n    defaultDateFormat: \"d\",\n    defaultLocaleId: \"en\"\n};\n","export const Key = {\n    DELETE: \"Delete\",\n    BACKSPACE: \"Backspace\",\n    TAB: \"Tab\",\n    ENTER: \"Enter\",\n    ESCAPE: \"Escape\",\n    ARROW_LEFT: \"ArrowLeft\",\n    ARROW_UP: \"ArrowUp\",\n    ARROW_RIGHT: \"ArrowRight\",\n    ARROW_DOWN: \"ArrowDown\",\n    SPACE: \" \",\n    END: \"End\",\n    HOME: \"Home\",\n    PAGE_UP: \"PageUp\",\n    PAGE_DOWN: \"PageDown\"\n};\n","import { Constants } from '../common/constants';\nimport { Key } from '../common/key';\n/**\n * @hidden\n */\nexport const padZero = (length) => new Array(Math.max(length, 0)).fill('0').join('');\n/**\n * @hidden\n */\nexport const unpadZero = (value) => value.replace(/^0*/, '');\n/**\n * @hidden\n */\nexport const approximateStringMatching = ({ oldText, newText, formatPattern, selectionStart, isInCaretMode, keyEvent }) => {\n    /*\n      Remove the right part of the cursor.\n      oldFormat = oldFormat.substring(0, caret + oldText.length - newText.length);\n    */\n    const oldIndex = selectionStart + oldText.length - newText.length;\n    const oldTextSeparator = oldText[oldIndex];\n    const oldSegmentText = oldText.substring(0, oldIndex);\n    const newSegmentText = newText.substring(0, selectionStart);\n    const diff = [];\n    /* Handle the typing of a single character over the same selection. */\n    if (oldSegmentText === newSegmentText && selectionStart > 0) {\n        diff.push([formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]);\n        return diff;\n    }\n    if (oldSegmentText.indexOf(newSegmentText) === 0 && (isInCaretMode &&\n        (keyEvent.key === Key.DELETE || keyEvent.key === Key.BACKSPACE)) ||\n        (oldSegmentText.indexOf(newSegmentText) === 0 && !isInCaretMode &&\n            (newSegmentText.length === 0 ||\n                formatPattern[newSegmentText.length - 1] !== formatPattern[newSegmentText.length]))) {\n        /* Handle Delete/Backspace. */\n        let deletedSymbol = '';\n        /*\n            The whole text is replaced by the same character.\n            A nasty patch is required to keep the selection in the first segment.\n        */\n        if (!isInCaretMode && newSegmentText.length === 1) {\n            diff.push([formatPattern[0], newSegmentText[0]]);\n        }\n        for (let i = newSegmentText.length; i < oldSegmentText.length; i++) {\n            if (formatPattern[i] !== deletedSymbol && formatPattern[i] !== Constants.formatSeparator) {\n                deletedSymbol = formatPattern[i];\n                diff.push([deletedSymbol, '']);\n            }\n        }\n        return diff;\n    }\n    /*\n        Handle the insertion of the text (the new text is longer than the previous one).\n        Handle the typing over a literal as well.\n    */\n    if ((isInCaretMode &&\n        (newSegmentText.indexOf(oldSegmentText) === 0 ||\n            formatPattern[selectionStart - 1] === Constants.formatSeparator)) ||\n        (!isInCaretMode &&\n            (newSegmentText.indexOf(oldSegmentText) === 0 ||\n                formatPattern[selectionStart - 1] === Constants.formatSeparator))) {\n        let symbol = formatPattern[0];\n        for (let i = Math.max(0, oldSegmentText.length - 1); i < formatPattern.length; i++) {\n            if (formatPattern[i] !== Constants.formatSeparator) {\n                symbol = formatPattern[i];\n                break;\n            }\n        }\n        return [[symbol, newSegmentText[selectionStart - 1]]];\n    }\n    /* Handle the entering of a space or a separator for navigating to the next item. */\n    if ((newSegmentText[newSegmentText.length - 1] === ' ') ||\n        (newSegmentText[newSegmentText.length - 1] === oldTextSeparator && formatPattern[oldIndex] === '_')) {\n        return [[formatPattern[selectionStart - 1], Constants.formatSeparator]];\n    }\n    /* Handle typing over a correctly selected part. */\n    const result = [[formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]];\n    return result;\n};\n/**\n * @hidden\n */\nexport const dateSymbolMap = (map, part) => {\n    map[part.pattern[0]] = part.type;\n    return map;\n};\n/**\n * @hidden\n */\nexport const isInRange = (candidate, min, max) => (candidate === null || !((min && min > candidate) || (max && max < candidate)));\n","import { cloneDate } from '@progress/kendo-date-math';\nconst isObject = (value) => value && typeof (value) === \"object\" && !Array.isArray(value);\nconst isHtmlElement = (element) => element instanceof HTMLElement;\nconst dateSetter = (method) => (date, value) => {\n    const clone = cloneDate(date);\n    clone[method](value);\n    return clone;\n};\n/**\n * @hidden\n */\nexport const isPresent = (value) => value !== undefined && value !== null;\n/**\n * @hidden\n */\nexport const isDocumentAvailable = () => !!document;\n/**\n * @hidden\n */\nexport const isNumber = (value) => isPresent(value) && typeof (value) === \"number\" && !Number.isNaN(value);\n/**\n * @hidden\n */\nexport const parseToInt = (value) => parseInt(value, 10);\n/**\n * @hidden\n */\nexport const isParseableToInt = (value) => isNumber(parseToInt(value)) && /^[0-9]+$/.test(value);\n/**\n * @hidden\n */\nexport const clamp = (value, min, max) => Math.min(max, Math.max(min, value));\n/**\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nexport const extend = (...args) => Object.assign(...args);\n/**\n * @hidden\n */\nexport const deepExtend = (target, ...sources) => {\n    if (!sources.length) {\n        return target;\n    }\n    const source = sources.shift();\n    if (isObject(target) && isObject(source)) {\n        for (const key in source) {\n            if (!Object.prototype.hasOwnProperty.call(source, key) ||\n                key === \"__proto__\" ||\n                key === \"constructor\" ||\n                key === \"prototype\") {\n                continue;\n            }\n            if (isHtmlElement(source[key])) {\n                target[key] = source[key];\n            }\n            else if (isObject(source[key]) && !(source[key] instanceof Date)) {\n                if (!target[key] || !isObject(target[key])) {\n                    extend(target, { [key]: {} });\n                }\n                deepExtend(target[key], source[key]);\n            }\n            else {\n                extend(target, { [key]: source[key] });\n            }\n        }\n    }\n    return deepExtend(target, ...sources);\n};\n/**\n * @hidden\n */\n// eslint-disable-next-line\nexport const noop = () => { };\n/**\n * @hidden\n */\nexport const isFunction = (fn) => typeof (fn) === \"function\";\n/**\n * @hidden\n */\nexport const cropTwoDigitYear = (date) => {\n    if (!isPresent(date) || isNaN(date.getTime())) {\n        return 0;\n    }\n    return Number(date\n        .getFullYear()\n        .toString()\n        .slice(-2));\n};\n/**\n * @hidden\n */\nexport const setYears = dateSetter('setFullYear');\n/**\n * @hidden\n */\nexport const millisecondDigitsInFormat = (format) => {\n    const result = format && format.match(/S+(\\1)/);\n    return result ? result[0].length : 0;\n};\n/**\n * @hidden\n */\nexport const millisecondStepFor = (digits) => {\n    return Math.pow(10, 3 - digits);\n};\n/**\n * @hidden\n */\nexport const areDatePartsEqualTo = (date, year, month, day, hour, minutes, seconds, milliseconds) => {\n    if (date &&\n        date.getFullYear() === year &&\n        date.getMonth() === month &&\n        date.getDate() === day &&\n        date.getHours() === hour &&\n        date.getMinutes() === minutes &&\n        date.getSeconds() === seconds &&\n        date.getMilliseconds() === milliseconds) {\n        return true;\n    }\n    return false;\n};\n/**\n * @hidden\n */\nexport const isValidDate = (value) => isPresent(value) && value.getTime && isNumber(value.getTime());\n/**\n * @hidden\n */\nexport const isIOS = () => /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.maxTouchPoints &&\n    navigator.maxTouchPoints > 2 &&\n    /Macintosh/i.test(navigator.userAgent));\n","import { addMonths, cloneDate, createDate, isEqual, getDate, lastDayOfMonth } from '@progress/kendo-date-math';\nimport { Mask } from './mask';\nimport { dateSymbolMap, padZero, unpadZero } from '../dateinput/utils';\nimport { extend, isPresent, cropTwoDigitYear, setYears, parseToInt, clamp, areDatePartsEqualTo, isNumber, isValidDate, isParseableToInt } from './utils';\nimport { Constants } from './constants';\nconst MONTH_INDEX_FEBRUARY = 1;\nconst DEFAULT_LEAP_YEAR = 2000;\nconst PREVIOUS_CENTURY_BASE = 1900;\nconst CURRENT_CENTURY_BASE = 2000;\nconst SHORT_PATTERN_LENGTH_REGEXP = /d|M|H|h|m|s/;\nconst MONTH_PART_WITH_WORDS_THRESHOLD = 2;\nconst MONTH_SYMBOL = \"M\";\n// JS months start from 0 (January) instead of 1 (January)\nconst JS_MONTH_OFFSET = 1;\nexport class DateObject {\n    set value(value) {\n        if (value && !(value instanceof Date)) {\n            // throw new Error(\"The 'value' should be a valid JavaScript Date instance.\");\n            return;\n        }\n        this._value = value;\n        this.resetInvalidDate();\n    }\n    get value() {\n        return this._value;\n    }\n    get localeId() {\n        let localeId = Constants.defaultLocaleId;\n        const cldrKeys = Object.keys(this.intl.cldr);\n        for (let i = 0; i < cldrKeys.length; i++) {\n            const key = cldrKeys[i];\n            const value = this.intl.cldr[key];\n            if (value.name && value.calendar && value.numbers &&\n                value.name !== Constants.defaultLocaleId) {\n                localeId = value.name;\n                break;\n            }\n        }\n        return localeId;\n    }\n    constructor({ intlService, formatPlaceholder, format, cycleTime = false, twoDigitYearMax = Constants.twoDigitYearMax, value = null, autoCorrectParts = true, toggleDayPeriod = false, autoSwitchParts = true }) {\n        this.year = true;\n        this.month = true;\n        this.date = true;\n        this.hours = true;\n        this.minutes = true;\n        this.seconds = true;\n        this.milliseconds = true;\n        this.dayperiod = true;\n        this.leadingZero = null;\n        this.typedMonthPart = '';\n        this.knownParts = 'adHhmMsEyS';\n        this.symbols = {\n            'E': 'E',\n            'H': 'H',\n            'M': 'M',\n            'a': 'a',\n            'd': 'd',\n            'h': 'h',\n            'm': 'm',\n            's': 's',\n            'y': 'y',\n            'S': 'S'\n        };\n        this._value = this.getDefaultDate();\n        this.cycleTime = false;\n        this._partiallyInvalidDate = {\n            startDate: null,\n            invalidDateParts: {\n                'E': { value: null, date: null, startDateOffset: 0 },\n                'H': { value: null, date: null, startDateOffset: 0 },\n                'M': { value: null, date: null, startDateOffset: 0 },\n                'a': { value: null, date: null, startDateOffset: 0 },\n                'd': { value: null, date: null, startDateOffset: 0 },\n                'h': { value: null, date: null, startDateOffset: 0 },\n                'm': { value: null, date: null, startDateOffset: 0 },\n                's': { value: null, date: null, startDateOffset: 0 },\n                'y': { value: null, date: null, startDateOffset: 0 },\n                'S': { value: null, date: null, startDateOffset: 0 }\n            }\n        };\n        this.setOptions({\n            intlService,\n            formatPlaceholder,\n            format,\n            cycleTime,\n            twoDigitYearMax,\n            value,\n            autoCorrectParts,\n            toggleDayPeriod,\n            autoSwitchParts\n        });\n        if (!value) {\n            this._value = this.getDefaultDate();\n            const sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n            for (let i = 0; i < sampleFormat.length; i++) {\n                this.setExisting(sampleFormat[i], false);\n            }\n        }\n        else {\n            this._value = cloneDate(value);\n        }\n    }\n    /**\n     * @hidden\n     */\n    setOptions(options) {\n        this.intl = options.intlService;\n        this.formatPlaceholder = options.formatPlaceholder || 'wide';\n        this.format = options.format;\n        this.cycleTime = options.cycleTime;\n        this.monthNames = this.allFormattedMonths(this.localeId);\n        this.dayPeriods = this.allDayPeriods(this.localeId);\n        this.twoDigitYearMax = options.twoDigitYearMax;\n        this.autoCorrectParts = options.autoCorrectParts;\n        this.toggleDayPeriod = options.toggleDayPeriod;\n        this.autoSwitchParts = options.autoSwitchParts;\n    }\n    setValue(value) {\n        if (!value) {\n            this._value = this.getDefaultDate();\n            this.modifyExisting(false);\n        }\n        else if (!isEqual(value, this._value)) {\n            this._value = cloneDate(value);\n            this.modifyExisting(true);\n        }\n        else if (isEqual(value, this._value) && this.dayPeriods) {\n            this.setExisting('a', true);\n        }\n        this.resetInvalidDate();\n    }\n    /**\n     * @hidden\n     */\n    hasValue() {\n        const pred = (a, p) => a || p.type !== 'literal' && p.type !== 'dayperiod' && this.getExisting(p.pattern[0]);\n        return this.intl.splitDateFormat(this.format, this.localeId).reduce(pred, false);\n    }\n    /**\n     * @hidden\n     */\n    getValue() {\n        for (let i = 0; i < this.knownParts.length; i++) {\n            if (!this.getExisting(this.knownParts[i])) {\n                return null;\n            }\n        }\n        return cloneDate(this.value);\n    }\n    /**\n     * @hidden\n     */\n    createDefaultDate() {\n        // use the leap year 2000 that has 29th February\n        // and a month that has 31 days\n        // so that the default date can accommodate maximum date values\n        // it is better to use a fixed date instead of new Date()\n        return createDate(DEFAULT_LEAP_YEAR, 0, 31);\n    }\n    /**\n     * @hidden\n     */\n    getDefaultDate() {\n        return getDate(this.createDefaultDate());\n    }\n    /**\n     * @hidden\n     */\n    getFormattedDate(format) {\n        return this.intl.formatDate(this.getValue(), format, this.localeId);\n    }\n    /**\n     * @hidden\n     */\n    getTextAndFormat(customFormat = \"\") {\n        const format = customFormat || this.format;\n        let text = this.intl.formatDate(this.value, format, this.localeId);\n        const mask = this.dateFormatString(this.value, format);\n        if (!this.autoCorrectParts && this._partiallyInvalidDate.startDate) {\n            let partiallyInvalidText = \"\";\n            const formattedDate = this.intl.formatDate(this.value, format, this.localeId);\n            const formattedDates = this.getFormattedInvalidDates(format);\n            for (let i = 0; i < formattedDate.length; i++) {\n                const symbol = mask.symbols[i];\n                if (mask.partMap[i].type === \"literal\") {\n                    partiallyInvalidText += text[i];\n                }\n                else if (this.getInvalidDatePartValue(symbol)) {\n                    const partsForSegment = this.getPartsForSegment(mask, i);\n                    if (symbol === \"M\") {\n                        const datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();\n                        if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {\n                            partiallyInvalidText += formattedDates[symbol][i];\n                        }\n                        else {\n                            if (this.getInvalidDatePartValue(symbol)) {\n                                const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n                                partiallyInvalidText += formattedDatePart;\n                                // add -1 as the first character in the segment is at index i\n                                i += partsForSegment.length - 1;\n                            }\n                            else {\n                                partiallyInvalidText += formattedDates[symbol][i];\n                            }\n                        }\n                    }\n                    else {\n                        if (this.getInvalidDatePartValue(symbol)) {\n                            const datePartText = this.getInvalidDatePartValue(symbol).toString();\n                            const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n                            partiallyInvalidText += formattedDatePart;\n                            // add -1 as the first character in the segment is at index i\n                            i += partsForSegment.length - 1;\n                        }\n                        else {\n                            partiallyInvalidText += formattedDates[symbol][i];\n                        }\n                    }\n                }\n                else {\n                    partiallyInvalidText += text[i];\n                }\n            }\n            text = partiallyInvalidText;\n        }\n        const result = this.merge(text, mask);\n        return result;\n    }\n    /**\n     * @hidden\n     */\n    getFormattedInvalidDates(customFormat = \"\") {\n        const format = customFormat || this.format;\n        const formattedDatesForSymbol = {\n            'E': '',\n            'H': '',\n            'M': '',\n            'a': '',\n            'd': '',\n            'h': '',\n            'm': '',\n            's': '',\n            'y': '',\n            'S': ''\n        };\n        Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n            const date = this.getInvalidDatePart(key).date;\n            if (date) {\n                const formattedInvalidDate = this.intl.formatDate(date, format, this.localeId);\n                formattedDatesForSymbol[key] = formattedInvalidDate;\n            }\n        });\n        return formattedDatesForSymbol;\n    }\n    modifyExisting(value) {\n        const sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n        for (let i = 0; i < sampleFormat.length; i++) {\n            this.setExisting(sampleFormat[i], value);\n        }\n    }\n    /**\n     * @hidden\n     */\n    getExisting(symbol) {\n        switch (symbol) {\n            case 'y': return this.year;\n            case 'M':\n            case 'L': return this.month;\n            case 'd': return this.date;\n            case 'E': return this.date && this.month && this.year;\n            case 'h':\n            case 'H': return this.hours;\n            case 't':\n            case 'a': return this.dayperiod;\n            case 'm': return this.minutes;\n            case 's': return this.seconds;\n            case \"S\": return this.milliseconds;\n            default:\n                return true;\n        }\n    }\n    setExisting(symbol, value) {\n        switch (symbol) {\n            case 'y':\n                // allow 2/29 dates\n                this.year = value;\n                if (value === false) {\n                    this._value.setFullYear(DEFAULT_LEAP_YEAR);\n                }\n                break;\n            case 'M':\n                // make sure you can type 31 in the day part\n                this.month = value;\n                if (value === false) {\n                    if (this.autoCorrectParts) {\n                        this._value.setMonth(0);\n                    }\n                }\n                break;\n            case 'd':\n                this.date = value;\n                break;\n            case 'h':\n            case 'H':\n                this.hours = value;\n                break;\n            case 't':\n            case 'a':\n                this.dayperiod = value;\n                break;\n            case 'm':\n                this.minutes = value;\n                break;\n            case 's':\n                this.seconds = value;\n                break;\n            case \"S\":\n                this.milliseconds = value;\n                break;\n            default:\n                break;\n        }\n        if (this.getValue()) {\n            this.resetInvalidDate();\n        }\n    }\n    modifyPart(symbol, offset) {\n        if (!isPresent(symbol) || !isPresent(offset) || offset === 0) {\n            return;\n        }\n        let newValue = cloneDate(this.value);\n        let timeModified = false;\n        let invalidDateFound;\n        const isMonth = symbol === \"M\";\n        const isDay = symbol === \"d\" || symbol === \"E\";\n        const symbolExists = this.getExisting(symbol);\n        if (!this.autoCorrectParts && (isDay || isMonth)) {\n            const invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};\n            const invalidDatePartValue = this.getInvalidDatePartValue(symbol);\n            let year = invalidDateParts.y.value || newValue.getFullYear();\n            let month = invalidDateParts.M.value || newValue.getMonth();\n            let day = invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();\n            const hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();\n            const minutes = invalidDateParts.m.value || newValue.getMinutes();\n            const seconds = invalidDateParts.s.value || newValue.getSeconds();\n            const milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();\n            switch (symbol) {\n                case 'y':\n                    year += offset;\n                    break;\n                case 'M':\n                    month += offset;\n                    break;\n                case 'd':\n                case 'E':\n                    day += offset;\n                    break;\n                // case 'h':\n                // case 'H': hour += offset; break;\n                // case 'm': minutes += offset; break;\n                // case 's': seconds += offset; break;\n                // case 'S': milliseconds += offset; break;\n                default: break;\n            }\n            if (symbol === \"M\") {\n                if ((month < 0 || month > 11)) {\n                    if (symbolExists) {\n                        this.setExisting(symbol, false);\n                        this.resetInvalidDateSymbol(symbol);\n                        return;\n                    }\n                }\n                if (!symbolExists) {\n                    if (month < 0) {\n                        month = clamp(11 + ((month % 11) + 1), 0, 11);\n                    }\n                    else {\n                        const monthValue = isPresent(invalidDatePartValue) ?\n                            month :\n                            ((offset - JS_MONTH_OFFSET) % 12);\n                        month = clamp(monthValue, 0, 11);\n                    }\n                    month = clamp(month, 0, 11);\n                }\n                month = clamp(month, 0, 11);\n            }\n            else if (symbol === \"d\") {\n                if (symbolExists) {\n                    if (day <= 0 || day > 31) {\n                        this.setExisting(symbol, false);\n                        this.resetInvalidDateSymbol(symbol);\n                        return;\n                    }\n                }\n                else if (!symbolExists) {\n                    if (isPresent(invalidDatePartValue)) {\n                        if (day <= 0 || day > 31) {\n                            this.setExisting(symbol, false);\n                            this.resetInvalidDateSymbol(symbol);\n                            return;\n                        }\n                    }\n                    if (offset < 0) {\n                        const dayValue = isPresent(invalidDatePartValue) ? day : 1 + (31 - Math.abs(offset % 31));\n                        day = clamp(dayValue, 1, 31);\n                    }\n                    else {\n                        const dayValue = isPresent(invalidDatePartValue) ? day : offset % 31;\n                        day = clamp(dayValue, 1, 31);\n                    }\n                    day = clamp(day, 1, 31);\n                }\n            }\n            const dateCandidate = createDate(year, month, day, hour, minutes, seconds, milliseconds);\n            const newValueCandidate = isMonth || isDay ?\n                this.modifyDateSymbolWithValue(newValue, symbol, isMonth ? month : day) :\n                null;\n            const dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);\n            if (this.getValue() && areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds)) {\n                newValue = cloneDate(dateCandidate);\n                this.markDatePartsAsExisting();\n            }\n            else if (isMonth && newValueCandidate) {\n                if (newValueCandidate.getMonth() === month) {\n                    if (this.getExisting(\"d\")) {\n                        if (dateCandidateExists) {\n                            newValue = cloneDate(dateCandidate);\n                            this.resetInvalidDateSymbol(symbol);\n                        }\n                        else {\n                            invalidDateFound = true;\n                            this.setInvalidDatePart(symbol, {\n                                value: month,\n                                date: cloneDate(newValueCandidate),\n                                startDateOffset: offset,\n                                startDate: cloneDate(this.value)\n                            });\n                            this.setExisting(symbol, false);\n                        }\n                    }\n                    else if (dateCandidateExists) {\n                        this.resetInvalidDateSymbol(symbol);\n                        newValue = cloneDate(dateCandidate);\n                        if (this.getExisting(\"M\") && this.getExisting(\"y\")) {\n                            // changing from 28/Feb to 29/Feb to 29/March\n                            this.setExisting(\"d\", true);\n                            this.resetInvalidDateSymbol(\"d\");\n                        }\n                    }\n                    else {\n                        this.resetInvalidDateSymbol(symbol);\n                        newValue = cloneDate(newValueCandidate);\n                    }\n                }\n                else {\n                    invalidDateFound = true;\n                    this.setInvalidDatePart(symbol, {\n                        value: month,\n                        date: cloneDate(newValueCandidate),\n                        startDateOffset: offset,\n                        startDate: cloneDate(this.value)\n                    });\n                    this.setExisting(symbol, false);\n                }\n            }\n            else if (isDay && newValueCandidate) {\n                if (newValueCandidate.getDate() === day) {\n                    if (this.getExisting(\"M\")) {\n                        if (dateCandidateExists) {\n                            newValue = cloneDate(dateCandidate);\n                            this.resetInvalidDateSymbol(symbol);\n                        }\n                        else {\n                            invalidDateFound = true;\n                            this.setInvalidDatePart(symbol, {\n                                value: day,\n                                date: cloneDate(newValueCandidate),\n                                startDateOffset: offset,\n                                startDate: cloneDate(this.value)\n                            });\n                            this.setExisting(symbol, false);\n                        }\n                    }\n                    else if (dateCandidateExists) {\n                        newValue = cloneDate(dateCandidate);\n                        this.resetInvalidDateSymbol(symbol);\n                        if (this.getExisting(\"d\") && this.getExisting(\"y\")) {\n                            // changing from 31/Jan to 31/Feb to 28/Feb\n                            this.setExisting(\"M\", true);\n                            this.resetInvalidDateSymbol(\"M\");\n                        }\n                    }\n                    else {\n                        this.resetInvalidDateSymbol(symbol);\n                        newValue = cloneDate(newValueCandidate);\n                    }\n                }\n                else {\n                    invalidDateFound = true;\n                    this.setInvalidDatePart(symbol, {\n                        value: day,\n                        date: cloneDate(this.value),\n                        startDateOffset: offset,\n                        startDate: cloneDate(this.value)\n                    });\n                    this.setExisting(symbol, false);\n                }\n            }\n        }\n        else {\n            const hours = newValue.getHours();\n            switch (symbol) {\n                case 'y':\n                    newValue.setFullYear(newValue.getFullYear() + offset);\n                    break;\n                case 'M':\n                    newValue = addMonths(this.value, offset);\n                    break;\n                case 'd':\n                case 'E':\n                    newValue.setDate(newValue.getDate() + offset);\n                    break;\n                case 'h':\n                case 'H':\n                    newValue.setHours(newValue.getHours() + offset);\n                    timeModified = true;\n                    break;\n                case 'm':\n                    newValue.setMinutes(newValue.getMinutes() + offset);\n                    timeModified = true;\n                    break;\n                case 's':\n                    newValue.setSeconds(newValue.getSeconds() + offset);\n                    timeModified = true;\n                    break;\n                case \"S\":\n                    newValue.setMilliseconds(newValue.getMilliseconds() + offset);\n                    break;\n                case 'a':\n                    if (this.toggleDayPeriod) {\n                        newValue.setHours(hours >= 12 ? hours - 12 : hours + 12);\n                    }\n                    else {\n                        newValue.setHours(newValue.getHours() + (12 * offset));\n                    }\n                    timeModified = true;\n                    break;\n                default: break;\n            }\n        }\n        if (this.shouldNormalizeCentury()) {\n            newValue = this.normalizeCentury(newValue);\n        }\n        if (timeModified && !this.cycleTime && newValue.getDate() !== this._value.getDate()) {\n            // todo: blazor has this fix, but this fails a unit test\n            // newValue.setDate(this._value.getDate());\n            // newValue.setMonth(this._value.getMonth());\n            // newValue.setFullYear(this._value.getFullYear());\n        }\n        if (!invalidDateFound) {\n            this.setExisting(symbol, true);\n            this._value = newValue;\n            if (this.getValue()) {\n                this.resetInvalidDate();\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    parsePart({ symbol, currentChar, resetSegmentValue, cycleSegmentValue, rawTextValue: rawInputValue, isDeleting, originalFormat }) {\n        const isInCaretMode = !cycleSegmentValue;\n        const dateParts = this.dateFormatString(this.value, this.format);\n        const datePartsLiterals = dateParts.partMap\n            .filter(x => x.type === \"literal\")\n            .map((x, index) => {\n            return {\n                datePartIndex: index,\n                type: x.type,\n                pattern: x.pattern,\n                literal: \"\"\n            };\n        });\n        const flatDateParts = dateParts.partMap\n            .map((x) => {\n            return {\n                type: x.type,\n                pattern: x.pattern,\n                text: \"\"\n            };\n        });\n        for (let i = 0; i < datePartsLiterals.length; i++) {\n            const datePart = datePartsLiterals[i];\n            for (let j = 0; j < datePart.pattern.length; j++) {\n                if (datePartsLiterals[i + j]) {\n                    datePartsLiterals[i + j].literal = datePart.pattern[j];\n                }\n            }\n            i += datePart.pattern.length - 1;\n        }\n        for (let i = 0; i < flatDateParts.length; i++) {\n            const datePart = flatDateParts[i];\n            for (let j = 0; j < datePart.pattern.length; j++) {\n                if (flatDateParts[i + j]) {\n                    flatDateParts[i + j].text = datePart.pattern[j];\n                }\n            }\n            i += datePart.pattern.length - 1;\n        }\n        const shouldResetPart = isInCaretMode && symbol === \"M\" && dateParts.partMap\n            .filter(x => x.type === \"month\")\n            .some(x => x.pattern.length > MONTH_PART_WITH_WORDS_THRESHOLD);\n        const parseResult = {\n            value: null,\n            switchToNext: false,\n            resetPart: shouldResetPart,\n            hasInvalidDatePart: false\n        };\n        if (!currentChar) {\n            if (isInCaretMode) {\n                for (let i = 0; i < datePartsLiterals.length; i++) {\n                    const literal = datePartsLiterals[i].literal;\n                    const rawValueStartsWithLiteral = rawInputValue.startsWith(literal);\n                    const rawValueEndsWithLiteral = rawInputValue.endsWith(literal);\n                    const rawValueHasConsecutiveLiterals = rawInputValue.indexOf(literal + literal) >= 0;\n                    if (rawValueStartsWithLiteral || rawValueEndsWithLiteral || rawValueHasConsecutiveLiterals) {\n                        this.resetLeadingZero();\n                        this.setExisting(symbol, false);\n                        this.resetInvalidDateSymbol(symbol);\n                        return extend(parseResult, { value: null, switchToNext: false });\n                    }\n                }\n            }\n            else {\n                this.resetLeadingZero();\n                this.setExisting(symbol, false);\n                this.resetInvalidDateSymbol(symbol);\n                return extend(parseResult, { value: null, switchToNext: false });\n            }\n        }\n        const baseDate = this.intl.formatDate(this.value, this.format, this.localeId);\n        const baseFormat = dateParts.symbols;\n        let replaced = false;\n        let prefix = '';\n        let current = '';\n        let datePartText = '';\n        let basePrefix = '';\n        let baseSuffix = '';\n        let suffix = '';\n        let convertedBaseFormat = \"\";\n        for (let i = 0; i < flatDateParts.length; i++) {\n            convertedBaseFormat += flatDateParts[i].text;\n        }\n        const hasFixedFormat = (this.format === baseFormat) ||\n            (this.format === convertedBaseFormat) ||\n            (this.format === originalFormat) ||\n            (this.format.length === originalFormat.length);\n        const datePartStartIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).indexOf(symbol);\n        const datePartEndIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).lastIndexOf(symbol);\n        const segmentLength = datePartEndIndex - datePartStartIndex + 1;\n        const formatToTextLengthDiff = originalFormat.length - rawInputValue.length;\n        if (isInCaretMode || (!isInCaretMode && !this.autoCorrectParts)) {\n            let segmentCharIndex = 0;\n            for (let i = 0; i < baseDate.length; i++) {\n                if (baseFormat[i] === symbol) {\n                    const existing = this.getExisting(symbol);\n                    if (symbol === \"y\") {\n                        if (!this.hasInvalidDatePart() && this.getExisting(\"y\")) {\n                            current += baseDate[i];\n                        }\n                        else {\n                            const invalidDatePartValue = this.getInvalidDatePartValue(symbol);\n                            if (isPresent(invalidDatePartValue)) {\n                                current += (invalidDatePartValue || \"\").toString()[segmentCharIndex] || \"\";\n                                segmentCharIndex++;\n                            }\n                            else {\n                                current += existing ? baseDate[i] : '0';\n                            }\n                        }\n                    }\n                    else {\n                        current += existing ? baseDate[i] : '0';\n                    }\n                    if (formatToTextLengthDiff > 0) {\n                        if (datePartText.length + formatToTextLengthDiff < segmentLength) {\n                            datePartText += rawInputValue[i] || \"\";\n                        }\n                    }\n                    else {\n                        datePartText += rawInputValue[i] || \"\";\n                    }\n                    replaced = true;\n                }\n                else if (!replaced) {\n                    prefix += baseDate[i];\n                    basePrefix += baseDate[i];\n                }\n                else {\n                    suffix += baseDate[i];\n                    baseSuffix += baseDate[i];\n                }\n            }\n            if (hasFixedFormat) {\n                if (convertedBaseFormat.length < rawInputValue.length) {\n                    datePartText += currentChar;\n                }\n                else if (!isDeleting && originalFormat.length > rawInputValue.length) {\n                    // let the parsing to determine if the incomplete value is valid\n                }\n                if (datePartText.length > segmentLength) {\n                    return extend(parseResult, { value: null, switchToNext: false });\n                }\n            }\n            if (!hasFixedFormat || (hasFixedFormat && !this.autoCorrectParts)) {\n                current = \"\";\n                datePartText = \"\";\n                prefix = \"\";\n                suffix = \"\";\n                replaced = false;\n                let segmentCharIndex = 0;\n                for (let i = 0; i < originalFormat.length; i++) {\n                    if (originalFormat[i] === symbol) {\n                        const existing = this.getExisting(symbol);\n                        if (symbol === \"y\") {\n                            if (!this.hasInvalidDatePart() && this.getExisting(\"y\")) {\n                                current += baseDate[i];\n                            }\n                            else {\n                                const invalidDatePartValue = this.getInvalidDatePartValue(symbol);\n                                if (isPresent(invalidDatePartValue)) {\n                                    current += (invalidDatePartValue || \"\").toString()[segmentCharIndex] || \"\";\n                                    segmentCharIndex++;\n                                }\n                                else {\n                                    current += existing ? baseDate[i] : '0';\n                                }\n                            }\n                        }\n                        else {\n                            current += existing ? baseDate[i] || \"\" : '0';\n                        }\n                        if (formatToTextLengthDiff > 0) {\n                            if (datePartText.length + formatToTextLengthDiff < segmentLength) {\n                                datePartText += rawInputValue[i] || \"\";\n                            }\n                        }\n                        else {\n                            datePartText += rawInputValue[i] || \"\";\n                        }\n                        replaced = true;\n                    }\n                    else if (!replaced) {\n                        prefix += rawInputValue[i] || \"\";\n                    }\n                    else {\n                        suffix += rawInputValue[i - formatToTextLengthDiff] || \"\";\n                    }\n                }\n                if (originalFormat.length < rawInputValue.length) {\n                    datePartText += currentChar;\n                }\n            }\n        }\n        if (!isInCaretMode) {\n            if (this.autoCorrectParts) {\n                current = \"\";\n                datePartText = \"\";\n                prefix = \"\";\n                suffix = \"\";\n                replaced = false;\n                for (let i = 0; i < baseDate.length; i++) {\n                    if (baseFormat[i] === symbol) {\n                        const existing = this.getExisting(symbol);\n                        current += existing ? baseDate[i] : '0';\n                        replaced = true;\n                    }\n                    else if (!replaced) {\n                        prefix += baseDate[i];\n                    }\n                    else {\n                        suffix += baseDate[i];\n                    }\n                }\n            }\n            else {\n                current = resetSegmentValue ? datePartText : current;\n            }\n        }\n        let parsedDate = null;\n        const { monthName: monthByChar, matchesCount } = this.matchMonth(currentChar);\n        const dayPeriod = this.matchDayPeriod(currentChar, symbol);\n        const isZeroCurrentChar = currentChar === '0';\n        const leadingZero = this.leadingZero || {};\n        if (isZeroCurrentChar) {\n            if (datePartText === \"0\") {\n                datePartText = current;\n            }\n            const valueNumber = parseToInt(resetSegmentValue ?\n                currentChar :\n                (isInCaretMode ? datePartText : current) + currentChar);\n            if (valueNumber === 0 && !this.isAbbrMonth(dateParts.partMap, symbol) && symbol !== \"a\") {\n                this.incrementLeadingZero(symbol);\n            }\n        }\n        else {\n            this.resetLeadingZero();\n        }\n        const partPattern = this.partPattern(dateParts.partMap, symbol);\n        const patternValue = partPattern ? partPattern.pattern : null;\n        const patternLength = this.patternLength(patternValue) || (patternValue ? patternValue.length : 0);\n        if (isInCaretMode) {\n            if (isDeleting && !datePartText) {\n                this.setExisting(symbol, false);\n                return extend(parseResult, { value: null, switchToNext: false });\n            }\n        }\n        const currentMaxLength = current.length - 3;\n        let tryParse = true;\n        let middle = isInCaretMode ? datePartText : current;\n        for (let i = Math.max(0, currentMaxLength); i <= current.length; i++) {\n            if (!tryParse) {\n                break;\n            }\n            middle = resetSegmentValue ?\n                currentChar :\n                isInCaretMode ?\n                    datePartText :\n                    (current.substring(i) + currentChar);\n            if (this.autoSwitchParts && symbol === 'h' && current.substring(i) === '12') {\n                middle = middle.replace('12', '0');\n            }\n            if (isInCaretMode || !this.autoCorrectParts) {\n                tryParse = false;\n                middle = unpadZero(middle);\n                // middle = padZero(segmentLength - middle.length) + middle;\n                middle = padZero(patternLength - middle.length) + middle;\n            }\n            const middleNumber = parseInt(middle, 10);\n            const candidateDateString = prefix + middle + suffix;\n            parsedDate = this.intl.parseDate(candidateDateString, this.format, this.localeId);\n            // if the format does not include year/month/day, e.g. hh:mm:ss\n            // then the exact date cannot be inferred as there is no data for it\n            // thus the today's date is used, but revert to the original date\n            // to keep other parts of the date unchanged\n            if (parsedDate && this.value &&\n                dateParts.partMap.every(x => x.type !== \"year\" && x.type !== \"month\" && x.type != \"day\")) {\n                parsedDate.setFullYear(this.value.getFullYear());\n                parsedDate.setMonth(this.value.getMonth());\n                parsedDate.setDate(this.value.getDate());\n            }\n            let autoCorrectedPrefixAndSuffix = false;\n            if (isInCaretMode && !isValidDate(parsedDate)) {\n                // if part of the date is not available, e.g. \"d\"\n                // but an expanded format like \"F\" is used\n                // the element value can be \"EEEE, February 1, 2022 3:04:05 AM\"\n                // which is not parsable by intl\n                // use the base prefix and suffix, e.g. convert the candidate date string\n                // to \"Thursday, February 1, 2022 3:04:05 AM\"\n                // as \"EEEE, February...\" is not parsable\n                if (this.autoCorrectParts) {\n                    parsedDate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);\n                    autoCorrectedPrefixAndSuffix = true;\n                }\n            }\n            const isCurrentCharParsable = !isNaN(parseInt(currentChar, 10)) || (isInCaretMode && isDeleting && currentChar === \"\");\n            if (!parsedDate && !isNaN(middleNumber) && isCurrentCharParsable && this.autoCorrectParts) {\n                if (symbol === MONTH_SYMBOL && !monthByChar) {\n                    // JS months start from 0 (January) instead of 1 (January)\n                    const monthNumber = middleNumber - JS_MONTH_OFFSET;\n                    if (monthNumber > -1 && monthNumber < 12) {\n                        parsedDate = cloneDate(this.value);\n                        parsedDate.setMonth(monthNumber);\n                        if (parsedDate.getMonth() !== monthNumber) {\n                            parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n                        }\n                    }\n                }\n                if (symbol === 'y') {\n                    parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);\n                    if (((isInCaretMode && isValidDate(parsedDate)) ||\n                        (!isInCaretMode && parsedDate)) && this.date && parsedDate.getDate() !== this.value.getDate()) {\n                        parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n                    }\n                }\n            }\n            if ((isInCaretMode && isValidDate(parsedDate)) || (!isInCaretMode && parsedDate)) {\n                // move to next segment if the part will overflow with next char\n                // when start from empty date (01, then 010), padded zeros should be trimmed\n                const peekResult = this.isPeekDateOverflowingDatePart({\n                    useBasePrefixAndSuffix: autoCorrectedPrefixAndSuffix,\n                    middle,\n                    patternValue,\n                    basePrefix,\n                    baseSuffix,\n                    prefix,\n                    suffix,\n                    symbol,\n                    patternLength,\n                    leadingZero\n                });\n                let switchToNext = peekResult.switchToNext;\n                if (this.shouldNormalizeCentury()) {\n                    parsedDate = this.normalizeCentury(parsedDate);\n                }\n                if (symbol === 'H' && parsedDate.getHours() >= 12) {\n                    this.setExisting('a', true);\n                }\n                this._value = parsedDate;\n                this.setExisting(symbol, true);\n                this.resetInvalidDateSymbol(symbol);\n                if (!this.autoCorrectParts) {\n                    if (symbol === \"M\") {\n                        if (this.getExisting(\"M\") && this.getExisting(\"y\")) {\n                            // changing from 28/Feb to 29/Feb to 29/March\n                            this.setExisting(\"d\", true);\n                            this.resetInvalidDateSymbol(\"d\");\n                        }\n                    }\n                    else if (symbol === \"d\") {\n                        if (this.getExisting(\"d\") && this.getExisting(\"y\")) {\n                            // changing from 31/Jan to 31/Feb to 28/Feb\n                            this.setExisting(\"M\", true);\n                            this.resetInvalidDateSymbol(\"M\");\n                        }\n                    }\n                    else if (symbol === \"y\") {\n                        // if the parsed date is valid, make the whole value valid\n                        this.markDatePartsAsExisting();\n                    }\n                    if (!this.hasInvalidDatePart()) {\n                        this.markDatePartsAsExisting();\n                        if (!peekResult.peekedDate && peekResult.switchToNext && !this.autoCorrectParts) {\n                            if (symbol === \"M\") {\n                                // skip processing the month\n                            }\n                            else if (symbol === \"d\") {\n                                if (peekResult.parsedPeekedValue === 30 &&\n                                    this.value.getMonth() === MONTH_INDEX_FEBRUARY) {\n                                    // the peekValue cannot be constructed\n                                    // as there cannot be more than 29 days in February\n                                    // still the segment should not be switched as autoCorrectParts=\"false\"\n                                    // should allow typing \"30\"\n                                    switchToNext = false;\n                                }\n                            }\n                        }\n                    }\n                }\n                return extend(parseResult, { value: this.value, switchToNext: switchToNext });\n            }\n        }\n        if (monthByChar) {\n            parsedDate = this.intl.parseDate(prefix + monthByChar + suffix, this.format, this.localeId);\n            if (parsedDate) {\n                this._value = parsedDate;\n                this.setExisting(symbol, true);\n                return extend(parseResult, { value: this.value, switchToNext: matchesCount === 1 });\n            }\n        }\n        if (dayPeriod) {\n            parsedDate = this.intl.parseDate(prefix + dayPeriod + suffix, this.format) ||\n                this.intl.parseDate(basePrefix + dayPeriod + baseSuffix, this.format);\n            if (parsedDate) {\n                this._value = parsedDate;\n                this.setExisting(symbol, true);\n                return extend(parseResult, { value: this.value, switchToNext: true });\n            }\n        }\n        if (isZeroCurrentChar && symbol !== \"a\") {\n            this.setExisting(symbol, false);\n        }\n        if (!this.autoCorrectParts) {\n            let datePartValue;\n            let textToParse = isInCaretMode ? datePartText : middle;\n            let parsedValue = parseToInt(textToParse);\n            if (isNumber(parsedValue) && isParseableToInt(textToParse)) {\n                if ((symbol === \"d\" && (parsedValue <= 0 || parsedValue > 31)) ||\n                    (symbol === \"M\" && (parsedValue <= 0 || parsedValue > 11))) {\n                    if (isInCaretMode) {\n                        return extend(parseResult, {\n                            value: null,\n                            switchToNext: false\n                        });\n                    }\n                    else {\n                        // the value overflows the possible value range\n                        // thus reset the segment value regardless of the \"resetSegmentValue\" flag\n                        // otherwise the input is ignored and you cannot change the value,\n                        // e.g. \"03->(press 2)->02\" will not work and the user will be blocked on \"03\"\n                        textToParse = currentChar;\n                        parsedValue = parseToInt(textToParse);\n                    }\n                }\n                if (!isNumber(parsedValue) || !isParseableToInt(textToParse)) {\n                    return extend(parseResult, { value: null, switchToNext: false });\n                }\n                datePartValue = symbol === \"M\" ?\n                    parsedValue - JS_MONTH_OFFSET :\n                    parsedValue;\n                const isYear = symbol === \"y\";\n                const isMonth = symbol === \"M\";\n                const isDay = symbol === \"d\";\n                let newValue = cloneDate(this._value);\n                const invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};\n                const year = isYear ? datePartValue : invalidDateParts.y.value || newValue.getFullYear();\n                /* tslint:disable:no-shadowed-variable */\n                const month = isMonth ? datePartValue : invalidDateParts.M.value || newValue.getMonth();\n                /* tslint:enable:no-shadowed-variable */\n                const day = isDay ? datePartValue : invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();\n                const hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();\n                const minutes = invalidDateParts.m.value || newValue.getMinutes();\n                const seconds = invalidDateParts.s.value || newValue.getSeconds();\n                const milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();\n                const dateCandidate = createDate(year, month, day, hour, minutes, seconds, milliseconds);\n                const dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);\n                const newValueCandidate = isYear || isMonth || isDay ?\n                    this.modifyDateSymbolWithValue(newValue, symbol, isYear ? year : isMonth ? month : day) :\n                    null;\n                let invalidDateFound = false;\n                if (isMonth && newValueCandidate) {\n                    if (newValueCandidate.getMonth() === month) {\n                        if (this.getExisting(\"d\")) {\n                            if (dateCandidateExists) {\n                                newValue = cloneDate(dateCandidate);\n                                this.resetInvalidDateSymbol(symbol);\n                            }\n                            else {\n                                invalidDateFound = true;\n                                this.setInvalidDatePart(symbol, {\n                                    value: month,\n                                    date: cloneDate(newValueCandidate),\n                                    startDate: cloneDate(this.value)\n                                });\n                                this.setExisting(symbol, false);\n                            }\n                        }\n                        else if (dateCandidateExists) {\n                            this.resetInvalidDateSymbol(symbol);\n                            newValue = cloneDate(dateCandidate);\n                            if (this.getExisting(\"M\") && this.getExisting(\"y\")) {\n                                // changing from 28/Feb to 29/Feb to 29/March\n                                this.setExisting(\"d\", true);\n                                this.resetInvalidDateSymbol(\"d\");\n                            }\n                        }\n                        else {\n                            this.resetInvalidDateSymbol(symbol);\n                            newValue = cloneDate(newValueCandidate);\n                        }\n                    }\n                    else {\n                        invalidDateFound = true;\n                        this.setInvalidDatePart(symbol, {\n                            value: month,\n                            date: cloneDate(newValueCandidate),\n                            startDate: cloneDate(this.value)\n                        });\n                        this.setExisting(symbol, false);\n                    }\n                }\n                else if (isDay && newValueCandidate) {\n                    if (newValueCandidate.getDate() === day) {\n                        if (this.getExisting(\"M\")) {\n                            if (dateCandidateExists) {\n                                newValue = cloneDate(dateCandidate);\n                                this.resetInvalidDateSymbol(symbol);\n                            }\n                            else {\n                                invalidDateFound = true;\n                                this.setInvalidDatePart(symbol, {\n                                    value: day,\n                                    date: cloneDate(newValueCandidate),\n                                    startDate: cloneDate(this.value)\n                                });\n                                this.setExisting(symbol, false);\n                            }\n                        }\n                        else if (dateCandidateExists) {\n                            newValue = cloneDate(dateCandidate);\n                            this.resetInvalidDateSymbol(symbol);\n                            if (this.getExisting(\"d\") && this.getExisting(\"y\")) {\n                                // changing from 31/Jan to 31/Feb to 28/Feb\n                                this.setExisting(\"M\", true);\n                                this.resetInvalidDateSymbol(\"M\");\n                            }\n                        }\n                        else {\n                            this.resetInvalidDateSymbol(symbol);\n                            newValue = cloneDate(newValueCandidate);\n                        }\n                    }\n                    else {\n                        invalidDateFound = true;\n                        this.setInvalidDatePart(symbol, {\n                            value: day,\n                            date: cloneDate(this.value),\n                            startDate: cloneDate(this.value)\n                        });\n                        this.setExisting(symbol, false);\n                    }\n                }\n                else if (isYear && newValueCandidate) {\n                    if (newValueCandidate.getFullYear() === year) {\n                        if (this.getExisting(\"d\") && this.getExisting(\"M\")) {\n                            if (dateCandidateExists) {\n                                newValue = cloneDate(dateCandidate);\n                                this.resetInvalidDateSymbol(symbol);\n                            }\n                            else {\n                                invalidDateFound = true;\n                                this.setInvalidDatePart(symbol, {\n                                    value: year,\n                                    date: cloneDate(newValueCandidate),\n                                    startDate: cloneDate(this.value)\n                                });\n                                this.setExisting(symbol, false);\n                            }\n                        }\n                        else if (dateCandidateExists) {\n                            this.resetInvalidDateSymbol(symbol);\n                            newValue = cloneDate(dateCandidate);\n                            if (this.getExisting(\"M\") && this.getExisting(\"d\")) {\n                                this.setExisting(\"y\", true);\n                                this.resetInvalidDateSymbol(\"y\");\n                            }\n                        }\n                        else {\n                            this.resetInvalidDateSymbol(symbol);\n                            newValue = cloneDate(newValueCandidate);\n                        }\n                    }\n                    else {\n                        invalidDateFound = true;\n                        this.setInvalidDatePart(symbol, {\n                            value: year,\n                            date: cloneDate(newValueCandidate),\n                            startDate: cloneDate(this.value)\n                        });\n                        this.setExisting(symbol, false);\n                    }\n                }\n                if (!invalidDateFound) {\n                    this.setExisting(symbol, true);\n                    if (isInCaretMode && !isValidDate(parsedDate)) {\n                        const valueCandidate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);\n                        if (isValidDate(valueCandidate)) {\n                            this._value = valueCandidate;\n                        }\n                    }\n                    else {\n                        this._value = newValue;\n                    }\n                    if (this.getValue()) {\n                        this.resetInvalidDate();\n                    }\n                }\n                let switchToNext = false;\n                if (symbol === \"M\") {\n                    if (parsedValue >= 2 || textToParse.length >= 2) {\n                        switchToNext = true;\n                    }\n                    else {\n                        switchToNext = false;\n                    }\n                }\n                else {\n                    if (hasFixedFormat) {\n                        const peekDateSwitchToNext = this.isPeekDateOverflowingDatePart({\n                            useBasePrefixAndSuffix: !this.autoCorrectParts,\n                            middle,\n                            patternValue,\n                            basePrefix,\n                            baseSuffix,\n                            prefix,\n                            suffix,\n                            symbol,\n                            patternLength,\n                            leadingZero\n                        }).switchToNext;\n                        switchToNext = peekDateSwitchToNext;\n                    }\n                    else {\n                        switchToNext = textToParse.length > segmentLength;\n                    }\n                }\n                return extend(parseResult, {\n                    value: null,\n                    switchToNext: switchToNext,\n                    hasInvalidDatePart: invalidDateFound\n                });\n            }\n        }\n        return extend(parseResult, { value: null, switchToNext: false });\n    }\n    /**\n     * @hidden\n     */\n    symbolMap(symbol) {\n        return this.intl.splitDateFormat(this.format, this.localeId).reduce(dateSymbolMap, {})[symbol];\n    }\n    /**\n     * @hidden\n     */\n    resetLeadingZero() {\n        const hasLeadingZero = this.leadingZero !== null;\n        this.setLeadingZero(null);\n        return hasLeadingZero;\n    }\n    setLeadingZero(leadingZero) {\n        this.leadingZero = leadingZero;\n    }\n    /**\n     * @hidden\n     */\n    getLeadingZero() {\n        return this.leadingZero || {};\n    }\n    /**\n     * @hidden\n     */\n    normalizeCentury(date) {\n        if (!isPresent(date)) {\n            return date;\n        }\n        const twoDigitYear = cropTwoDigitYear(date);\n        const centuryBase = this.getNormalizedCenturyBase(twoDigitYear);\n        const normalizedDate = setYears(date, centuryBase + twoDigitYear);\n        return normalizedDate;\n    }\n    incrementLeadingZero(symbol) {\n        const leadingZero = this.leadingZero || {};\n        leadingZero[symbol] = (leadingZero[symbol] || 0) + 1;\n        this.leadingZero = leadingZero;\n    }\n    /**\n     * @hidden\n     */\n    isAbbrMonth(parts, symbol) {\n        const pattern = this.partPattern(parts, symbol);\n        return pattern.type === 'month' && pattern.names;\n    }\n    /**\n     * @hidden\n     */\n    partPattern(parts, symbol) {\n        return parts.filter((part) => part.pattern.indexOf(symbol) !== -1)[0];\n    }\n    /**\n     * @hidden\n     */\n    peek(value, pattern) {\n        if (!pattern) {\n            return value;\n        }\n        const peekValue = value.replace(/^0*/, '') + '0';\n        return padZero(pattern.length - peekValue.length) + peekValue;\n    }\n    /**\n     * @hidden\n     */\n    matchMonth(typedChar) {\n        this.typedMonthPart += typedChar.toLowerCase();\n        if (this.monthNames.length === 0) {\n            return { monthName: '', matchesCount: 0 };\n        }\n        while (this.typedMonthPart.length > 0) {\n            const matchingMonths = [];\n            for (let i = 0; i < this.monthNames.length; i++) {\n                const monthName = this.monthNames[i].toLowerCase();\n                if (monthName.startsWith(this.typedMonthPart)) {\n                    matchingMonths.push(this.monthNames[i]);\n                }\n            }\n            if (matchingMonths.length > 0) {\n                return { monthName: matchingMonths[0], matchesCount: matchingMonths.length };\n            }\n            const monthAsNum = parseInt(this.typedMonthPart, 10);\n            /* ensure they exact match */\n            if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString().startsWith(this.typedMonthPart)) {\n                // count the amount of possible months for each number\n                // 1 -> 4 (1, 10, 11, 12)\n                // 2-9 -> 1\n                const months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n                const matchesCount = months.reduce((count, month) => {\n                    return month.toString().startsWith(this.typedMonthPart) ? count + 1 : count;\n                }, 0);\n                return { monthName: this.monthNames[monthAsNum - 1], matchesCount: matchesCount };\n            }\n            this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);\n        }\n        return { monthName: '', matchesCount: 0 };\n    }\n    /**\n     * @hidden\n     */\n    matchDayPeriod(typedChar, symbol) {\n        const lowerChart = typedChar.toLowerCase();\n        if (symbol === 'a' && this.dayPeriods) {\n            if (this.dayPeriods.am.toLowerCase().startsWith(lowerChart)) {\n                return this.dayPeriods.am;\n            }\n            else if (this.dayPeriods.pm.toLowerCase().startsWith(lowerChart)) {\n                return this.dayPeriods.pm;\n            }\n        }\n        return '';\n    }\n    /**\n     * @hidden\n     */\n    allFormattedMonths(locale = \"en\") {\n        const dateFormatParts = this.intl.splitDateFormat(this.format, this.localeId);\n        for (let i = 0; i < dateFormatParts.length; i++) {\n            if (dateFormatParts[i].type === 'month' && dateFormatParts[i].names) {\n                return this.intl.dateFormatNames(locale, dateFormatParts[i].names);\n            }\n        }\n        return [];\n    }\n    /**\n     * @hidden\n     */\n    allDayPeriods(locale = \"en\") {\n        const dateFormatParts = this.intl.splitDateFormat(this.format);\n        for (let i = 0; i < dateFormatParts.length; i++) {\n            if (dateFormatParts[i].type === \"dayperiod\" && dateFormatParts[i].names) {\n                return this.intl.dateFormatNames(locale, dateFormatParts[i].names);\n            }\n        }\n        return null;\n    }\n    /**\n     * @hidden\n     */\n    patternLength(pattern) {\n        if (!pattern) {\n            return 0;\n        }\n        if (pattern[0] === 'y') {\n            return 4;\n        }\n        if (SHORT_PATTERN_LENGTH_REGEXP.test(pattern)) {\n            return 2;\n        }\n        return 0;\n    }\n    /**\n     * @hidden\n     */\n    dateFormatString(date, format) {\n        const dateFormatParts = this.intl.splitDateFormat(format, this.localeId);\n        const parts = [];\n        const partMap = [];\n        for (let i = 0; i < dateFormatParts.length; i++) {\n            let partLength = this.intl.formatDate(date, { pattern: dateFormatParts[i].pattern }, this.localeId).length;\n            while (partLength > 0) {\n                parts.push(this.symbols[dateFormatParts[i].pattern[0]] || Constants.formatSeparator);\n                partMap.push(dateFormatParts[i]);\n                partLength--;\n            }\n        }\n        const returnValue = new Mask();\n        returnValue.symbols = parts.join('');\n        returnValue.partMap = partMap;\n        return returnValue;\n    }\n    /**\n     * @hidden\n     */\n    merge(text, mask) {\n        // Important: right to left.\n        let resultText = '';\n        let resultFormat = '';\n        const format = mask.symbols;\n        let processTextSymbolsEnded = false;\n        let ignoreFormatSymbolsCount = 0;\n        const formattedDates = this.getFormattedInvalidDates(format);\n        for (let formatSymbolIndex = format.length - 1; formatSymbolIndex >= 0; formatSymbolIndex--) {\n            const partsForSegment = this.getPartsForSegment(mask, formatSymbolIndex);\n            if (this.knownParts.indexOf(format[formatSymbolIndex]) === -1 || this.getExisting(format[formatSymbolIndex])) {\n                if (this.autoCorrectParts) {\n                    resultText = text[formatSymbolIndex] + resultText;\n                }\n                else {\n                    if (text.length !== format.length) {\n                        if (processTextSymbolsEnded) {\n                            resultText = text[formatSymbolIndex] + resultText;\n                        }\n                        else if (ignoreFormatSymbolsCount > 0) {\n                            resultText = text[formatSymbolIndex] + resultText;\n                            ignoreFormatSymbolsCount--;\n                            if (ignoreFormatSymbolsCount <= 0) {\n                                processTextSymbolsEnded = true;\n                            }\n                        }\n                        else {\n                            resultText = (text[formatSymbolIndex + text.length - format.length] || \"\") + resultText;\n                        }\n                    }\n                    else {\n                        resultText = text[formatSymbolIndex] + resultText;\n                    }\n                }\n                resultFormat = format[formatSymbolIndex] + resultFormat;\n            }\n            else {\n                const symbol = format[formatSymbolIndex];\n                let formatSymbolIndexModifier = 0;\n                if (this.autoCorrectParts || (!this.autoCorrectParts && !this.getInvalidDatePartValue(symbol))) {\n                    while (formatSymbolIndex >= 0 && symbol === format[formatSymbolIndex]) {\n                        formatSymbolIndex--;\n                    }\n                    formatSymbolIndex++;\n                }\n                if (this.leadingZero && this.leadingZero[symbol]) {\n                    resultText = '0' + resultText;\n                }\n                else {\n                    if (!this.autoCorrectParts && this.getInvalidDatePartValue(symbol)) {\n                        let datePartText = this.getInvalidDatePartValue(symbol).toString();\n                        if (symbol === \"M\") {\n                            datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();\n                            if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {\n                                resultText = formattedDates[symbol][formatSymbolIndex] + resultText;\n                            }\n                            else {\n                                datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();\n                                const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n                                resultText = formattedDatePart + resultText;\n                                formatSymbolIndexModifier = partsForSegment.length - 1;\n                                ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;\n                            }\n                        }\n                        else {\n                            const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n                            resultText = formattedDatePart + resultText;\n                            formatSymbolIndexModifier = partsForSegment.length - 1;\n                            ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;\n                        }\n                    }\n                    else {\n                        resultText = this.dateFieldName(mask.partMap[formatSymbolIndex]) + resultText;\n                    }\n                }\n                while (resultFormat.length < resultText.length) {\n                    resultFormat = format[formatSymbolIndex] + resultFormat;\n                }\n                if (formatSymbolIndexModifier !== 0) {\n                    formatSymbolIndex = (formatSymbolIndex - formatSymbolIndexModifier) + (text.length - format.length);\n                }\n            }\n        }\n        return { text: resultText, format: resultFormat };\n    }\n    /**\n     * @hidden\n     */\n    dateFieldName(part) {\n        const formatPlaceholder = this.formatPlaceholder || 'wide';\n        if (formatPlaceholder[part.type]) {\n            return formatPlaceholder[part.type];\n        }\n        if (formatPlaceholder === 'formatPattern') {\n            return part.pattern;\n        }\n        return this.intl.dateFieldName(Object.assign(part, { nameType: formatPlaceholder }));\n    }\n    /**\n     * @hidden\n     */\n    getNormalizedCenturyBase(twoDigitYear) {\n        return twoDigitYear > this.twoDigitYearMax ?\n            PREVIOUS_CENTURY_BASE :\n            CURRENT_CENTURY_BASE;\n    }\n    /**\n     * @hidden\n     */\n    shouldNormalizeCentury() {\n        return this.intl.splitDateFormat(this.format).some(part => part.pattern === 'yy');\n    }\n    resetInvalidDate() {\n        this._partiallyInvalidDate.startDate = null;\n        Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n            this.resetInvalidDatePart(key);\n        });\n    }\n    resetInvalidDateSymbol(symbol) {\n        this.resetInvalidDatePart(symbol);\n        let shouldResetInvalidDate = true;\n        Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n            if (this._partiallyInvalidDate.invalidDateParts[key] &&\n                isPresent(this._partiallyInvalidDate.invalidDateParts[key].value)) {\n                shouldResetInvalidDate = false;\n            }\n        });\n        if (shouldResetInvalidDate) {\n            this.resetInvalidDate();\n        }\n    }\n    resetInvalidDatePart(symbol) {\n        if (this._partiallyInvalidDate.invalidDateParts[symbol]) {\n            this._partiallyInvalidDate.invalidDateParts[symbol] = {\n                value: null,\n                date: null,\n                startDateOffset: 0\n            };\n        }\n    }\n    /**\n     * @hidden\n     */\n    getInvalidDatePart(symbol) {\n        const invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];\n        return invalidDatePart || {};\n    }\n    /**\n     * @hidden\n     */\n    getInvalidDatePartValue(symbol) {\n        const invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];\n        return (invalidDatePart || {}).value;\n    }\n    setInvalidDatePart(symbol, { value = null, date = null, startDateOffset = 0, startDate = null }) {\n        if (this._partiallyInvalidDate.invalidDateParts[symbol]) {\n            this._partiallyInvalidDate.invalidDateParts[symbol].value = value;\n            this._partiallyInvalidDate.invalidDateParts[symbol].date = date;\n            this._partiallyInvalidDate.invalidDateParts[symbol].startDateOffset = startDateOffset;\n            this._partiallyInvalidDate.startDate = startDate;\n        }\n    }\n    /**\n     * @hidden\n     */\n    hasInvalidDatePart() {\n        let hasInvalidDatePart = false;\n        Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n            if (this._partiallyInvalidDate.invalidDateParts[key] &&\n                isPresent(this._partiallyInvalidDate.invalidDateParts[key].value)) {\n                hasInvalidDatePart = true;\n            }\n        });\n        return hasInvalidDatePart;\n    }\n    /**\n     * @hidden\n     */\n    modifyDateSymbolWithOffset(date, symbol, offset) {\n        let newValue = cloneDate(date);\n        let timeModified = false;\n        switch (symbol) {\n            case 'y':\n                newValue.setFullYear(newValue.getFullYear() + offset);\n                break;\n            case 'M':\n                newValue = addMonths(this.value, offset);\n                break;\n            case 'd':\n            case 'E':\n                newValue.setDate(newValue.getDate() + offset);\n                break;\n            case 'h':\n            case 'H':\n                newValue.setHours(newValue.getHours() + offset);\n                timeModified = true;\n                break;\n            case 'm':\n                newValue.setMinutes(newValue.getMinutes() + offset);\n                timeModified = true;\n                break;\n            case 's':\n                newValue.setSeconds(newValue.getSeconds() + offset);\n                timeModified = true;\n                break;\n            case \"S\":\n                newValue.setMilliseconds(newValue.getMilliseconds() + offset);\n                break;\n            case 'a':\n                newValue.setHours(newValue.getHours() + (12 * offset));\n                timeModified = true;\n                break;\n            default: break;\n        }\n        return {\n            date: newValue,\n            timeModified: timeModified\n        };\n    }\n    /**\n     * @hidden\n     */\n    modifyDateSymbolWithValue(date, symbol, value) {\n        let newValue = cloneDate(date);\n        switch (symbol) {\n            case 'y':\n                newValue.setFullYear(value);\n                break;\n            case 'M':\n                newValue = addMonths(date, value - date.getMonth());\n                break;\n            case 'd':\n            case 'E':\n                newValue.setDate(value);\n                break;\n            case 'h':\n            case 'H':\n                newValue.setHours(value);\n                break;\n            case 'm':\n                newValue.setMinutes(value);\n                break;\n            case 's':\n                newValue.setSeconds(value);\n                break;\n            case \"S\":\n                newValue.setMilliseconds(value);\n                break;\n            case 'a':\n                newValue.setHours(value);\n                break;\n            default: break;\n        }\n        return newValue;\n    }\n    markDatePartsAsExisting() {\n        this.modifyExisting(true);\n    }\n    /**\n     * @hidden\n     */\n    getPartsForSegment(mask, partIndex) {\n        const segmentPart = mask.partMap[partIndex];\n        const partsForSegment = [];\n        for (let maskPartIndex = partIndex; maskPartIndex < mask.partMap.length; maskPartIndex++) {\n            const part = mask.partMap[maskPartIndex];\n            if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {\n                partsForSegment.push(part);\n            }\n            else {\n                break;\n            }\n        }\n        for (let maskPartIndex = partIndex - 1; maskPartIndex >= 0; maskPartIndex--) {\n            const part = mask.partMap[maskPartIndex];\n            if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {\n                partsForSegment.unshift(part);\n            }\n            else {\n                break;\n            }\n        }\n        return partsForSegment;\n    }\n    /**\n     * @hidden\n     */\n    isPeekDateOverflowingDatePart({ useBasePrefixAndSuffix, middle, patternValue, basePrefix, baseSuffix, prefix, suffix, symbol, patternLength, leadingZero }) {\n        // move to next segment if the part will overflow with next char\n        // when start from empty date (01, then 010), padded zeros should be trimmed\n        const peekedValue = this.peek(middle, patternValue);\n        const peekedDateString = useBasePrefixAndSuffix ?\n            `${basePrefix}${peekedValue}${baseSuffix}` :\n            `${prefix}${peekedValue}${suffix}`;\n        const peekedDate = this.intl.parseDate(peekedDateString, this.format, this.localeId);\n        const leadingZeroOffset = (this.leadingZero || {})[symbol] || 0;\n        const patternSatisfied = (leadingZeroOffset + unpadZero(middle).length) >= patternLength;\n        const parsedPeekedValue = parseToInt(peekedValue);\n        const switchToNext = peekedDate === null ||\n            (leadingZero[symbol] ?\n                patternValue.length <= middle.length :\n                patternSatisfied);\n        return {\n            peekedDate,\n            peekedDateString,\n            peekedValue,\n            parsedPeekedValue,\n            switchToNext\n        };\n    }\n}\n","export const KeyCode = {\n    BACKSPACE: 8,\n    DELETE: 46,\n    TAB: 9,\n    ENTER: 13,\n    ESCAPE: 27,\n    ARROW_LEFT: 37,\n    ARROW_UP: 38,\n    ARROW_RIGHT: 39,\n    ARROW_DOWN: 40,\n    SPACE: 32,\n    END: 35,\n    HOME: 36,\n    PAGE_UP: 33,\n    PAGE_DOWN: 34\n};\n","import { extend, isFunction } from \"./utils\";\nconst defaultOptions = {\n    events: {}\n};\nexport class Observable {\n    constructor(options) {\n        this.options = extend({}, defaultOptions, options);\n    }\n    destroy() {\n        this.options = {};\n    }\n    /**\n     * @hidden\n     */\n    trigger(eventName, args = {}) {\n        const eventData = {\n            defaultPrevented: false,\n            preventDefault: () => {\n                eventData.defaultPrevented = true;\n            }\n        };\n        if (isFunction(this.options.events[eventName])) {\n            this.options.events[eventName](extend(eventData, args, {\n                sender: this\n            }));\n            return eventData.defaultPrevented;\n        }\n        return false;\n    }\n}\n","export var DateInputInteractionMode;\n(function (DateInputInteractionMode) {\n    DateInputInteractionMode[\"None\"] = \"none\";\n    DateInputInteractionMode[\"Caret\"] = \"caret\";\n    DateInputInteractionMode[\"Selection\"] = \"selection\";\n})(DateInputInteractionMode || (DateInputInteractionMode = {}));\n","import { DateObject } from '../common/dateobject';\nimport { approximateStringMatching } from './utils';\nimport { KeyCode } from '../common/keycode';\nimport { Key } from '../common/key';\nimport { extend, isPresent, isDocumentAvailable, millisecondDigitsInFormat, millisecondStepFor, isValidDate, isIOS } from '../common/utils';\nimport { Observable } from '../common/observable';\nimport { DateInputInteractionMode } from './interaction-mode';\nimport { isEqual, cloneDate } from '@progress/kendo-date-math';\nimport { Constants } from '../common/constants';\nconst DEFAULT_SEGMENT_STEP = 1;\nconst DRAG_START = \"dragStart\";\nconst DROP = \"drop\";\nconst TOUCH_START = \"touchstart\";\nconst MOUSE_DOWN = \"mousedown\";\nconst MOUSE_UP = \"mouseup\";\nconst CLICK = \"click\";\nconst INPUT = \"input\";\nconst KEY_DOWN = \"keydown\";\nconst FOCUS = \"focus\";\nconst BLUR = \"blur\";\nconst PASTE = \"paste\";\nconst MOUSE_SCROLL = \"DOMMouseScroll\";\nconst MOUSE_WHEEL = \"mousewheel\";\nconst VALUE_CHANGE = \"valueChange\";\nconst INPUT_END = \"inputEnd\";\nconst BLUR_END = \"blurEnd\";\nconst FOCUS_END = \"focusEnd\";\nconst CHANGE = \"change\";\nconst defaultDateInputOptions = {\n    format: \"d\",\n    hasPlaceholder: false,\n    placeholder: null,\n    cycleTime: true,\n    locale: null,\n    steps: {\n        millisecond: DEFAULT_SEGMENT_STEP,\n        second: DEFAULT_SEGMENT_STEP,\n        minute: DEFAULT_SEGMENT_STEP,\n        hour: DEFAULT_SEGMENT_STEP,\n        day: DEFAULT_SEGMENT_STEP,\n        month: DEFAULT_SEGMENT_STEP,\n        year: DEFAULT_SEGMENT_STEP\n    },\n    formatPlaceholder: null,\n    events: {\n        [VALUE_CHANGE]: null,\n        [INPUT]: null,\n        [INPUT_END]: null,\n        [FOCUS]: null,\n        [FOCUS_END]: null,\n        [BLUR]: null,\n        [BLUR_END]: null,\n        [KEY_DOWN]: null,\n        [MOUSE_WHEEL]: null,\n        [CHANGE]: null\n    },\n    selectNearestSegmentOnFocus: false,\n    selectPreviousSegmentOnBackspace: false,\n    enableMouseWheel: false,\n    allowCaretMode: false,\n    autoSwitchParts: true,\n    autoSwitchKeys: [],\n    twoDigitYearMax: Constants.twoDigitYearMax,\n    autoCorrectParts: true,\n    autoFill: false,\n    toggleDayPeriod: false\n};\nexport class DateInput extends Observable {\n    get value() {\n        return this.dateObject && this.dateObject.getValue();\n    }\n    constructor(element, options) {\n        super(options);\n        this.dateObject = null;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        this.currentText = '';\n        this.currentFormat = '';\n        this.interactionMode = DateInputInteractionMode.None;\n        this.previousElementSelection = { start: 0, end: 0 };\n        this.init(element, options);\n    }\n    init(element, options) {\n        let dateValue = isValidDate(this.options.value) ? cloneDate(this.options.value) : new Date(options.formattedValue);\n        if (!isValidDate(dateValue)) {\n            dateValue = null;\n        }\n        this.element = element;\n        // this.element._kendoWidget = this;\n        this.options = extend({}, defaultDateInputOptions, options, { steps: Object.assign(Object.assign({}, defaultDateInputOptions.steps), options.steps) });\n        this.intl = this.options.intlService;\n        this.dateObject = this.createDateObject();\n        this.dateObject.setValue(dateValue);\n        this.setTextAndFormat();\n        this.bindEvents();\n        this.resetSegmentValue = true;\n        this.interactionMode = DateInputInteractionMode.None;\n        this.forceUpdate();\n    }\n    destroy() {\n        this.unbindEvents();\n        this.dateObject = null;\n        super.destroy();\n    }\n    bindEvents() {\n        this.onElementDragStart = this.onElementDragStart.bind(this);\n        this.element.addEventListener(DRAG_START, this.onElementDragStart);\n        this.onElementDrop = this.onElementDrop.bind(this);\n        this.element.addEventListener(DROP, this.onElementDrop);\n        this.onElementClick = this.onElementClick.bind(this);\n        this.element.addEventListener(CLICK, this.onElementClick);\n        this.onElementMouseDown = this.onElementMouseDown.bind(this);\n        this.element.addEventListener(MOUSE_DOWN, this.onElementMouseDown);\n        this.element.addEventListener(TOUCH_START, this.onElementMouseDown);\n        this.onElementMouseUp = this.onElementMouseUp.bind(this);\n        this.element.addEventListener(MOUSE_UP, this.onElementMouseUp);\n        this.onElementInput = this.onElementInput.bind(this);\n        this.element.addEventListener(INPUT, this.onElementInput);\n        this.onElementKeyDown = this.onElementKeyDown.bind(this);\n        this.element.addEventListener(KEY_DOWN, this.onElementKeyDown);\n        this.onElementFocus = this.onElementFocus.bind(this);\n        this.element.addEventListener(FOCUS, this.onElementFocus);\n        this.onElementBlur = this.onElementBlur.bind(this);\n        this.element.addEventListener(BLUR, this.onElementBlur);\n        this.onElementChange = this.onElementChange.bind(this);\n        this.element.addEventListener(CHANGE, this.onElementChange);\n        this.onElementPaste = this.onElementPaste.bind(this);\n        this.element.addEventListener(PASTE, this.onElementPaste);\n        this.onElementMouseWheel = this.onElementMouseWheel.bind(this);\n        this.element.addEventListener(MOUSE_SCROLL, this.onElementMouseWheel);\n        this.element.addEventListener(MOUSE_WHEEL, this.onElementMouseWheel);\n    }\n    unbindEvents() {\n        this.element.removeEventListener(DRAG_START, this.onElementDragStart);\n        this.element.removeEventListener(DROP, this.onElementDrop);\n        this.element.removeEventListener(TOUCH_START, this.onElementMouseDown);\n        this.element.removeEventListener(MOUSE_DOWN, this.onElementMouseDown);\n        this.element.removeEventListener(MOUSE_UP, this.onElementMouseUp);\n        this.element.removeEventListener(CLICK, this.onElementClick);\n        this.element.removeEventListener(INPUT, this.onElementInput);\n        this.element.removeEventListener(KEY_DOWN, this.onElementKeyDown);\n        this.element.removeEventListener(FOCUS, this.onElementFocus);\n        this.element.removeEventListener(BLUR, this.onElementBlur);\n        this.element.removeEventListener(CHANGE, this.onElementChange);\n        this.element.removeEventListener(PASTE, this.onElementPaste);\n        this.element.removeEventListener(MOUSE_SCROLL, this.onElementMouseWheel);\n        this.element.removeEventListener(MOUSE_WHEEL, this.onElementMouseWheel);\n    }\n    setOptions(options, refresh = false) {\n        this.options = extend({}, this.options, options, { steps: Object.assign(Object.assign({}, defaultDateInputOptions.steps), options.steps) });\n        this.setDateObjectOptions();\n        if (refresh) {\n            this.unbindEvents();\n            this.init(this.element, this.options);\n        }\n    }\n    /**\n     * @hidden\n     */\n    setDateObjectOptions() {\n        if (this.dateObject) {\n            const newOptions = this.getDateObjectOptions();\n            this.dateObject.setOptions(newOptions);\n        }\n    }\n    /**\n     * @hidden\n     */\n    resetLocale() {\n        this.unbindEvents();\n        this.init(this.element, this.options);\n    }\n    /**\n     * @hidden\n     */\n    isInCaretMode() {\n        return this.interactionMode === DateInputInteractionMode.Caret;\n    }\n    focus() {\n        this.element.focus();\n        if (this.options.selectNearestSegmentOnFocus) {\n            this.selectNearestSegment(0);\n        }\n    }\n    /**\n     * @hidden\n     */\n    onElementDragStart(e) {\n        e.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    onElementDrop(e) {\n        e.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    onElementMouseDown() {\n        this.mouseDownStarted = true;\n        this.focusedPriorToMouseDown = this.isActive;\n    }\n    /**\n     * @hidden\n     */\n    onElementMouseUp(e) {\n        this.mouseDownStarted = false;\n        e.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    onElementClick(e) {\n        this.mouseDownStarted = false;\n        this.switchedPartOnPreviousKeyAction = false;\n        const selection = this.selection;\n        if (this.isInCaretMode()) {\n            // explicitly refresh the input element value\n            // caret mode can change the number of symbols in the element\n            // thus clicking on a segment can result in incorrect selection\n            this.forceUpdate();\n        }\n        if (e.detail === 3) {\n            // when 3 clicks occur, leave the native event to handle the change\n            // this results in selecting the whole element value\n        }\n        else {\n            if (this.isActive && this.options.selectNearestSegmentOnFocus) {\n                const selectionPresent = this.element.selectionStart !== this.element.selectionEnd;\n                const placeholderToggled = isPresent(this.options.placeholder) &&\n                    !this.dateObject.hasValue() &&\n                    !this.focusedPriorToMouseDown;\n                // focus first segment if the user hasn't selected something during mousedown and if the placeholder was just toggled\n                const selectFirstSegment = !selectionPresent && placeholderToggled;\n                const index = selectFirstSegment ? 0 : this.caret()[0];\n                this.selectNearestSegment(index);\n            }\n            else {\n                this.setSelection(this.selectionByIndex(selection.start));\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    onElementInput(e) {\n        this.triggerInput({ event: e });\n        const oldElementValue = this.elementValue;\n        if (!this.element || !this.dateObject) {\n            return;\n        }\n        const switchedPartOnPreviousKeyAction = this.switchedPartOnPreviousKeyAction;\n        if (this.isPasteInProgress) {\n            if (this.options.allowCaretMode) {\n                // pasting should leave the input with caret\n                // thus allow direct input instead of selection mode\n                this.resetSegmentValue = false;\n            }\n            this.updateOnPaste(e);\n            this.isPasteInProgress = false;\n            return;\n        }\n        const keyDownEvent = this.keyDownEvent || {};\n        const isBackspaceKey = keyDownEvent.keyCode === KeyCode.BACKSPACE || keyDownEvent.key === Key.BACKSPACE;\n        const isDeleteKey = keyDownEvent.keyCode === KeyCode.DELETE || keyDownEvent.key === Key.DELETE;\n        const originalInteractionMode = this.interactionMode;\n        if (this.options.allowCaretMode &&\n            originalInteractionMode !== DateInputInteractionMode.Caret &&\n            !isDeleteKey && !isBackspaceKey) {\n            this.resetSegmentValue = true;\n        }\n        if (this.options.allowCaretMode) {\n            this.interactionMode = DateInputInteractionMode.Caret;\n        }\n        else {\n            this.interactionMode = DateInputInteractionMode.Selection;\n        }\n        const hasCaret = this.isInCaretMode();\n        if (hasCaret && this.keyDownEvent.key === Key.SPACE) {\n            // do not allow custom \"holes\" in the date segments\n            this.restorePreviousInputEventState();\n            return;\n        }\n        const oldExistingDateValue = this.dateObject && this.dateObject.getValue();\n        const oldDateValue = this.dateObject ? this.dateObject.value : null;\n        const { text: currentText, format: currentFormat } = this.dateObject.getTextAndFormat();\n        this.currentFormat = currentFormat;\n        let oldText = \"\";\n        if (hasCaret) {\n            if (isBackspaceKey || isDeleteKey) {\n                oldText = this.previousElementValue;\n            }\n            else if (originalInteractionMode === DateInputInteractionMode.Caret) {\n                oldText = this.previousElementValue;\n            }\n            else {\n                oldText = currentText;\n            }\n        }\n        else {\n            oldText = currentText;\n        }\n        const newText = this.elementValue;\n        const diff = approximateStringMatching({\n            oldText: oldText,\n            newText: newText,\n            formatPattern: this.currentFormat,\n            selectionStart: this.selection.start,\n            isInCaretMode: hasCaret,\n            keyEvent: this.keyDownEvent\n        });\n        if (diff && diff.length && diff[0] && diff[0][1] !== Constants.formatSeparator) {\n            this.switchedPartOnPreviousKeyAction = false;\n        }\n        if (hasCaret && (!diff || diff.length === 0)) {\n            this.restorePreviousInputEventState();\n            return;\n        }\n        else if (hasCaret && diff.length === 1) {\n            if (!diff[0] || !diff[0][0]) {\n                this.restorePreviousInputEventState();\n                return;\n            }\n            else if (hasCaret && diff[0] &&\n                (diff[0][0] === Constants.formatSeparator || diff[0][1] === Constants.formatSeparator)) {\n                this.restorePreviousInputEventState();\n                return;\n            }\n        }\n        const navigationOnly = (diff.length === 1 && diff[0][1] === Constants.formatSeparator);\n        const parsePartsResults = [];\n        let switchPart = false;\n        let error = null;\n        if (!navigationOnly) {\n            for (let i = 0; i < diff.length; i++) {\n                const parsePartResult = this.dateObject.parsePart({\n                    symbol: diff[i][0],\n                    currentChar: diff[i][1],\n                    resetSegmentValue: this.resetSegmentValue,\n                    cycleSegmentValue: !this.isInCaretMode(),\n                    rawTextValue: this.element.value,\n                    isDeleting: isBackspaceKey || isDeleteKey,\n                    originalFormat: this.currentFormat\n                });\n                parsePartsResults.push(parsePartResult);\n                if (!parsePartResult.value) {\n                    error = { type: \"parse\" };\n                }\n                switchPart = parsePartResult.switchToNext;\n            }\n        }\n        if (!this.options.autoSwitchParts) {\n            switchPart = false;\n        }\n        this.resetSegmentValue = false;\n        const hasFixedFormat = this.options.format === this.currentFormat ||\n            // all not fixed formats are 1 symbol, e.g. \"d\"\n            (isPresent(this.options.format) && this.options.format.length > 1);\n        const lastParseResult = parsePartsResults[parsePartsResults.length - 1];\n        const lastParseResultHasNoValue = lastParseResult && !isPresent(lastParseResult.value);\n        const parsingFailedOnDelete = (hasCaret && (isBackspaceKey || isDeleteKey) && lastParseResultHasNoValue);\n        const resetPart = lastParseResult ? lastParseResult.resetPart : false;\n        const newExistingDateValue = this.dateObject.getValue();\n        const hasExistingDateValueChanged = !isEqual(oldExistingDateValue, newExistingDateValue);\n        const newDateValue = this.dateObject.value;\n        let symbolForSelection;\n        const currentSelection = this.selection;\n        if (hasCaret) {\n            const diffChar = diff && diff.length > 0 ? diff[0][0] : null;\n            const hasLeadingZero = this.dateObject.getLeadingZero()[diffChar];\n            if (diff.length && diff[0][0] !== Constants.formatSeparator) {\n                if (switchPart) {\n                    this.forceUpdateWithSelection();\n                    this.switchDateSegment(1);\n                }\n                else if (resetPart) {\n                    symbolForSelection = this.currentFormat[currentSelection.start];\n                    if (symbolForSelection) {\n                        this.forceUpdate();\n                        this.setSelection(this.selectionBySymbol(symbolForSelection));\n                    }\n                    else {\n                        this.restorePreviousInputEventState();\n                    }\n                }\n                else if (parsingFailedOnDelete) {\n                    this.forceUpdate();\n                    if (diff.length && diff[0][0] !== Constants.formatSeparator) {\n                        this.setSelection(this.selectionBySymbol(diff[0][0]));\n                    }\n                }\n                else if (lastParseResultHasNoValue) {\n                    if (e.data === \"0\" && hasLeadingZero) {\n                        // do not reset element value on a leading zero\n                        // wait for consecutive input to determine the value\n                    }\n                    else if (isPresent(oldExistingDateValue) && !isPresent(newExistingDateValue)) {\n                        this.restorePreviousInputEventState();\n                    }\n                    else if (!isPresent(oldExistingDateValue) && isPresent(newExistingDateValue)) {\n                        this.forceUpdateWithSelection();\n                    }\n                    else if (isPresent(oldExistingDateValue) && isPresent(newExistingDateValue)) {\n                        if (hasExistingDateValueChanged) {\n                            this.forceUpdateWithSelection();\n                        }\n                        else {\n                            this.restorePreviousInputEventState();\n                        }\n                    }\n                    else if (!isPresent(oldExistingDateValue) && !isPresent(newExistingDateValue)) {\n                        this.forceUpdateWithSelection();\n                    }\n                    else if (oldDateValue !== newDateValue) {\n                        // this can happen on auto correct when no valid value is parsed\n                    }\n                    else {\n                        this.restorePreviousInputEventState();\n                    }\n                }\n                else if (!lastParseResultHasNoValue) {\n                    // the user types a valid but incomplete date (e.g. year \"123\" with format \"yyyy\")\n                    // let them continue typing, but refresh for not fixed formats\n                    if (!hasFixedFormat) {\n                        this.forceUpdateWithSelection();\n                    }\n                }\n            }\n            else {\n                if (!this.options.autoSwitchParts && diff[0][1] === Constants.formatSeparator) {\n                    // do not change the selection when a separator is pressed\n                    // this should happen only if autoSwitchKeys contains the separator explicitly\n                }\n                else {\n                    this.setSelection(this.selectionBySymbol(diff[0][0]));\n                }\n            }\n        }\n        else if (!hasCaret) {\n            this.forceUpdate();\n            if (diff.length && diff[0][0] !== Constants.formatSeparator) {\n                this.setSelection(this.selectionBySymbol(diff[0][0]));\n            }\n            if (this.options.autoSwitchParts) {\n                if (navigationOnly) {\n                    this.resetSegmentValue = true;\n                    if (!switchedPartOnPreviousKeyAction) {\n                        this.switchDateSegment(1);\n                    }\n                    this.switchedPartOnPreviousKeyAction = true;\n                }\n                else if (switchPart) {\n                    this.switchDateSegment(1);\n                    this.switchedPartOnPreviousKeyAction = true;\n                }\n            }\n            else {\n                if (lastParseResult && lastParseResult.switchToNext) {\n                    // the value is complete and should be switched, but the \"autoSwitchParts\" option prevents this\n                    // ensure that the segment value can be reset on next input\n                    this.resetSegmentValue = true;\n                }\n                else if (navigationOnly) {\n                    this.resetSegmentValue = true;\n                    if (!switchedPartOnPreviousKeyAction) {\n                        this.switchDateSegment(1);\n                    }\n                    this.switchedPartOnPreviousKeyAction = true;\n                }\n            }\n            if (isBackspaceKey && this.options.selectPreviousSegmentOnBackspace) {\n                // kendo angular have this UX\n                this.switchDateSegment(-1);\n            }\n        }\n        this.tryTriggerValueChange({\n            oldValue: oldExistingDateValue,\n            event: e\n        });\n        this.triggerInputEnd({ event: e, error: error, oldElementValue: oldElementValue, newElementValue: this.elementValue });\n        if (hasCaret) {\n            // a format like \"F\" can dynamically change the resolved format pattern based on the value, e.g.\n            // \"Tuesday, February 1, 2022 3:04:05 AM\" becomes\n            // \"Wednesday, February 2, 2022 3:04:05 AM\" giving a diff of 2 (\"Tuesday\".length - \"Wednesday\".length)\n            this.setTextAndFormat();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onElementFocus(e) {\n        if (this.triggerFocus({ event: e })) {\n            return;\n        }\n        this.isActive = true;\n        this.interactionMode = DateInputInteractionMode.None;\n        this.switchedPartOnPreviousKeyAction = false;\n        this.refreshElementValue();\n        if (!this.mouseDownStarted) {\n            this.caret(0, this.elementValue.length);\n        }\n        this.mouseDownStarted = false;\n        this.triggerFocusEnd({ event: e });\n    }\n    /**\n     * @hidden\n     */\n    onElementBlur(e) {\n        this.resetSegmentValue = true;\n        this.isActive = false;\n        if (this.triggerBlur({ event: e })) {\n            return;\n        }\n        if (this.options.autoFill) {\n            this.autoFill();\n        }\n        this.interactionMode = DateInputInteractionMode.None;\n        this.switchedPartOnPreviousKeyAction = false;\n        this.refreshElementValue();\n        this.triggerBlurEnd({ event: e });\n    }\n    /**\n     * @hidden\n     */\n    onElementChange(e) {\n        this.triggerChange({ event: e });\n    }\n    /**\n     * @hidden\n     */\n    onElementKeyDown(e) {\n        if (this.triggerKeyDown({ event: e })) {\n            return;\n        }\n        const { start, end } = this.selection;\n        const event = e;\n        this.keyDownEvent = e;\n        this.previousElementValue = this.element.value;\n        this.previousElementSelection = { start, end };\n        if (this.keyEventMatchesAutoSwitchKeys(e)) {\n            const isTabKey = e.keyCode === KeyCode.TAB;\n            if (isTabKey) {\n                const { start: selectionStart, end: selectionEnd } = this.selection;\n                if (e.shiftKey && isTabKey) {\n                    this.switchDateSegment(-1);\n                }\n                else {\n                    this.switchDateSegment(1);\n                }\n                if (selectionStart !== this.selection.start || selectionEnd !== this.selection.end) {\n                    // when the selection changes, prevent the default Tab behavior\n                    e.preventDefault();\n                    return;\n                }\n            }\n            else {\n                // do not allow the \"input\" event to be triggered\n                e.preventDefault();\n                this.switchDateSegment(1);\n                return;\n            }\n        }\n        const symbol = this.currentFormat[this.selection.start];\n        const step = this.getStepFromSymbol(symbol);\n        let shouldPreventDefault = false;\n        const oldElementValue = this.elementValue;\n        if (e.altKey || e.ctrlKey || e.metaKey || e.keyCode === KeyCode.TAB) {\n            return;\n        }\n        switch (e.keyCode) {\n            case KeyCode.ARROW_LEFT:\n                this.switchDateSegment(-1);\n                shouldPreventDefault = true;\n                this.switchedPartOnPreviousKeyAction = false;\n                break;\n            case KeyCode.ARROW_UP:\n                this.modifyDateSegmentValue(step, symbol, event);\n                if (oldElementValue !== this.elementValue) {\n                    this.triggerInputEnd({ event: e, error: null, newElementValue: this.elementValue, oldElementValue: oldElementValue });\n                }\n                shouldPreventDefault = true;\n                this.switchedPartOnPreviousKeyAction = false;\n                break;\n            case KeyCode.ARROW_RIGHT:\n                this.switchDateSegment(1);\n                shouldPreventDefault = true;\n                this.switchedPartOnPreviousKeyAction = false;\n                break;\n            case KeyCode.ARROW_DOWN:\n                this.modifyDateSegmentValue(-step, symbol, event);\n                if (oldElementValue !== this.elementValue) {\n                    this.triggerInputEnd({ event: e, error: null, newElementValue: this.elementValue, oldElementValue: oldElementValue });\n                }\n                shouldPreventDefault = true;\n                this.switchedPartOnPreviousKeyAction = false;\n                break;\n            case KeyCode.ENTER:\n                // todo: handle \"change\" event\n                break;\n            case KeyCode.HOME:\n                this.selectNearestSegment(0);\n                shouldPreventDefault = true;\n                this.switchedPartOnPreviousKeyAction = false;\n                this.resetSegmentValue = true;\n                break;\n            case KeyCode.END:\n                this.selectNearestSegment(this.elementValue.length);\n                shouldPreventDefault = true;\n                this.switchedPartOnPreviousKeyAction = false;\n                this.resetSegmentValue = true;\n                break;\n            default:\n                // allow the \"input\" event to handle the change\n                return;\n        }\n        if (shouldPreventDefault) {\n            e.preventDefault();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onElementPaste() {\n        this.isPasteInProgress = true;\n    }\n    /**\n     * @hidden\n     */\n    onElementMouseWheel(e) {\n        const oldElementValue = this.elementValue;\n        if (!this.options.enableMouseWheel || this.triggerMouseWheel({ event: e })) {\n            return;\n        }\n        if (!this.isActive) {\n            return;\n        }\n        const event = e;\n        if (event.shiftKey) {\n            this.switchDateSegment((event.wheelDelta || -event.detail) > 0 ? -1 : 1);\n        }\n        else {\n            this.modifyDateSegmentValue((event.wheelDelta || -event.detail) > 0 ? 1 : -1);\n        }\n        event.returnValue = false;\n        if (event.preventDefault) {\n            event.preventDefault();\n        }\n        if (oldElementValue !== this.elementValue) {\n            this.triggerInputEnd({ event: e, error: null, newElementValue: this.elementValue, oldElementValue: oldElementValue });\n        }\n    }\n    updateOnPaste(e) {\n        let value = this.intl.parseDate(this.elementValue, this.inputFormat) || this.value;\n        if (isPresent(value) && this.dateObject.shouldNormalizeCentury()) {\n            value = this.dateObject.normalizeCentury(value);\n        }\n        const oldDateObjectValue = this.dateObject && this.dateObject.getValue();\n        this.writeValue(value);\n        this.tryTriggerValueChange({\n            oldValue: oldDateObjectValue,\n            event: e\n        });\n    }\n    get elementValue() {\n        return (this.element || {}).value || '';\n    }\n    get inputFormat() {\n        if (!this.options.format) {\n            return Constants.defaultDateFormat;\n        }\n        if (typeof this.options.format === 'string') {\n            return this.options.format;\n        }\n        else {\n            return this.options.format.inputFormat;\n        }\n    }\n    get displayFormat() {\n        if (!this.options.format) {\n            return Constants.defaultDateFormat;\n        }\n        if (typeof this.options.format === 'string') {\n            return this.options.format;\n        }\n        else {\n            return this.options.format.displayFormat;\n        }\n    }\n    get selection() {\n        let returnValue = { start: 0, end: 0 };\n        if (this.element !== null && this.element.selectionStart !== undefined) {\n            returnValue = {\n                start: this.element.selectionStart,\n                end: this.element.selectionEnd\n            };\n        }\n        return returnValue;\n    }\n    setSelection(selection) {\n        if (this.element && document.activeElement === this.element) {\n            this.element.setSelectionRange(selection.start, selection.end);\n            if (isDocumentAvailable() && isIOS()) {\n                this.element.scrollIntoView({ block: 'nearest', inline: 'nearest' });\n            }\n            if (selection.start !== selection.end) {\n                this.interactionMode = DateInputInteractionMode.Selection;\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    selectionBySymbol(symbol) {\n        let start = -1;\n        let end = 0;\n        for (let i = 0; i < this.currentFormat.length; i++) {\n            if (this.currentFormat[i] === symbol) {\n                end = i + 1;\n                if (start === -1) {\n                    start = i;\n                }\n            }\n        }\n        if (start < 0) {\n            start = 0;\n        }\n        if (!this.options.autoCorrectParts && this.currentFormat.length !== this.currentText.length) {\n            if (this.currentFormat.length < this.currentText.length) {\n                end += this.currentText.length - this.currentFormat.length;\n            }\n            else {\n                end = Math.max(0, end - (this.currentFormat.length - this.currentText.length));\n            }\n        }\n        return { start, end };\n    }\n    /**\n     * @hidden\n     */\n    selectionByIndex(index) {\n        let selection = { start: index, end: index };\n        for (let i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {\n            if (i < this.currentFormat.length && this.currentFormat[i] !== Constants.formatSeparator) {\n                selection = this.selectionBySymbol(this.currentFormat[i]);\n                break;\n            }\n            if (j >= 0 && this.currentFormat[j] !== Constants.formatSeparator) {\n                selection = this.selectionBySymbol(this.currentFormat[j]);\n                break;\n            }\n        }\n        return selection;\n    }\n    switchDateSegment(offset) {\n        const selection = this.selection;\n        if (this.isInCaretMode()) {\n            let start = selection.start;\n            const currentSymbol = this.currentFormat[start - 1];\n            let symbol = \"\";\n            let symbolCandidate = \"\";\n            if (offset < 0) {\n                for (let i = start + offset; i >= 0; i--) {\n                    symbolCandidate = this.currentFormat[i];\n                    if (symbolCandidate !== Constants.formatSeparator &&\n                        symbolCandidate !== currentSymbol) {\n                        start = i;\n                        symbol = symbolCandidate;\n                        break;\n                    }\n                }\n            }\n            else {\n                for (let i = start + offset; i < this.currentFormat.length; i++) {\n                    symbolCandidate = this.currentFormat[i];\n                    if (symbolCandidate !== Constants.formatSeparator &&\n                        symbolCandidate !== currentSymbol) {\n                        start = i;\n                        symbol = symbolCandidate;\n                        break;\n                    }\n                }\n            }\n            if (symbol) {\n                this.forceUpdate();\n                this.setSelection(this.selectionBySymbol(symbol));\n                this.interactionMode = DateInputInteractionMode.Selection;\n                return;\n            }\n        }\n        this.interactionMode = DateInputInteractionMode.None;\n        const { start: selectionStart, end: selectionEnd } = this.selection;\n        if (selectionStart < selectionEnd &&\n            this.currentFormat[selectionStart] !== this.currentFormat[selectionEnd - 1]) {\n            this.setSelection(this.selectionByIndex(offset > 0 ? selectionStart : selectionEnd - 1));\n            this.resetSegmentValue = true;\n            this.interactionMode = DateInputInteractionMode.None;\n            return;\n        }\n        const previousFormatSymbol = this.currentFormat[selectionStart];\n        let a = selectionStart + offset;\n        while (a > 0 && a < this.currentFormat.length) {\n            if (this.currentFormat[a] !== previousFormatSymbol &&\n                this.currentFormat[a] !== Constants.formatSeparator) {\n                break;\n            }\n            a += offset;\n        }\n        if (this.currentFormat[a] === Constants.formatSeparator) {\n            // no known symbol is found\n            return;\n        }\n        let b = a;\n        while (b >= 0 && b < this.currentFormat.length) {\n            if (this.currentFormat[b] !== this.currentFormat[a]) {\n                break;\n            }\n            b += offset;\n        }\n        if (a > b && (b + 1 !== selectionStart || a + 1 !== selectionEnd)) {\n            this.setSelection({ start: b + 1, end: a + 1 });\n            this.resetSegmentValue = true;\n        }\n        else if (a < b && (a !== selectionStart || b !== selectionEnd)) {\n            this.setSelection({ start: a, end: b });\n            this.resetSegmentValue = true;\n        }\n        this.interactionMode = DateInputInteractionMode.None;\n    }\n    modifyDateSegmentValue(offset, symbol = \"\", event = {}) {\n        if (!this.dateObject || this.options.readonly) {\n            return;\n        }\n        const oldValue = this.value;\n        let step = DEFAULT_SEGMENT_STEP;\n        const caret = this.caret();\n        symbol = symbol || this.currentFormat[caret[0]];\n        if (symbol === \"S\" && (!this.options.steps.millisecond || this.options.steps.millisecond === DEFAULT_SEGMENT_STEP)) {\n            const msDigits = millisecondDigitsInFormat(this.inputFormat);\n            step = millisecondStepFor(msDigits);\n        }\n        this.dateObject.modifyPart(symbol, step * offset);\n        this.tryTriggerValueChange({\n            oldValue: oldValue,\n            event: event\n        });\n        this.forceUpdate();\n        this.setSelection(this.selectionBySymbol(symbol));\n    }\n    /**\n     * @hidden\n     */\n    tryTriggerValueChange(args = { oldValue: null, event: {} }) {\n        if (!isEqual(this.value, args.oldValue)) {\n            return this.triggerValueChange(args);\n        }\n    }\n    /**\n     * @hidden\n     */\n    triggerValueChange(args = { oldValue: null, event: {} }) {\n        return this.trigger(VALUE_CHANGE, extend(args, {\n            value: this.value\n        }));\n    }\n    /**\n     * @hidden\n     */\n    triggerInput(args = { event: {} }) {\n        return this.trigger(INPUT, extend(args, {\n            value: this.value\n        }));\n    }\n    /**\n     * @hidden\n     */\n    triggerInputEnd(args = { event: {}, error: null, oldElementValue: '', newElementValue: '' }) {\n        return this.trigger(INPUT_END, extend(args, {\n            value: this.value\n        }));\n    }\n    /**\n     * @hidden\n     */\n    triggerFocus(args = { event: {} }) {\n        return this.trigger(FOCUS, extend({}, args));\n    }\n    /**\n     * @hidden\n     */\n    triggerFocusEnd(args = { event: {} }) {\n        return this.trigger(FOCUS_END, extend({}, args));\n    }\n    /**\n     * @hidden\n     */\n    triggerBlur(args = { event: {} }) {\n        return this.trigger(BLUR, extend({}, args));\n    }\n    /**\n     * @hidden\n     */\n    triggerBlurEnd(args = { event: {} }) {\n        return this.trigger(BLUR_END, extend({}, args));\n    }\n    /**\n     * @hidden\n     */\n    triggerChange(args = { event: {} }) {\n        return this.trigger(CHANGE, extend(args, {\n            value: this.value\n        }));\n    }\n    /**\n     * @hidden\n     */\n    triggerKeyDown(args = { event: {} }) {\n        return this.trigger(KEY_DOWN, extend({}, args));\n    }\n    /**\n     * @hidden\n     */\n    triggerMouseWheel(args = { event: {} }) {\n        return this.trigger(MOUSE_WHEEL, extend({}, args));\n    }\n    /**\n     * @hidden\n     */\n    forceUpdate() {\n        this.setTextAndFormat();\n        this.refreshElementValue();\n    }\n    /**\n     * @hidden\n     */\n    forceUpdateWithSelection() {\n        const { start, end } = this.selection;\n        const elementValueLength = this.elementValue.length;\n        this.forceUpdate();\n        const selectionOffset = this.elementValue.length - elementValueLength;\n        this.setSelection({\n            start: start + selectionOffset,\n            end: end + selectionOffset\n        });\n    }\n    /**\n     * @hidden\n     */\n    setTextAndFormat() {\n        const { text: currentText, format: currentFormat } = this.dateObject.getTextAndFormat();\n        this.currentFormat = currentFormat;\n        this.currentText = currentText;\n    }\n    /**\n     * @hidden\n     */\n    setElementValue(value) {\n        this.element.value = value;\n    }\n    /**\n     * @hidden\n     */\n    getStepFromSymbol(symbol) {\n        /* eslint-disable no-fallthrough */\n        switch (symbol) {\n            case \"S\":\n                return Number(this.options.steps.millisecond);\n            case \"s\":\n                return Number(this.options.steps.second);\n            case \"m\":\n                return Number(this.options.steps.minute);\n            // represents hour as value from 01 through 12\n            case \"h\":\n            // represents hour as value from 01 through 23\n            case \"H\":\n                return Number(this.options.steps.hour);\n            case \"M\":\n                return Number(this.options.steps.month);\n            // there is no 'D' format specifier for day\n            case \"d\":\n            // used for formats such as \"EEEE, MMMM d, yyyy\",\n            // where \"EEEE\" stands for full name of the day e.g. Monday\n            case \"E\":\n                return Number(this.options.steps.day);\n            // there is no 'Y' format specifier for year\n            case \"y\":\n                return Number(this.options.steps.year);\n            default:\n                return DEFAULT_SEGMENT_STEP;\n        }\n        /* eslint-enable no-fallthrough */\n    }\n    /**\n     * @hidden\n     */\n    restorePreviousInputEventState() {\n        this.restorePreviousElementValue();\n        this.restorePreviousElementSelection();\n    }\n    /**\n     * @hidden\n     */\n    restorePreviousElementValue() {\n        this.setElementValue(this.previousElementValue || '');\n    }\n    /**\n     * @hidden\n     */\n    restorePreviousElementSelection() {\n        const { start, end } = this.previousElementSelection;\n        this.setSelection({ start: start || 0, end: end || 0 });\n    }\n    writeValue(value) {\n        this.verifyValue(value);\n        this.dateObject = this.getDateObject(value);\n        this.refreshElementValue();\n    }\n    verifyValue(value) {\n        if (value && !isValidDate(value)) {\n            throw new Error(\"The 'value' should be a valid JavaScript Date instance.\");\n        }\n    }\n    refreshElementValue() {\n        const element = this.element;\n        const format = this.isActive ? this.inputFormat : this.displayFormat;\n        const { text: currentText, format: currentFormat } = this.dateObject.getTextAndFormat(format);\n        this.currentFormat = currentFormat;\n        this.currentText = currentText;\n        const hasPlaceholder = this.options.hasPlaceholder || isPresent(this.options.placeholder);\n        const showPlaceholder = !this.isActive &&\n            hasPlaceholder &&\n            !this.dateObject.hasValue();\n        if (hasPlaceholder && isPresent(this.options.placeholder)) {\n            element.placeholder = this.options.placeholder;\n        }\n        const newElementValue = showPlaceholder ? \"\" : currentText;\n        this.previousElementValue = this.elementValue;\n        this.setElementValue(newElementValue);\n    }\n    /**\n     * @hidden\n     */\n    caret(start, end = start) {\n        const isPosition = start !== undefined;\n        let returnValue = [start, start];\n        const element = this.element;\n        if (isPosition && (this.options.disabled || this.options.readonly)) {\n            return undefined;\n        }\n        try {\n            if (element.selectionStart !== undefined) {\n                if (isPosition) {\n                    if (isDocumentAvailable() && document.activeElement !== element) {\n                        element.focus();\n                    }\n                    element.setSelectionRange(start, end);\n                }\n                returnValue = [element.selectionStart, element.selectionEnd];\n            }\n        }\n        catch (e) {\n            returnValue = [];\n        }\n        return returnValue;\n    }\n    selectNearestSegment(index) {\n        // Finds the nearest (in both directions) known part.\n        for (let i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {\n            if (i < this.currentFormat.length && this.currentFormat[i] !== \"_\") {\n                this.selectDateSegment(this.currentFormat[i]);\n                return;\n            }\n            if (j >= 0 && this.currentFormat[j] !== \"_\") {\n                this.selectDateSegment(this.currentFormat[j]);\n                return;\n            }\n        }\n    }\n    selectDateSegment(symbol) {\n        let begin = -1;\n        let end = 0;\n        for (let i = 0; i < this.currentFormat.length; i++) {\n            if (this.currentFormat[i] === symbol) {\n                end = i + 1;\n                if (begin === -1) {\n                    begin = i;\n                }\n            }\n        }\n        if (begin < 0) {\n            begin = 0;\n        }\n        this.caret(0, 0);\n        this.caret(begin, end);\n    }\n    /**\n     * @hidden\n     */\n    getDateObject(value) {\n        const { leadingZero } = (this.dateObject || {}) || null;\n        this.options.value = value;\n        const dateObject = this.createDateObject();\n        dateObject.setLeadingZero(this.isActive ? leadingZero : null);\n        return dateObject;\n    }\n    /* tslint:disable:align */\n    /**\n     * @hidden\n     */\n    createDateObject() {\n        const defaultOptions = this.getDateObjectOptions();\n        const dateObject = new DateObject(extend({}, defaultOptions));\n        return dateObject;\n    }\n    /**\n     * @hidden\n     */\n    getDateObjectOptions() {\n        const newOptions = {\n            intlService: this.options.intlService,\n            formatPlaceholder: this.options.formatPlaceholder ? this.options.formatPlaceholder : 'formatPattern',\n            format: this.inputFormat,\n            cycleTime: this.options.cycleTime,\n            twoDigitYearMax: this.options.twoDigitYearMax,\n            autoCorrectParts: this.options.autoCorrectParts,\n            value: this.options.value,\n            toggleDayPeriod: this.options.toggleDayPeriod,\n            autoSwitchParts: this.options.autoSwitchParts\n        };\n        return newOptions;\n    }\n    /* tslint:enable:align */\n    /**\n     * @hidden\n     */\n    keyEventMatchesAutoSwitchKeys(keyObject) {\n        const autoSwitchKeys = (this.options.autoSwitchKeys || [])\n            .map(x => x.toString().toLowerCase().trim());\n        if (autoSwitchKeys.indexOf(keyObject.keyCode.toString()) >= 0 ||\n            autoSwitchKeys.indexOf(keyObject.keyCode) >= 0 ||\n            autoSwitchKeys.indexOf(keyObject.key.toLowerCase().trim()) >= 0) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @hidden\n     */\n    autoFill() {\n        const dateObject = this.dateObject;\n        const currentDate = new Date();\n        let day, month, year, hours, minutes, seconds;\n        if (dateObject.date || dateObject.month || dateObject.year || dateObject.hours || dateObject.minutes || dateObject.seconds) {\n            year = dateObject.year ? dateObject.value.getFullYear() : currentDate.getFullYear(),\n                month = dateObject.month ? dateObject.value.getMonth() : currentDate.getMonth(),\n                day = dateObject.date ? dateObject.value.getDate() : currentDate.getDate(),\n                hours = dateObject.hours ? dateObject.value.getHours() : currentDate.getHours(),\n                minutes = dateObject.minutes ? dateObject.value.getMinutes() : currentDate.getMinutes(),\n                seconds = dateObject.seconds ? dateObject.value.getSeconds() : currentDate.getSeconds();\n            dateObject.setValue(new Date(year, month, day, hours, minutes, seconds));\n            this.refreshElementValue();\n            this.triggerValueChange();\n        }\n    }\n}\n","import \"./kendo.core.js\";\nimport \"./kendo.label.js\";\nimport \"./kendo.icons.js\";\nimport { DateInput as DateInputCommon } from \"@progress/kendo-dateinputs-common\";\n\nexport const __meta__ = {\n    id: \"dateinput\",\n    name: \"DateInput\",\n    category: \"web\",\n    description: \"The DateInput widget allows to edit date by typing.\",\n    depends: [ \"core\", \"label\" ]\n};\n\n(function($, undefined) {\n    var global = window;\n    var kendo = global.kendo;\n    var ui = kendo.ui;\n    var Widget = ui.Widget;\n    var ns = \".kendoDateInput\";\n    var objectToString = {}.toString;\n    var isPlainObject = $.isPlainObject;\n\n\n    var FOCUSED = \"k-focus\";\n    var STATEDISABLED = \"k-disabled\";\n    var STATEINVALID = \"k-invalid\";\n\n    var DISABLED = \"disabled\";\n    var READONLY = \"readonly\";\n    var CHANGE = \"change\";\n\n    var IntlService = kendo.Class.extend({\n        init: function(options) {\n            const info = options.culture ? kendo.getCulture(options.culture) : kendo.culture();\n            this.messages = options.messages;\n            this.cldr = { };\n            this.cldr[info.name] = {\n                name: info.name,\n                calendar: info.calendar || {},\n                numbers: info.numberFormat\n            };\n        },\n\n        parseDate: function(value, format, culture) {\n            return kendo.parseDate(value, format, culture, true);\n        },\n\n        formatDate: function(date, format, culture) {\n            return kendo.toString(date, format, culture);\n        },\n\n        splitDateFormat: function(format) {\n            return kendo.date.splitDateFormat(format);\n        },\n\n        dateFormatNames: function(locale, options) {\n            return kendo.date.dateFormatNames(options);\n        },\n\n        dateFieldName: function(options) {\n            return this.messages[options.type] || {};\n        }\n    });\n\n    function buildKeys() {\n        const cultureInfo = kendo.culture();\n        let keys = [];\n\n        keys.push(cultureInfo.calendars.standard[\"/\"]);\n        keys.push(cultureInfo.calendars.standard[\":\"]);\n\n        return keys;\n    }\n\n    function getCultureFormat(culture, format) {\n        if (!culture) {\n            return format;\n        }\n        const cultureInfo = kendo.getCulture(culture);\n        return cultureInfo.calendars.standard.patterns[format] || format;\n    }\n\n    var DateInput = Widget.extend({\n        init: function(element, options) {\n            var that = this;\n\n            Widget.fn.init.call(that, element, options);\n            element = that.element;\n\n            options = that.options;\n            options.format = kendo._extractFormat(options.format || kendo.getCulture(options.culture).calendars.standard.patterns.d);\n            options.min = kendo.parseDate(element.attr(\"min\")) || kendo.parseDate(options.min);\n            options.max = kendo.parseDate(element.attr(\"max\")) || kendo.parseDate(options.max);\n            options.inputMode = options.inputMode || element.attr(\"inputmode\") || \"text\";\n\n            var wrapperClass = (element.parent().attr(\"class\") || \"\");\n            var skipStyling = wrapperClass.indexOf(\"picker\") >= 0 && wrapperClass.indexOf(\"rangepicker\") < 0;\n            var initialValue = that.options.value || element.val();\n\n            if (skipStyling) {\n                that.wrapper = that.element.parent();\n            } else {\n                that.wrapper = element.wrap(\"<span class='k-dateinput k-input'></span>\").parent();\n                that.wrapper.addClass(element[0].className).removeClass('input-validation-error');\n            }\n            that.wrapper[0].style.cssText = element[0].style.cssText;\n            element.css({\n                height: element[0].style.height\n            });\n\n\n            that._validationIcon = $(kendo.ui.icon({ icon: \"exclamation-circle\", iconClass: \"k-input-validation-icon k-hidden\" })).insertAfter(element);\n\n            that._form();\n\n            that.dateInputInstance = new DateInputCommon(element[0], {\n                format: getCultureFormat(options.culture, options.format),\n                autoCorrectParts: options.autoCorrectParts,\n                autoSwitchKeys: options.autoSwitchKeys.length ? options.autoSwitchKeys : buildKeys(),\n                enableMouseWheel: options.enableMouseWheel,\n                twoDigitYearMax: options.twoDigitYearMax,\n                steps: options.steps,\n                formatPlaceholder: options.messages,\n                events: {\n                    inputEnd: function(e) {\n                        if (e.error) {\n                            that._blinkInvalidState();\n                        }\n                    },\n                    keydown: function(e) {\n                        if (!e.event.keyCode) {\n                            e.preventDefault();\n                            return;\n                        }\n                        if (e.event.keyCode == kendo.keys.UP || e.event.keyCode == kendo.keys.DOWN) {\n                            setTimeout(function() {\n                                that.element.trigger(CHANGE);\n                            });\n                        }\n                    },\n                    blur: function(e) {\n                        that._change();\n                        e.preventDefault();\n                    },\n                },\n                intlService: new IntlService({\n                    culture: options.culture,\n                    messages: that.options.messages\n                }),\n                autoSwitchParts: options.autoSwitchParts,\n                autoFill: options.autoFill,\n                toggleDayPeriod: options.toggleDayPeriod\n            });\n\n            that._emptyMask = this.element.val();\n            if (options.value) {\n                that.value(options.value);\n            }\n\n            that.element\n                .addClass(\"k-input-inner\")\n                .attr(\"autocomplete\", \"off\")\n                .attr(\"inputmode\", options.inputMode)\n                .on(\"focus\" + ns, function() {\n                    that.wrapper.addClass(FOCUSED);\n                })\n                .on(\"focusout\" + ns, function() {\n                    that.wrapper.removeClass(FOCUSED);\n                });\n\n            try {\n                element[0].setAttribute(\"type\", \"text\");\n            } catch (e) {\n                element[0].type = \"text\";\n            }\n\n            var disabled = element.is(\"[disabled]\") || $(that.element).parents(\"fieldset\").is(':disabled');\n\n            if (disabled) {\n                that.enable(false);\n            } else {\n                that.readonly(element.is(\"[readonly]\"));\n            }\n            that.value(initialValue);\n            if (!skipStyling) {\n                that._applyCssClasses();\n            }\n\n            if (options.label) {\n                that._label();\n            }\n            that.element.removeAttr(\"style\");\n            kendo.notify(that);\n        },\n\n        options: {\n            name: \"DateInput\",\n            autoAdjust: true,\n            autoCorrectParts: true,\n            autoSwitchKeys: [],\n            autoSwitchParts: false,\n            enableMouseWheel: true,\n            culture: \"\",\n            value: \"\",\n            format: \"\",\n            min: new Date(1900, 0, 1),\n            max: new Date(2099, 11, 31),\n            messages: {\n                \"year\": \"year\",\n                \"month\": \"month\",\n                \"day\": \"day\",\n                \"weekday\": \"day of the week\",\n                \"hour\": \"hours\",\n                \"minute\": \"minutes\",\n                \"second\": \"seconds\",\n                \"milliseconds\": \"milliseconds\",\n                \"dayperiod\": \"AM/PM\"\n            },\n            size: undefined,\n            steps: {\n                year: 1,\n                month: 1,\n                day: 1,\n                hour: 1,\n                minute: 1,\n                second: 1,\n                millisecond: 1,\n            },\n            fillMode: undefined,\n            rounded: undefined,\n            label: null,\n            autoFill: false,\n            toggleDayPeriod: true\n        },\n\n        events: [\n            CHANGE\n        ],\n\n        min: function(value) {\n            if (value !== undefined) {\n                this.options.min = value;\n            } else {\n                return this.options.min;\n            }\n        },\n\n        max: function(value) {\n            if (value !== undefined) {\n                this.options.max = value;\n            } else {\n                return this.options.max;\n            }\n        },\n\n        setOptions: function(options) {\n            var that = this;\n            Widget.fn.setOptions.call(that, options);\n            that.dateInputInstance.destroy();\n            that.dateInputInstance = null;\n\n            that.dateInputInstance = new DateInputCommon(this.element[0], {\n                format: getCultureFormat(that.options.culture, that.options.format),\n                autoSwitchKeys: that.options.autoSwitchKeys.length ? that.options.autoSwitchKeys : buildKeys(),\n                autoCorrectParts: that.options.autoCorrectParts,\n                enableMouseWheel: that.options.enableMouseWheel,\n                steps: that.options.steps,\n                twoDigitYearMax: that.options.twoDigitYearMax,\n                formatPlaceholder: that.options.messages,\n                events: {\n                    inputEnd: function(e) {\n                        if (e.error) {\n                            that._blinkInvalidState();\n                        }\n                    },\n                    keydown: function(e) {\n                        if (e.event.keyCode == kendo.keys.UP || e.event.keyCode == kendo.keys.DOWN) {\n                            setTimeout(function() {\n                                that.element.trigger(CHANGE);\n                            });\n                        }\n                    },\n                    blur: function(e) {\n                        that._change();\n                        e.preventDefault();\n                    },\n                },\n                intlService: new IntlService({\n                    culture: that.options.culture,\n                    messages: that.options.messages\n                }),\n                autoSwitchParts: that.options.autoSwitchParts,\n                autoFill: that.options.autoFill,\n                toggleDayPeriod: that.options.toggleDayPeriod\n            });\n\n            that.value(options.value);\n        },\n\n        destroy: function() {\n            var that = this;\n            that.element.off(ns);\n            that.dateInputInstance.destroy();\n\n            this.element.val(\"\");\n            this.element.attr(\"value\", \"\");\n\n            if (that._formElement) {\n                that._formElement.off(\"reset\", that._resetHandler);\n            }\n\n            if (that.label) {\n                that.label.destroy();\n            }\n\n            if (that._validationIcon) {\n                that._validationIcon.remove();\n            }\n\n            Widget.fn.destroy.call(that);\n        },\n\n        value: function(value) {\n            if (value === undefined) {\n                return this.dateInputInstance.value;\n            }\n\n            if (value === null) {\n                value = \"\";\n            }\n\n            if (objectToString.call(value) !== \"[object Date]\") {\n                value = kendo.parseDate(value, this.options.format, this.options.culture);\n            }\n\n            if (value && !value.getTime()) {\n                value = null;\n            }\n\n            this.dateInputInstance.writeValue(value);\n\n            this._oldValue = value;\n\n            if (this.label && this.label.floatingLabel) {\n                this.label.floatingLabel.refresh();\n            }\n        },\n\n        _hasDateInput: function() {\n\n            return this._emptyMask !== this.element.val();\n        },\n\n        readonly: function(readonly) {\n            this._editable({\n                readonly: readonly === undefined ? true : readonly,\n                disable: false\n            });\n\n            if (this.label && this.label.floatingLabel) {\n                this.label.floatingLabel.readonly(readonly === undefined ? true : readonly);\n            }\n        },\n\n        enable: function(enable) {\n            this._editable({\n                readonly: false,\n                disable: !(enable = enable === undefined ? true : enable)\n            });\n\n            if (this.label && this.label.floatingLabel) {\n                this.label.floatingLabel.enable(enable = enable === undefined ? true : enable);\n            }\n        },\n\n        _label: function() {\n            var that = this;\n            var options = that.options;\n            var labelOptions = isPlainObject(options.label) ? options.label : {\n                content: options.label\n            };\n\n            that.label = new kendo.ui.Label(null, $.extend({}, labelOptions, {\n                widget: that,\n                floatCheck: () => {\n                    if (!that.value() && (!that._hasDateInput() || that.element.val() === \"\") && document.activeElement !== that.element[0]) {\n                        this.element.val(\"\");\n                        return true;\n                    }\n\n                    return false;\n                }\n            }));\n\n            that._inputLabel = that.label.element;\n        },\n\n        _bindInput: function() {\n            var that = this;\n            that.element\n                .on(\"focus\" + ns, function() {\n                    that.wrapper.addClass(FOCUSED);\n                })\n                .on(\"focusout\" + ns, function() {\n                    that.wrapper.removeClass(FOCUSED);\n                });\n\n            if (this.dateInputInstance) {\n                this.dateInputInstance.bindEvents();\n            }\n        },\n\n        _unbindInput: function() {\n            this.element\n                .off(\"focus\" + ns)\n                .off(\"focusout\" + ns);\n\n            if (this.dateInputInstance) {\n                this.dateInputInstance.unbindEvents();\n            }\n        },\n\n        _editable: function(options) {\n            var that = this;\n            var element = that.element;\n            var disable = options.disable;\n            var readonly = options.readonly;\n            var wrapper = that.wrapper;\n\n            that._unbindInput();\n\n            if (!readonly && !disable) {\n                wrapper.removeClass(STATEDISABLED);\n                if (element && element.length) {\n                    element[0].removeAttribute(DISABLED);\n                    element[0].removeAttribute(READONLY);\n                }\n\n                that._bindInput();\n            } else {\n                if (disable) {\n                    wrapper.addClass(STATEDISABLED);\n                    element.attr(DISABLED, disable);\n                    if (element && element.length) {\n                        element[0].removeAttribute(READONLY);\n                    }\n                }\n                if (readonly) {\n                    element.attr(READONLY, readonly);\n                }\n            }\n        },\n\n        _change: function() {\n            let that = this,\n                oldValue = that._oldValue,\n                value = that.value(),\n                autoAdjust = that.options.autoAdjust;\n\n            if (autoAdjust && value && that.min() && value < that.min()) {\n                that.value(that.min());\n                value = that.value();\n            }\n            if (autoAdjust && value && that.max() && value > that.max()) {\n                that.value(that.max());\n                value = that.value();\n            }\n\n            if (oldValue && value && value.getTime() !== oldValue.getTime() ||\n                oldValue && !value ||\n                !oldValue && value\n            ) {\n                that._oldValue = value;\n                that.trigger(CHANGE, { blur: true });\n                that.element.trigger(CHANGE);\n            }\n        },\n\n\n        _blinkInvalidState: function() {\n            var that = this;\n\n            that._addInvalidState();\n            clearTimeout(that._invalidStateTimeout);\n            that._invalidStateTimeout = setTimeout(that._removeInvalidState.bind(that), 100);\n        },\n\n        _addInvalidState: function() {\n            var that = this;\n\n            that.wrapper.addClass(STATEINVALID);\n            that._validationIcon.removeClass(\"k-hidden\");\n        },\n\n        _removeInvalidState: function() {\n            var that = this;\n\n            that.wrapper.removeClass(STATEINVALID);\n            that._validationIcon.addClass(\"k-hidden\");\n            that._invalidStateTimeout = null;\n        },\n\n\n        _form: function() {\n            var that = this;\n            var element = that.element;\n            var formId = element.attr(\"form\");\n            var form = formId ? $(\"#\" + formId) : element.closest(\"form\");\n            var initialValue = element[0].value;\n\n            if (!initialValue && that.options.value) {\n                initialValue = that.options.value;\n            }\n\n            if (form[0]) {\n                that._resetHandler = function() {\n                    setTimeout(function() {\n                        that.value(initialValue);\n                    });\n                };\n\n                that._formElement = form.on(\"reset\", that._resetHandler);\n            }\n        },\n\n        _paste: function(e) {\n            e.preventDefault();\n        },\n\n\n    });\n\n    kendo.cssProperties.registerPrefix(\"DateInput\", \"k-input-\");\n\n    kendo.cssProperties.registerValues(\"DateInput\", [{\n        prop: \"rounded\",\n        values: kendo.cssProperties.roundedValues.concat([['full', 'full']])\n    }]);\n\n    ui.plugin(DateInput);\n\n})(window.kendo.jQuery);\nexport default kendo;\n\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61],"mappings":"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"}