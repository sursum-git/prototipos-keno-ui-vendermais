{"version":3,"file":"kendo.promptbox.min.js","names":["STRING","UNDEFINED","STRING","FUNCTION","UNDEFINED","cssPropertiesNames","licensing","DOT","DOT","DEFAULT_MESSAGES","DOT","COMMA","DATE_OBJECT","objectToString","STRING","STRING","STRING","FUNCTION"],"sources":["../../src/core/models/dependency-container.ts","../../src/core/service-container.ts","../../src/core/services/css-properties.service.ts","../../src/core/services/kendo-jquery.service.ts","../../src/core/base/class.ts","../../src/core/base/observable.ts","../../src/core/services/dom-utils.service.ts","../../src/core/services/utils.service.ts","../../src/core/base/widget.ts","../../src/core/services/html.service.ts","../../src/core/services/file-utils.service.ts","../../src/promptbox/constants.ts","../../src/promptbox/templates/promptbox.template.ts","../../src/promptbox/collaborators/accessibility-manager.collaborator.ts","../../src/promptbox/collaborators/action-button-manager.collaborator.ts","../../src/promptbox/collaborators/speech-handler.collaborator.ts","../../src/promptbox/collaborators/file-handler.collaborator.ts","../../src/promptbox/collaborators/input-manager.collaborator.ts","../../src/promptbox/promptbox.widget.ts","../../src/promptbox/index.ts","../../src/core/models/date-utils.ts","../../src/core/models/dom-utils.ts","../../src/core/base/databound-widget.ts","../../src/core/services/culture.service.ts","../../src/core/services/number-formatter.service.ts","../../src/core/services/date-formatter.service.ts","../../src/core/services/formatter.service.ts","../../src/core/services/number-parser.service.ts","../../src/core/services/date-parser.service.ts","../../src/core/services/kendo-culture-to-intl.service.ts","../../src/core/services/template.service.ts","../../src/core/services/support.service.ts","../../src/core/services/date-utils.service.ts","../../src/core/services/effects.service.ts","../../src/core/services/focus-utils.service.ts","../../src/core/services/property-access.service.ts","../../src/core/services/input.service.ts","../../src/core/services/color.service.ts","../../src/core/services/selector.service.ts","../../src/core/services/timezone.service.ts","../../src/core/services/type-utils.service.ts","../../src/core/services/mouse-event-normalizer.service.ts","../../src/core/services/event-map.service.ts","../../src/core/services/defaults.service.ts","../../src/core/services/widget-registry.service.ts","../../src/core/services/widget-utils.service.ts","../../src/core/services/namespace.service.ts","../../src/kendo.promptbox.js"],"sourcesContent":["/**\n * Service Container Models\n * \n * Simple DI container for Kendo widgets. Services can be:\n * - Singleton: one instance shared everywhere\n * - Scoped: new instance created per resolution\n */\n\nexport enum ServiceLifetime {\n    Singleton = \"singleton\",\n    Scoped = \"scoped\"\n}\n\n/** Constructor type for class-based injection */\nexport type Constructor<T = any> = new (...args: any[]) => T;\n\nexport interface IServiceRegistration<T = any> {\n    /** The class constructor (used as token) */\n    ctor: Constructor<T>;\n    /** Factory to create the service */\n    factory: () => T;\n    /** Service lifetime */\n    lifetime: ServiceLifetime;\n    /** Cached instance (for singletons) */\n    instance?: T;\n}\n\nexport interface IServiceContainer {\n    /**\n     * Register a class as a singleton service.\n     */\n    singleton<T>(ctor: Constructor<T>, factory?: () => T): void;\n\n    /**\n     * Register an existing instance as a singleton.\n     */\n    singletonInstance<T>(ctor: Constructor<T>, instance: T): void;\n\n    /**\n     * Register a class as a scoped service.\n     */\n    scoped<T>(ctor: Constructor<T>, factory?: () => T): void;\n\n    /**\n     * Resolve a service by its class constructor.\n     */\n    resolve<T>(ctor: Constructor<T>): T;\n\n    /**\n     * Try to resolve a service, returns undefined if not registered.\n     */\n    tryResolve<T>(ctor: Constructor<T>): T | undefined;\n\n    /**\n     * Check if a service is registered.\n     */\n    has<T>(ctor: Constructor<T>): boolean;\n\n    /**\n     * Get the lifetime of a registered service.\n     */\n    getLifetime<T>(ctor: Constructor<T>): ServiceLifetime | undefined;\n}\n","/**\n * Service Container\n * \n * A minimal DI container for resolving services in widget constructors.\n * Uses class constructors as tokens for type-safe injection.\n * \n * Usage:\n * ```ts\n * // Registration (during kendo.core.js init)\n * serviceContainer.singleton(UtilsService);\n * serviceContainer.scoped(SomeScopedService);\n * \n * // Or register an existing instance\n * serviceContainer.singletonInstance(UtilsService, existingUtilsService);\n * \n * // In widgets - use inject() with default parameter\n * class Chat extends Widget {\n *     constructor(\n *         element: HTMLElement,\n *         options: ChatOptions,\n *         utils = inject(UtilsService)\n *     ) {\n *         super(element, options);\n *         this.utils = utils;\n *     }\n * }\n * ```\n */\n\nimport { \n    ServiceLifetime, \n    Constructor, \n    IServiceContainer, \n    IServiceRegistration \n} from \"./models/dependency-container\";\n\nclass ServiceContainer implements IServiceContainer {\n    /** Map from constructor to registration */\n    private registrations = new Map<Constructor, IServiceRegistration>();\n\n    /**\n     * Register a class as a singleton service.\n     * One instance will be created and shared everywhere.\n     */\n    singleton<T>(ctor: Constructor<T>, factory?: () => T): void {\n        this.registrations.set(ctor, {\n            ctor,\n            factory: factory ?? (() => new ctor()),\n            lifetime: ServiceLifetime.Singleton,\n            instance: undefined\n        });\n    }\n\n    /**\n     * Register an existing instance as a singleton.\n     * Useful when the instance is already created (e.g., during kendo.core.js init).\n     */\n    singletonInstance<T>(ctor: Constructor<T>, instance: T): void {\n        this.registrations.set(ctor, {\n            ctor,\n            factory: () => instance,\n            lifetime: ServiceLifetime.Singleton,\n            instance\n        });\n    }\n\n    /**\n     * Register a class as a scoped service.\n     * A new instance will be created each time it's resolved.\n     */\n    scoped<T>(ctor: Constructor<T>, factory?: () => T): void {\n        this.registrations.set(ctor, {\n            ctor,\n            factory: factory ?? (() => new ctor()),\n            lifetime: ServiceLifetime.Scoped,\n            instance: undefined\n        });\n    }\n\n    /**\n     * Resolve a service by its class constructor.\n     * - Singleton: returns cached instance (creates on first call)\n     * - Scoped: creates new instance each time\n     */\n    resolve<T>(ctor: Constructor<T>): T {\n        const registration = this.registrations.get(ctor);\n        \n        if (!registration) {\n            throw new Error(`Service ${ctor.name} is not registered`);\n        }\n\n        if (registration.lifetime === ServiceLifetime.Singleton) {\n            // Return cached instance or create and cache\n            if (registration.instance === undefined) {\n                registration.instance = registration.factory();\n            }\n            return registration.instance as T;\n        }\n\n        // Scoped: always create new instance\n        return registration.factory() as T;\n    }\n\n    /**\n     * Try to resolve a service, returns undefined if not registered.\n     */\n    tryResolve<T>(ctor: Constructor<T>): T | undefined {\n        if (!this.has(ctor)) {\n            return undefined;\n        }\n        return this.resolve(ctor);\n    }\n\n    /**\n     * Check if a service is registered.\n     */\n    has<T>(ctor: Constructor<T>): boolean {\n        return this.registrations.has(ctor);\n    }\n\n    /**\n     * Get the lifetime of a registered service.\n     */\n    getLifetime<T>(ctor: Constructor<T>): ServiceLifetime | undefined {\n        return this.registrations.get(ctor)?.lifetime;\n    }\n}\n\n/** Global service container instance */\nexport const serviceContainer = new ServiceContainer();\n\n/**\n * Inject a service by its class constructor.\n * Use as default parameter value in constructors.\n * \n * @example\n * class Chat extends Widget {\n *     constructor(\n *         element: HTMLElement,\n *         options: ChatOptions,\n *         utils = inject(UtilsService)\n *     ) {\n *         this.utils = utils;\n *     }\n * }\n */\nexport function inject<T>(ctor: Constructor<T>): T {\n    return serviceContainer.resolve(ctor);\n}\n","import { \n    ICssPropertiesService, \n    CssValueDefinition, \n    RegisterValuesArg, \n    GetValidClassArgs,\n    DefaultValuesDictionary,\n    PropertyDictionary\n} from \"../models/css-properties\";\n\n// Constant for the prefix key in property dictionary\nconst PREFIX = \"prefix\";\n\n/**\n * Service for managing CSS class properties for widgets\n * Extracted from kendo.cssProperties in kendo.core.js\n */\nexport class CssPropertiesService implements ICssPropertiesService {\n    /**\n     * Predefined theme color values\n     */\n    readonly themeColorValues: CssValueDefinition[] = [\n        'base', 'primary', 'secondary', 'tertiary', 'inherit', \n        'info', 'success', 'warning', 'error', 'dark', 'light', 'inverse'\n    ];\n\n    /**\n     * Predefined fill mode values\n     */\n    readonly fillModeValues: CssValueDefinition[] = ['solid', 'outline', 'flat'];\n\n    /**\n     * Predefined shape values\n     */\n    readonly shapeValues: CssValueDefinition[] = ['rectangle', 'square'];\n\n    /**\n     * Predefined size values\n     */\n    readonly sizeValues: CssValueDefinition[] = [\n        ['small', 'sm'], ['medium', 'md'], ['large', 'lg']\n    ];\n\n    /**\n     * Predefined rounded values\n     */\n    readonly roundedValues: CssValueDefinition[] = [\n        ['small', 'sm'], ['medium', 'md'], ['large', 'lg'], ['full', 'full'], ['none', 'none']\n    ];\n\n    /**\n     * Predefined position mode values\n     */\n    readonly positionModeValues: CssValueDefinition[] = [\n        'fixed', 'static', 'sticky', 'absolute'\n    ];\n\n    /**\n     * Predefined resize values\n     */\n    readonly resizeValues: CssValueDefinition[] = [\n        ['both', 'resize'], ['horizontal', 'resize-x'], ['vertical', 'resize-y']\n    ];\n\n    /**\n     * Predefined overflow values\n     */\n    readonly overflowValues: CssValueDefinition[] = [\n        'auto', 'hidden', 'visible', 'scroll', 'clip'\n    ];\n\n    /**\n     * Predefined layout flow values\n     */\n    readonly layoutFlowValues: CssValueDefinition[] = [\n        ['vertical', '!k-flex-col'], ['horizontal', '!k-flex-row']\n    ];\n\n    /**\n     * Default values dictionary\n     */\n    defaultValues: DefaultValuesDictionary = {};\n\n    /**\n     * Widget property dictionary\n     */\n    propertyDictionary: PropertyDictionary = {};\n\n    /**\n     * Legacy property to CSS class map (for BottomNavigation compatibility)\n     * TODO: delete after implementing new styles and classes for BottomNavigation\n     */\n    propertyToCssClassMap: Record<string, Record<string, string>> = {};\n\n    constructor() {\n        // Register default CSS classes\n        this.registerDefaultCssClasses(\"themeColor\", this.themeColorValues);\n        this.registerDefaultCssClasses(\"fillMode\", this.fillModeValues);\n        this.registerDefaultCssClasses(\"shape\", this.shapeValues);\n        this.registerDefaultCssClasses(\"size\", this.sizeValues);\n        this.registerDefaultCssClasses(\"positionMode\", this.positionModeValues);\n        this.registerDefaultCssClasses(\"rounded\", this.roundedValues);\n        this.registerDefaultCssClasses(\"resize\", this.resizeValues);\n        this.registerDefaultCssClasses(\"overflow\", this.overflowValues);\n        this.registerDefaultCssClasses(\"layoutFlow\", this.layoutFlowValues);\n\n        // Register legacy CSS classes (for BottomNavigation compatibility)\n        this.registerCssClasses(\"themeColor\", this.themeColorValues);\n        this.registerCssClasses(\"fill\", this.fillModeValues);\n        this.registerCssClasses(\"shape\", this.shapeValues);\n        this.registerCssClasses(\"size\", this.sizeValues);\n        this.registerCssClasses(\"positionMode\", this.positionModeValues);\n    }\n\n    /**\n     * Register a CSS prefix for a widget\n     */\n    registerPrefix(widget: string, prefix: string): void {\n        if (!this.propertyDictionary[widget]) {\n            this.propertyDictionary[widget] = {};\n        }\n\n        this.propertyDictionary[widget][PREFIX] = prefix;\n    }\n\n    /**\n     * Register CSS values for a widget\n     */\n    registerValues(widget: string, args: RegisterValuesArg[]): void {\n        let i: number;\n        let j: number;\n        let prop: string;\n        let values: Record<string, string>;\n        let newValues: CssValueDefinition[];\n        let currentValue: CssValueDefinition;\n\n        if (!this.propertyDictionary[widget]) {\n            this.propertyDictionary[widget] = {};\n        }\n\n        for (i = 0; i < args.length; i++) {\n            prop = args[i].prop;\n            newValues = args[i].values;\n\n            if (!this.propertyDictionary[widget][prop]) {\n                this.propertyDictionary[widget][prop] = {};\n            }\n\n            values = this.propertyDictionary[widget][prop] as Record<string, string>;\n\n            for (j = 0; j < newValues.length; j++) {\n                currentValue = newValues[j];\n\n                if (Array.isArray(currentValue)) {\n                    values[(currentValue as [string, string])[0]] = (currentValue as [string, string])[1];\n                } else {\n                    values[currentValue as string] = currentValue as string;\n                }\n            }\n        }\n    }\n\n    /**\n     * Get a valid CSS class for a widget property\n     */\n    getValidClass(args: GetValidClassArgs): string {\n        const widget = args.widget;\n        const propName = args.propName;\n        const value = args.value;\n        const overridePrefix = args.prefix;\n\n        const defaultVals = this.defaultValues[propName];\n        const widgetProperties = this.propertyDictionary[widget];\n\n        if (!widgetProperties) {\n            return \"\";\n        }\n\n        const widgetValues = widgetProperties[propName] as Record<string, string>;\n        const validValue = widgetValues \n            ? (widgetValues[value] || (defaultVals && defaultVals[value])) \n            : (defaultVals && defaultVals[value]);\n\n        if (validValue) {\n            let prefix: string;\n\n            if (propName === \"themeColor\") {\n                prefix = widgetProperties[PREFIX] as string;\n            } else if (propName === \"positionMode\") {\n                prefix = \"k-pos-\";\n            } else if (propName === \"rounded\") {\n                prefix = \"k-rounded-\";\n            } else if (propName === \"resize\") {\n                prefix = \"k-\";\n            } else if (propName === \"overflow\") {\n                prefix = \"k-overflow-\";\n            } else if (propName === \"layoutFlow\") {\n                prefix = \"\";\n            } else {\n                prefix = widgetProperties[PREFIX] as string;\n            }\n\n            prefix = overridePrefix || prefix;\n\n            return prefix + validValue;\n        } else {\n            return \"\";\n        }\n    }\n\n    /**\n     * Register a single CSS class (internal for defaultValues)\n     */\n    private registerDefaultCssClass(propName: string, value: string, shorthand?: string): void {\n        if (!this.defaultValues[propName]) {\n            this.defaultValues[propName] = {};\n        }\n\n        this.defaultValues[propName][value] = shorthand || value;\n    }\n\n    /**\n     * Register multiple CSS classes for a property (internal for defaultValues)\n     */\n    private registerDefaultCssClasses(propName: string, arr: CssValueDefinition[]): void {\n        for (let i = 0; i < arr.length; i++) {\n            if (Array.isArray(arr[i])) {\n                const tuple = arr[i] as [string, string];\n                this.registerDefaultCssClass(propName, tuple[0], tuple[1]);\n            } else {\n                this.registerDefaultCssClass(propName, arr[i] as string);\n            }\n        }\n    }\n\n    // Legacy CSS class methods (for BottomNavigation compatibility)\n    // TODO: delete after implementing new styles and classes for BottomNavigation\n\n    /**\n     * Register a single legacy CSS class\n     */\n    registerCssClass(propName: string, value: string, shorthand?: string): void {\n        if (!this.propertyToCssClassMap[propName]) {\n            this.propertyToCssClassMap[propName] = {};\n        }\n\n        this.propertyToCssClassMap[propName][value] = shorthand || value;\n    }\n\n    /**\n     * Register multiple legacy CSS classes\n     */\n    registerCssClasses(propName: string, arr: CssValueDefinition[]): void {\n        for (let i = 0; i < arr.length; i++) {\n            if (Array.isArray(arr[i])) {\n                const tuple = arr[i] as [string, string];\n                this.registerCssClass(propName, tuple[0], tuple[1]);\n            } else {\n                this.registerCssClass(propName, arr[i] as string);\n            }\n        }\n    }\n\n    /**\n     * Get a valid legacy CSS class\n     */\n    getValidCssClass(prefix: string, propName: string, value: string): string | undefined {\n        if (value === undefined) {\n            return \"\";\n        }\n\n        const validValue = this.propertyToCssClassMap[propName]?.[value];\n\n        if (validValue) {\n            return prefix + validValue;\n        }\n\n        return undefined;\n    }\n}\n","/**\n * KendoJQuery Service\n * \n * Provides a jQuery wrapper with Kendo-specific functionality:\n * - Event namespacing with automatic cleanup\n * - Handler context binding  \n * - Touch/mouse event normalization\n * - Keyboard event handling\n *\n \n *\n * @module core-v2/services/kendo-jquery.service\n */\n\nimport type { ISupportService } from \"../models/support\";\nimport type { IMouseEventNormalizerService } from \"../models/mouse-event-normalizer\";\nimport type { IUtilsService } from \"../models/utils\";\nimport type { \n    IKendoJQueryService, \n    IKendoJQueryStatic, \n    IKendoJQuery,\n    IKeyboardWidget,\n    IKeyDownEvent\n} from \"../models/kendo-jquery\";\nimport type { IEventMapService } from \"../models/event-map\";\n\n// Constants\nconst STRING = \"string\";\nconst UNDEFINED = \"undefined\";\n\n/**\n * KendoJQuery Service\n * Creates and manages the KendoJQuery wrapper around jQuery\n */\nexport class KendoJQueryService implements IKendoJQueryService {\n    private kendoJQuery: IKendoJQueryStatic;\n    private rootjQuery: IKendoJQuery;\n    private originalOn: JQuery[\"on\"];\n\n    constructor(\n        private $: JQueryStatic,\n        private support: ISupportService,\n        private mouseEventNormalizer: IMouseEventNormalizerService,\n        private eventMapService: IEventMapService,\n        private utils: IUtilsService,\n        noDeprecateExtend: (deep: boolean, target: any, ...sources: any[]) => any\n    ) {\n        this.originalOn = $.fn.on;\n        this.kendoJQuery = this.createKendoJQuery(noDeprecateExtend);\n        this.rootjQuery = this.kendoJQuery(document);\n    }\n\n    /**\n     * Create the KendoJQuery constructor and prototype\n     */\n    private createKendoJQuery(noDeprecateExtend: (deep: boolean, target: any, ...sources: any[]) => any): IKendoJQueryStatic {\n        const $ = this.$;\n        const self = this;\n\n        // Create the kendoJQuery function\n        const kendoJQuery: any = function(selector: any, context?: any) {\n            return new kendoJQuery.fn.init(selector, context);\n        };\n\n        // Copy all jQuery static properties/methods (without deprecated warnings)\n        noDeprecateExtend(true, kendoJQuery, $);\n\n        // Set up prototype chain - inherit from jQuery\n        // TypeScript doesn't like `new $()` but this is valid jQuery pattern\n        kendoJQuery.fn = kendoJQuery.prototype = new ($ as any)();\n        kendoJQuery.fn.constructor = kendoJQuery;\n\n        // Override init to use kendoJQuery for context\n        kendoJQuery.fn.init = function(selector: any, context?: any) {\n            if (context && context instanceof $ && !(context instanceof kendoJQuery)) {\n                context = kendoJQuery(context);\n            }\n            // $.fn.init exists on jQuery but TypeScript types don't expose it\n            return ($.fn as any).init.call(this, selector, context, self.rootjQuery);\n        };\n\n        kendoJQuery.fn.init.prototype = kendoJQuery.fn;\n\n        // Add Kendo-specific methods\n        $.extend(kendoJQuery.fn, {\n            handler: function(this: IKendoJQuery, handler: object): IKendoJQuery {\n                this.data(\"handler\", handler);\n                return this;\n            },\n\n            autoApplyNS: function(this: IKendoJQuery, ns?: string): IKendoJQuery {\n                this.data(\"kendoNS\", ns || self.utils.guid());\n                return this;\n            },\n\n            on: function(this: IKendoJQuery, ...args: any[]): IKendoJQuery {\n                const that = this;\n                const ns = that.data(\"kendoNS\");\n                const on = self.originalOn;\n\n                // Support for event map signature (single object argument)\n                if (args.length === 1) {\n                    return on.call(that, args[0]) as IKendoJQuery;\n                }\n\n                let context: any = that;\n                const argsCopy = args.slice();\n\n                // Remove trailing undefined arguments\n                if (typeof argsCopy[argsCopy.length - 1] === UNDEFINED) {\n                    argsCopy.pop();\n                }\n\n                const callback = argsCopy[argsCopy.length - 1];\n                const events = self.eventMapService.applyEventMap(argsCopy[0], ns);\n\n                // Setup mouse trap for touch/mouse normalization\n                if (self.support.mouseAndTouchPresent && \n                    events.search(/mouse|click/) > -1 && \n                    this[0] !== document.documentElement) {\n                    \n                    self.mouseEventNormalizer.setupMouseMute();\n\n                    const selector = argsCopy.length === 2 ? null : argsCopy[1];\n                    const bustClick = events.indexOf(\"click\") > -1 && events.indexOf(\"touchend\") > -1;\n\n                    on.call(this,\n                        {\n                            touchstart: (e: JQuery.Event) => self.mouseEventNormalizer.muteMouse(e as any),\n                            touchend: () => self.mouseEventNormalizer.unMuteMouse()\n                        },\n                        selector,\n                        {\n                            bustClick: bustClick\n                        }\n                    );\n                }\n\n                // Handle keydown with widget keyboard navigation\n                if (argsCopy[0].indexOf(\"keydown\") !== -1 && argsCopy[1] && argsCopy[1].options) {\n                    argsCopy[0] = events;\n                    const widget = argsCopy[1] as IKeyboardWidget;\n                    const keyDownCallback = argsCopy[argsCopy.length - 1];\n                    \n                    argsCopy[argsCopy.length - 1] = function(e: IKeyDownEvent) {\n                        if (self.keyDownHandler(e, widget)) {\n                            return keyDownCallback.apply(this, [e]);\n                        }\n                    };\n                    \n                    on.apply(that, argsCopy as any);\n                    return that;\n                }\n\n                // Handle string callback (method name on handler object)\n                if (typeof callback === STRING) {\n                    context = that.data(\"handler\");\n                    const callbackFn = (context as any)[callback];\n\n                    argsCopy[argsCopy.length - 1] = function(e: JQuery.Event) {\n                        callbackFn.call(context, e);\n                    };\n                }\n\n                argsCopy[0] = events;\n                on.apply(that, argsCopy as any);\n\n                return that;\n            },\n\n            kendoDestroy: function(this: IKendoJQuery, ns?: string): IKendoJQuery {\n                ns = ns || this.data(\"kendoNS\");\n\n                if (ns) {\n                    this.off(\".\" + ns);\n                }\n\n                return this;\n            }\n        });\n\n        return kendoJQuery as IKendoJQueryStatic;\n    }\n\n    /**\n     * Get the KendoJQuery constructor function\n     */\n    getConstructor(): IKendoJQueryStatic {\n        return this.kendoJQuery;\n    }\n\n    /**\n     * Create a KendoJQuery wrapper\n     */\n    create(selector: any, context?: any): IKendoJQuery {\n        return this.kendoJQuery(selector, context);\n    }\n\n    /**\n     * Handle keydown events for a widget\n     * Executes all kendoKeydown handlers and checks if event should be prevented\n     */\n    keyDownHandler(e: IKeyDownEvent, widget: IKeyboardWidget): boolean {\n        const events = widget._events.kendoKeydown;\n\n        if (!events) {\n            return true;\n        }\n\n        // Clone the events array to prevent modification during iteration\n        const eventsCopy = events.slice();\n        e.sender = widget;\n        e.preventKendoKeydown = false;\n\n        for (let idx = 0, length = eventsCopy.length; idx < length; idx++) {\n            eventsCopy[idx].call(widget, e);\n        }\n\n        return !e.preventKendoKeydown;\n    }\n}\n","/**\n * Kendo UI Base Class\n *\n * This is the foundational class for the entire Kendo UI inheritance system.\n * It's implemented as an actual ES6 class but also provides the legacy extend()\n * static method for backwards compatibility.\n *\n * Supports both patterns:\n * - ES6: class MyClass extends Class { }\n * - Legacy: var MyClass = Class.extend({ init: function() { } })\n *\n \n *\n * @example\n * // ES6 class inheritance\n * class Animal extends Class {\n *     constructor(name) {\n *         super();\n *         this.name = name;\n *     }\n *     speak() {\n *         console.log(this.name + ' makes a sound.');\n *     }\n * }\n *\n * @example\n * // Legacy extend pattern\n * const Animal = Class.extend({\n *     init: function(name) {\n *         this.name = name;\n *     },\n *     speak: function() {\n *         console.log(this.name + ' makes a sound.');\n *     }\n * });\n *\n * const Dog = Animal.extend({\n *     speak: function() {\n *         console.log(this.name + ' barks.');\n *     }\n * });\n *\n * const dog = new Dog('Rex');\n * dog.speak(); // \"Rex barks.\"\n */\n\nimport type { IClass, ClassConstructor } from \"../models/class\";\nimport { inject } from \"../service-container\";\nimport { KendoJQueryService } from \"../services/kendo-jquery.service\";\n\n/**\n * Base Class for Kendo UI.\n * All Kendo classes inherit from this base class.\n */\nexport class Class implements IClass {\n    /**\n     * Static reference to prototype (jQuery-like pattern used throughout Kendo)\n     */\n    static fn: Class;\n\n    /**\n     * Options object - used by widgets and other classes\n     */\n    options?: Record<string, any>;\n\n    /**\n     * Initialization method - called by legacy extend pattern.\n     */\n    init?(..._args: any[]): void;\n\n    /**\n     * Initialize options by deep extending with the provided options.\n     */\n    _initOptions?(options?: Record<string, any>): void;\n\n    /**\n     * Creates a subclass with the given prototype.\n     * This is the legacy extend pattern used throughout Kendo UI.\n     *\n     * This method:\n     * 1. Creates a new constructor function that extends the current class\n     * 2. Copies all properties from proto to the new prototype\n     * 3. For plain object members, performs deep merge with base class members using $.extend\n     * 4. Sets up the extend method on the subclass for further inheritance\n     *\n     * @param proto - Object containing methods and properties for the subclass\n     * @returns New constructor function for the subclass\n     *\n     * @example\n     * var MyClass = Class.extend({\n     *     init: function(options) {\n     *         this.options = options;\n     *     },\n     *     myMethod: function() {\n     *         return this.options;\n     *     }\n     * });\n     *\n     * var instance = new MyClass({ foo: 'bar' });\n     */\n    static extend<T extends Partial<IClass>>(proto?: T): ClassConstructor<IClass & T> {\n        const that = this;\n\n        // Create a temp base for prototype chain setup (matches original pattern)\n        const base = function (): void { };\n        base.prototype = that.prototype;\n\n        // Create the subclass constructor\n        // If proto has init, use it; otherwise create a constructor that calls parent's init (if any)\n        // Note: Original uses `that.apply(this, arguments)` but ES6 classes can't be called with apply.\n        // Instead, we call the parent's init method directly from the prototype chain.\n        const subclass: any = proto && proto.init ? proto.init : function (this: any, ...args: any[]) {\n            // Call parent's init if it exists (this mimics `that.apply(this, arguments)`)\n            if (that.prototype.init) {\n                that.prototype.init.apply(this, args);\n            }\n        };\n\n        // Set up prototype chain: subclass.prototype inherits from base class prototype\n        const fn = subclass.fn = subclass.prototype = new (base as any)();\n\n        // Copy all members from proto to the new prototype\n        if (proto) {\n            for (const member in proto) {\n                if (proto[member] != null && proto[member].constructor === Object) {\n                    // For plain object members, deep merge with base class member\n                    // Uses jQuery's extend(true, ...) - exactly as original\n                    fn[member] = inject(KendoJQueryService).getConstructor().extend(true, {}, (base.prototype as any)[member], proto[member]);\n                } else {\n                    // For other members (functions, primitives, arrays, etc.), direct assignment\n                    fn[member] = proto[member];\n                }\n            }\n        }\n\n        // Set constructor reference for instanceof checks\n        fn.constructor = subclass;\n\n        // Allow subclass to be further extended\n        subclass.extend = that.extend;\n\n        return subclass as ClassConstructor<IClass & T>;\n    }\n}\n\n// Initialize static fn reference\nClass.fn = Class.prototype;\n\n/**\n * Define init and _initOptions on the prototype as ENUMERABLE properties.\n * \n * ES6 class methods are non-enumerable by default, which breaks the\n * legacy extend() pattern because when we do:\n *   base.prototype = that.prototype;\n *   fn = new base();\n * \n * The inherited methods from the ES6 class prototype don't appear in\n * for...in loops or when the object is logged/inspected. This causes\n * issues when deepExtend copies class instances - the non-enumerable\n * methods are not properly inherited through the prototype chain.\n * \n * By defining these methods directly on the prototype (like the original\n * Kendo Class did), we ensure they're enumerable and properly inherited.\n */\n\n// Base init method - does nothing by default, override in subclasses\nClass.prototype.init = function (this: Class, ..._args: any[]): void {\n    // Base init does nothing - override in subclasses\n};\n\n// Initialize options by deep extending with the provided options\nClass.prototype._initOptions = function (this: Class, options?: Record<string, any>): void {\n    // Use jQuery's extend directly to match original behavior exactly\n    this.options = inject(KendoJQueryService).getConstructor().extend(true, {}, this.options, options);\n};\n\n// Re-export types for convenience\nexport type { IClass, ClassConstructor } from \"../models/class\";\n","/**\n * Kendo UI Observable Class\n *\n * Provides event binding, unbinding, and triggering functionality.\n * This is the foundation for all event-driven components in Kendo UI.\n *\n * Extends Class and supports both ES6 and legacy extend() patterns.\n *\n \n *\n * @example\n * // ES6 class inheritance\n * class MyComponent extends Observable {\n *     doSomething() {\n *         this.trigger(\"change\", { value: 42 });\n *     }\n * }\n *\n * @example\n * // Legacy extend pattern\n * const MyComponent = Observable.extend({\n *     init: function() {\n *         Observable.fn.init.call(this);\n *         this.value = 0;\n *     },\n *     setValue: function(val) {\n *         this.value = val;\n *         this.trigger(\"change\", { value: val });\n *     }\n * });\n *\n * const component = new MyComponent();\n * component.bind(\"change\", function(e) {\n *     console.log(\"Value changed to:\", e.value);\n * });\n * component.setValue(42);\n */\n\nimport { Class } from \"./class\";\nimport type {\n    IObservable,\n    IObservableEvent,\n    IEventMap,\n    IHandlerMap,\n    EventHandler,\n    IWrappedEventHandler\n} from \"../models/observable\";\n\n// Type constants for typeof checks\nconst STRING = \"string\";\nconst FUNCTION = \"function\";\n\n/**\n * preventDefault helper function.\n * Called on event object to prevent default action.\n * Uses regular function to preserve `this` context (the event object).\n */\nfunction preventDefault(this: IObservableEvent): void {\n    this._defaultPrevented = true;\n}\n\n/**\n * isDefaultPrevented helper function.\n * Called on event object to check if default was prevented.\n * Uses regular function to preserve `this` context (the event object).\n */\nfunction isDefaultPrevented(this: IObservableEvent): boolean {\n    return this._defaultPrevented === true;\n}\n\n/**\n * Observable class for event handling.\n * All Kendo UI widgets and data components inherit from this class.\n */\nexport class Observable extends Class implements IObservable {\n    /**\n     * Static reference to prototype (jQuery-like pattern used throughout Kendo)\n     */\n    static fn: Observable;\n\n    /**\n     * Internal storage for event handlers.\n     */\n    _events!: IEventMap;\n\n    /**\n     * Constructor - initializes the Observable's _events storage.\n     */\n    constructor() {\n        super();\n        this._events = {};\n    }\n\n    /**\n     * Initialize the Observable instance.\n     * Sets up the internal _events storage.\n     * Accepts any arguments to allow subclasses to override with different signatures.\n     * \n     * Note: For direct Observable usage, this is called by the constructor.\n     * For subclasses, they should call Observable.fn.init.call(this) in their init.\n     */\n    init(..._args: any[]): void {\n        this._events = {};\n    }\n\n    /**\n     * Binds one or more event handlers to the observable.\n     * \n     * Supports multiple calling patterns:\n     * - bind(\"event\", handler)\n     * - bind([\"event1\", \"event2\"], handler)\n     * - bind({ event1: handler1, event2: handler2 })\n     * - bind(\"event\", handler, true) // one-time binding\n     * \n     * @param eventName - Event name, array of names, or object map\n     * @param handlers - Handler function or map of handlers\n     * @param one - If true, handler is removed after first invocation\n     * @returns this for chaining\n     */\n    bind(\n        eventName: string | string[] | IHandlerMap,\n        handlers?: EventHandler | IHandlerMap,\n        one?: boolean\n    ): this {\n        const that = this;\n        let idx: number | string;\n        let length: number;\n        let original: EventHandler;\n        let handler: EventHandler | IWrappedEventHandler | undefined;\n        const handlersIsFunction = typeof handlers === FUNCTION;\n        let events: IWrappedEventHandler[];\n\n        // Handle object syntax: bind({ change: handler, update: handler })\n        if (handlers === undefined) {\n            const eventMap = eventName as IHandlerMap;\n            for (idx in eventMap) {\n                that.bind(idx, eventMap[idx]);\n            }\n            return that;\n        }\n\n        // Convert single event name to array\n        const eventNames: string[] = typeof eventName === STRING\n            ? [eventName as string]\n            : eventName as string[];\n\n        for (idx = 0, length = eventNames.length; idx < length; idx++) {\n            const currentEventName = eventNames[idx];\n\n            handler = handlersIsFunction\n                ? handlers as EventHandler\n                : (handlers as IHandlerMap)[currentEventName];\n\n            if (handler) {\n                if (one) {\n                    // Wrap handler for one-time binding\n                    // IMPORTANT: Use IIFE to capture currentEventName and handler in closure\n                    original = handler;\n                    handler = (function (evtName: string, originalHandler: EventHandler) {\n                        const wrappedHandler: IWrappedEventHandler = function (this: Observable) {\n                            that.unbind(evtName, wrappedHandler);\n                            originalHandler.apply(that, arguments as any);\n                        };\n                        wrappedHandler.original = originalHandler;\n                        return wrappedHandler;\n                    })(currentEventName, original);\n                }\n                events = that._events[currentEventName] = that._events[currentEventName] || [];\n                events.push(handler as IWrappedEventHandler);\n            }\n        }\n\n        return that;\n    }\n\n    /**\n     * Binds an event handler that will be removed after first invocation.\n     * \n     * @param eventNames - Event name or array of names\n     * @param handlers - Handler function or map of handlers\n     * @returns this for chaining\n     */\n    one(eventNames: string | string[], handlers: EventHandler | IHandlerMap): this {\n        return this.bind(eventNames, handlers, true);\n    }\n\n    /**\n     * Binds an event handler at the beginning of the handler list.\n     * The handler will be invoked before other handlers.\n     * \n     * @param eventName - Event name or array of names\n     * @param handlers - Handler function or map of handlers\n     * @returns this for chaining\n     */\n    first(eventName: string | string[], handlers: EventHandler | IHandlerMap): this {\n        const that = this;\n        let idx: number;\n        const eventNames: string[] = typeof eventName === STRING\n            ? [eventName as string]\n            : eventName as string[];\n        const length = eventNames.length;\n        let handler: EventHandler | undefined;\n        const handlersIsFunction = typeof handlers === FUNCTION;\n        let events: IWrappedEventHandler[];\n\n        for (idx = 0; idx < length; idx++) {\n            const currentEventName = eventNames[idx];\n\n            handler = handlersIsFunction\n                ? handlers as EventHandler\n                : (handlers as IHandlerMap)[currentEventName];\n\n            if (handler) {\n                events = that._events[currentEventName] = that._events[currentEventName] || [];\n                events.unshift(handler as IWrappedEventHandler);\n            }\n        }\n\n        return that;\n    }\n\n    /**\n     * Triggers an event, invoking all bound handlers.\n     * \n     * @param eventName - Name of the event to trigger\n     * @param e - Optional event data object\n     * @returns true if preventDefault() was called, false otherwise\n     */\n    trigger(eventName: string, e?: Partial<IObservableEvent> | Record<string, any>): boolean {\n        const that = this;\n        let events = that._events[eventName];\n        let idx: number;\n        const length = events ? events.length : 0;\n\n        if (events) {\n            // Create or extend event object\n            const eventObj: IObservableEvent = (e || {}) as IObservableEvent;\n\n            eventObj.sender = that;\n            eventObj._defaultPrevented = false;\n            eventObj.preventDefault = preventDefault;\n            eventObj.isDefaultPrevented = isDefaultPrevented;\n\n            // Clone array to allow modifications during iteration\n            // (e.g., unbinding in a handler)\n            events = events.slice();\n\n            for (idx = 0; idx < length; idx++) {\n                events[idx].call(that, eventObj);\n            }\n\n            // Check if preventDefault was called by a handler\n            return (eventObj as { _defaultPrevented: boolean })._defaultPrevented === true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Unbinds event handlers.\n     * \n     * - unbind() - removes all handlers for all events\n     * - unbind(\"event\") - removes all handlers for specific event\n     * - unbind(\"event\", handler) - removes specific handler\n     * \n     * @param eventName - Optional event name\n     * @param handler - Optional specific handler to remove\n     * @returns this for chaining\n     */\n    unbind(eventName?: string, handler?: EventHandler): this {\n        const that = this;\n        const events = eventName ? that._events[eventName] : undefined;\n        let idx: number;\n\n        if (eventName === undefined) {\n            // Unbind all events\n            that._events = {};\n        } else if (events) {\n            if (handler) {\n                // Unbind specific handler (iterate backwards for safe removal)\n                for (idx = events.length - 1; idx >= 0; idx--) {\n                    if (events[idx] === handler || events[idx].original === handler) {\n                        events.splice(idx, 1);\n                    }\n                }\n            } else {\n                // Unbind all handlers for this event\n                that._events[eventName] = [];\n            }\n        }\n\n        return that;\n    }\n}\n\n/**\n * Make Observable methods ENUMERABLE by deleting and reassigning them.\n * \n * ES6 class methods are non-enumerable by default, which breaks legacy patterns\n * like `$.extend({}, observableInstance, ...)` which copies properties using\n * for...in loops. By deleting and reassigning, we create enumerable properties.\n */\nconst proto = Observable.prototype;\nconst methods = ['init', 'bind', 'one', 'first', 'trigger', 'unbind'] as const;\nmethods.forEach(method => {\n    const fn = proto[method];\n    Object.defineProperty(proto, method, {\n        value: fn,\n        writable: true,\n        configurable: true,\n        enumerable: true\n    });\n});\n\n// Set up static fn reference (jQuery-like pattern)\nObservable.fn = Observable.prototype;\n\n// Re-export types for convenience\nexport type {\n    IObservable,\n    IObservableEvent,\n    IEventMap,\n    IHandlerMap,\n    EventHandler,\n    IWrappedEventHandler,\n    ObservableConstructor\n} from \"../models/observable\";\n","import {\n    IDomUtilsService,\n    ElementOffset,\n    HiddenDimensions,\n    ParsedEffects,\n    ShadowDimensions,\n    ScrollResult,\n    VerticalScrollResult,\n    VerticalScrollOptions,\n    ScrollToElementOptions,\n    ProgressOptions,\n    DragToScrollOptions,\n    DragToScrollHandler\n} from \"../models/dom-utils\";\nimport { ISupportService } from \"../models/support\";\nimport { IUtilsService } from \"../models/utils\";\nimport { INamespaceService } from \"../models/namespace\";\n\n// Constants\nconst PERCENT_REGEXP = /%/;\nconst BOX_SHADOW_REGEXP = /(\\d+(?:\\.?)\\d*)px\\s*(\\d+(?:\\.?)\\d*)px\\s*(\\d+(?:\\.?)\\d*)px\\s*(\\d+)?/i;\n\n/**\n * Service providing DOM utility functions\n */\nexport class DomUtilsService implements IDomUtilsService {\n    private animationQueue: Array<() => void> = [];\n    private animationFrameFn: (callback: FrameRequestCallback) => void;\n\n    constructor(\n        private supportService: ISupportService,\n        private $: JQueryStatic,\n        private namespaceService: INamespaceService,\n        private utils: IUtilsService,\n        private kendo?: any // Optional kendo namespace for progress messages\n    ) {\n        // Set up requestAnimationFrame with fallbacks\n        const win = window as any;\n        this.animationFrameFn =\n            win.requestAnimationFrame ||\n            win.webkitRequestAnimationFrame ||\n            win.mozRequestAnimationFrame ||\n            win.oRequestAnimationFrame ||\n            win.msRequestAnimationFrame ||\n            ((callback: FrameRequestCallback) => { setTimeout(callback, 1000 / 60); });\n    }\n\n    isElement(element: any): boolean {\n        return element instanceof Element || element instanceof HTMLDocument;\n    }\n\n    /**\n     * Get outer width of element\n     */\n    outerWidth(element: HTMLElement | JQuery | Window, includeMargin?: boolean, calculateFromHidden?: boolean): number {\n        const $element = this.$(element as any);\n        if (calculateFromHidden) {\n            return this.getHiddenDimensions($element, includeMargin).width;\n        }\n        return $element.outerWidth(includeMargin || false) || 0;\n    }\n\n    /**\n     * Get outer height of element\n     */\n    outerHeight(element: HTMLElement | JQuery | Window, includeMargin?: boolean, calculateFromHidden?: boolean): number {\n        const $element = this.$(element as any);\n        if (calculateFromHidden) {\n            return this.getHiddenDimensions($element, includeMargin).height;\n        }\n        return $element.outerHeight(includeMargin || false) || 0;\n    }\n\n    /**\n     * Get computed styles for an element\n     */\n    getComputedStyles(element: HTMLElement, properties?: string[]): Record<string, string> {\n        const styles: Record<string, string> = {};\n        let computedStyle: any;\n\n        if (document.defaultView && document.defaultView.getComputedStyle) {\n            computedStyle = document.defaultView.getComputedStyle(element, \"\");\n\n            if (properties) {\n                this.$.each(properties, (_idx: number, value: string) => {\n                    styles[value] = computedStyle.getPropertyValue(value);\n                });\n            }\n        } else {\n            // IE fallback\n            computedStyle = (element as any).currentStyle;\n\n            if (properties) {\n                this.$.each(properties, (_idx: number, value: string) => {\n                    styles[value] = computedStyle[this.utils.toCamelCase(value)];\n                });\n            }\n        }\n\n        if (!this.utils.size(styles)) {\n            return computedStyle;\n        }\n\n        return styles;\n    }\n\n    /**\n     * Check if an element is scrollable\n     */\n    isScrollable(element: HTMLElement): boolean {\n        const dataset = element.dataset as any;\n        if (dataset[this.namespaceService.ns + \"scrollable\"] === \"false\") {\n            return false;\n        }\n\n        if (typeof element?.className === \"string\" &&\n            element.className.indexOf(\"k-auto-scrollable\") > -1) {\n            return true;\n        }\n\n        const overflow = this.getComputedStyles(element, [\"overflow\"]).overflow || \"\";\n        return overflow.indexOf(\"auto\") > -1 || overflow.indexOf(\"scroll\") > -1;\n    }\n\n    /**\n     * Get or set scroll left position (RTL-aware)\n     */\n    scrollLeft(element: HTMLElement | JQuery, value?: number): number | void {\n        const webkit = this.supportService.browser.webkit;\n        const mozilla = this.supportService.browser.mozilla;\n        const browserVersion = this.supportService.browser.version;\n\n        // Handle jQuery collection\n        if (element instanceof this.$ && value !== undefined) {\n            (element as JQuery).each((_i: number, e: HTMLElement) => {\n                this.scrollLeft(e, value);\n            });\n            return;\n        }\n\n        const el: HTMLElement = element instanceof this.$ ? (element as JQuery)[0] : element as HTMLElement;\n\n        if (!el) {\n            return;\n        }\n\n        const isRtl = this.supportService.isRtl(element);\n\n        if (value !== undefined) {\n            if (isRtl && webkit && (browserVersion < 85 || this.supportService.browser.safari)) {\n                el.scrollLeft = el.scrollWidth - el.clientWidth - value;\n            } else if (isRtl && (mozilla || webkit) && value > 0) {\n                el.scrollLeft = -value;\n            } else {\n                el.scrollLeft = value;\n            }\n        } else if (isRtl && webkit && (browserVersion < 85 || this.supportService.browser.safari)) {\n            return el.scrollWidth - el.clientWidth - el.scrollLeft;\n        } else {\n            return Math.abs(el.scrollLeft);\n        }\n    }\n\n    /**\n     * Get element offset position\n     */\n    getOffset(element: JQuery, type: string = \"offset\", positioned?: boolean): ElementOffset {\n        const offset = (element as any)[type]();\n\n        // Clone ClientRect object to JS object (jQuery3)\n        const result: ElementOffset = {\n            top: offset.top,\n            right: offset.right,\n            bottom: offset.bottom,\n            left: offset.left\n        };\n\n        // IE10 touch zoom is living in a separate viewport\n        if (this.supportService.browser.msie && (this.supportService.pointers || this.supportService.msPointers) && !positioned) {\n            const sign = this.supportService.isRtl(element) ? 1 : -1;\n\n            result.top -= (window.pageYOffset - (document.documentElement.scrollTop));\n            result.left -= (window.pageXOffset + (sign * document.documentElement.scrollLeft));\n        }\n\n        return result;\n    }\n\n    /**\n     * Get dimensions of a hidden element by temporarily cloning and showing it\n     */\n    getHiddenDimensions(element: JQuery, includeMargin?: boolean): HiddenDimensions {\n        const clone = element.clone();\n        clone.css(\"display\", \"\");\n        clone.css(\"visibility\", \"hidden\");\n        clone.appendTo(this.$(\"body\"));\n\n        const width = clone.outerWidth(includeMargin || false);\n        const height = clone.outerHeight(includeMargin || false);\n\n        clone.remove();\n\n        return {\n            width: width || 0,\n            height: height || 0\n        };\n    }\n\n    /**\n     * Parse effects string into object\n     */\n    parseEffects(input: string | string[]): ParsedEffects {\n        const effects: ParsedEffects = {};\n        const items = typeof input === \"string\" ? input.split(\" \") : input;\n\n        this.$.each(items, function (this: string, idx: number) {\n            effects[idx] = this;\n        });\n\n        return effects;\n    }\n\n    /**\n     * Remove whitespace text nodes from an element\n     */\n    stripWhitespace(element: HTMLElement): void {\n        if (document.createNodeIterator) {\n            const iterator = document.createNodeIterator(\n                element,\n                NodeFilter.SHOW_TEXT,\n                (node: Node) => {\n                    return node.parentNode === element\n                        ? NodeFilter.FILTER_ACCEPT\n                        : NodeFilter.FILTER_REJECT;\n                }\n            );\n\n            while (iterator.nextNode()) {\n                const refNode = (iterator as any).referenceNode;\n                if (refNode && !refNode.textContent?.trim()) {\n                    refNode.parentNode?.removeChild(refNode);\n                }\n            }\n        }\n    }\n\n    /**\n     * Request animation frame wrapper\n     */\n    animationFrame(callback: FrameRequestCallback): void {\n        this.animationFrameFn.call(window, callback);\n    }\n\n    /**\n     * Queue an animation callback\n     */\n    queueAnimation(callback: () => void): void {\n        this.animationQueue.push(callback);\n        if (this.animationQueue.length === 1) {\n            this.runNextAnimation();\n        }\n    }\n\n    /**\n     * Run the next animation in queue\n     */\n    runNextAnimation(): void {\n        this.animationFrame(() => {\n            if (this.animationQueue[0]) {\n                this.animationQueue.shift()!();\n                if (this.animationQueue[0]) {\n                    this.runNextAnimation();\n                }\n            }\n        });\n    }\n\n    /**\n     * Parse query string parameters from URL\n     */\n    parseQueryStringParams(url: string): Record<string, string> {\n        const queryString = url.split(\"?\")[1] || \"\";\n        const params: Record<string, string> = {};\n        const paramParts = queryString.split(/&|=/);\n        const length = paramParts.length;\n\n        for (let idx = 0; idx < length; idx += 2) {\n            if (paramParts[idx] !== \"\") {\n                params[decodeURIComponent(paramParts[idx])] = decodeURIComponent(paramParts[idx + 1]);\n            }\n        }\n\n        return params;\n    }\n\n    /**\n     * Get element under cursor position\n     */\n    elementUnderCursor(e: { x: { client?: number }; y: { client?: number } }): Element | null {\n        if (typeof e.x.client !== \"undefined\") {\n            return document.elementFromPoint(e.x.client!, e.y.client!);\n        }\n        return null;\n    }\n\n    /**\n     * Get wheel delta Y from jQuery event\n     */\n    wheelDeltaY(jQueryEvent: JQuery.MouseEventBase): number | undefined {\n        const e = jQueryEvent.originalEvent as WheelEvent & {\n            wheelDelta?: number;\n            wheelDeltaY?: number;\n            axis?: number;\n            VERTICAL_AXIS?: number;\n        };\n        const deltaY = e.wheelDeltaY;\n        let delta: number | undefined;\n\n        if (e.wheelDelta) {\n            // Webkit and IE\n            if (deltaY === undefined || deltaY) {\n                // IE does not have deltaY, thus always scroll\n                delta = e.wheelDelta;\n            }\n        } else if (e.detail && e.axis === e.VERTICAL_AXIS) {\n            // Firefox and Opera\n            delta = (-e.detail) * 10;\n        }\n\n        return delta;\n    }\n\n    /**\n     * Get box-shadow dimensions from an element\n     */\n    getShadows(element: JQuery): ShadowDimensions {\n        const shadow = element.css(\"box-shadow\");\n        const radius = shadow\n            ? BOX_SHADOW_REGEXP.exec(shadow) || [0, 0, 0, 0, 0]\n            : [0, 0, 0, 0, 0];\n        const blur = Math.max(+radius[3], +(radius[4] || 0));\n\n        return {\n            left: (-radius[1]) + blur,\n            right: (+radius[1]) + blur,\n            bottom: (+radius[2]) + blur\n        };\n    }\n\n    /**\n     * Wrap element with animation container\n     */\n    wrap(\n        element: JQuery,\n        autosize?: boolean,\n        resize?: boolean,\n        shouldCorrectWidth: boolean = true,\n        autowidth?: boolean\n    ): JQuery {\n        let parent = element.parent();\n        const windowOuterWidth = this.outerWidth(window);\n\n        parent.parent().removeClass(\"k-animation-container-sm\");\n\n        if (!parent.hasClass(\"k-child-animation-container\")) {\n            const width = element[0].style.width;\n            const height = element[0].style.height;\n            const percentWidth = PERCENT_REGEXP.test(width);\n            const percentHeight = PERCENT_REGEXP.test(height);\n            const forceDimensions = element.hasClass(\"k-tooltip\") || element.is(\".k-menu-horizontal.k-context-menu\");\n            const calculateFromHidden = element.hasClass(\"k-tooltip\");\n\n            const percentage = percentWidth || percentHeight;\n\n            let computedWidth: string | number = width;\n            let computedHeight: string | number = height;\n\n            if (!percentWidth && (!autosize || (autosize && width) || forceDimensions)) {\n                computedWidth = autosize\n                    ? this.outerWidth(element, false, calculateFromHidden) + 1\n                    : this.outerWidth(element, false, calculateFromHidden);\n            }\n            if (!percentHeight && (!autosize || (autosize && height)) || forceDimensions) {\n                computedHeight = this.outerHeight(element, false, calculateFromHidden);\n            }\n\n            element.wrap(\n                this.$(\"<div/>\")\n                    .addClass(\"k-child-animation-container\")\n                    .css({\n                        width: autowidth ? \"auto\" : computedWidth,\n                        height: computedHeight\n                    })\n            );\n            parent = element.parent();\n\n            parent.wrap(\n                this.$(\"<div/>\")\n                    .addClass(\"k-animation-container\")\n                    .attr(\"role\", \"region\")\n            );\n\n            if (percentage) {\n                element.css({\n                    width: \"100%\",\n                    height: \"100%\"\n                });\n            }\n        } else {\n            this.wrapResize(element, autosize, shouldCorrectWidth);\n        }\n\n        parent = parent.parent();\n\n        if (windowOuterWidth < this.outerWidth(parent)) {\n            parent.addClass(\"k-animation-container-sm\");\n            resize = true;\n        }\n\n        if (resize) {\n            this.wrapResize(element, autosize, shouldCorrectWidth);\n        }\n\n        return parent;\n    }\n\n    /**\n     * Resize wrapped element\n     */\n    wrapResize(element: JQuery, autosize?: boolean, shouldCorrectWidth: boolean = true): void {\n        const parent = element.parent();\n        const wrapper = element.closest(\".k-animation-container\");\n        const calculateFromHidden = element.hasClass(\"k-tooltip\");\n        const visible = element.is(\":visible\");\n        const wrapperStyle = parent[0].style;\n        const elementHeight = element[0].style.height;\n\n        if (wrapper.is(\":hidden\")) {\n            wrapper.css({\n                display: \"\",\n                position: \"\"\n            });\n        }\n\n        const percentage = PERCENT_REGEXP.test(wrapperStyle.width) || PERCENT_REGEXP.test(wrapperStyle.height);\n\n        if (!percentage) {\n            if (!visible) {\n                element.add(parent).show();\n            }\n            if (shouldCorrectWidth) {\n                parent.css(\"width\", \"\"); // Needed to get correct width dimensions\n            }\n            parent.css({\n                width: autosize\n                    ? this.outerWidth(element, false, calculateFromHidden) + 1\n                    : this.outerWidth(element, false, calculateFromHidden),\n            });\n\n            if (elementHeight === \"auto\") {\n                element.css({ height: this.outerHeight(parent) });\n            } else {\n                parent.css({\n                    height: this.outerHeight(element)\n                });\n            }\n\n            if (!visible) {\n                element.hide();\n            }\n        }\n    }\n\n    /**\n     * Scroll element horizontally by a delta\n     */\n    scrollByDelta(element: JQuery, delta: number): ScrollResult {\n        const isRtl = this.supportService.isRtl(element);\n        const srcOffset = isRtl ? -this.scrollLeft(element) : this.scrollLeft(element) as number;\n        const scrollDestination = srcOffset + delta;\n        const scrollWidth = element[0].scrollWidth - element[0].clientWidth;\n\n        const animationProps = { \"scrollLeft\": scrollDestination };\n\n        element.finish().animate(animationProps, \"fast\", \"linear\");\n\n        const maxScroll = isRtl ? -scrollWidth : scrollWidth;\n        const newScrollLeft = isRtl\n            ? Math.max(Math.min(scrollDestination, 0), maxScroll)\n            : Math.min(Math.max(scrollDestination, 0), maxScroll);\n\n        return {\n            atStart: newScrollLeft === 0,\n            atEnd: newScrollLeft === maxScroll\n        };\n    }\n\n    /**\n     * Scroll element vertically by a delta\n     */\n    scrollVerticalByDelta(\n        element: JQuery,\n        delta: number,\n        options: VerticalScrollOptions = {}\n    ): VerticalScrollResult {\n        const { duration = 'fast', easing = 'linear' } = options;\n        const currentScrollTop = element.scrollTop() || 0;\n        const targetScrollTop = currentScrollTop + delta;\n\n        const animationProps = { \"scrollTop\": targetScrollTop };\n\n        element.finish().animate(animationProps, duration as number, easing);\n\n        const maxScroll = element[0].scrollHeight - element[0].clientHeight;\n        const newScrollTop = Math.min(Math.max(targetScrollTop, 0), maxScroll);\n\n        return {\n            atTop: newScrollTop === 0,\n            atBottom: newScrollTop >= maxScroll\n        };\n    }\n\n    /**\n     * Smoothly scroll to a specific element within a container\n     */\n    scrollToElement(\n        container: JQuery,\n        targetElement: JQuery,\n        options: ScrollToElementOptions = {}\n    ): boolean {\n        if (!container.length || !targetElement.length) {\n            return false;\n        }\n\n        const {\n            duration = 0,\n            easing = 'linear',\n            position = 'center',\n            offset = 0,\n            onComplete\n        } = options;\n\n        const containerHeight = container.height() || 0;\n        const containerScrollTop = container.scrollTop() || 0;\n        const containerOffset = container.offset()!;\n        const targetOffset = targetElement.offset()!;\n        const targetHeight = targetElement.outerHeight() || 0;\n\n        const relativeTop = targetOffset.top - containerOffset.top + containerScrollTop;\n\n        let targetScrollTop: number;\n\n        switch (position) {\n            case 'top':\n                targetScrollTop = relativeTop + offset;\n                break;\n            case 'bottom':\n                targetScrollTop = relativeTop - containerHeight + targetHeight + offset;\n                break;\n            case 'center':\n            default:\n                targetScrollTop = relativeTop - (containerHeight / 2) + (targetHeight / 2) + offset;\n                break;\n        }\n\n        const maxScroll = container[0].scrollHeight - container[0].clientHeight;\n        targetScrollTop = Math.min(Math.max(targetScrollTop, 0), maxScroll);\n\n        container.finish().animate({\n            scrollTop: targetScrollTop\n        }, duration, easing, onComplete);\n\n        return true;\n    }\n\n    /**\n     * Add a value to an element's attribute, avoiding duplicates\n     * If the value already exists in the attribute, it won't be added again\n     */\n    addAttribute(element: JQuery, attribute: string, value: string): void {\n        const current = element.attr(attribute) || \"\";\n\n        if (current.indexOf(value) < 0) {\n            element.attr(attribute, (current + \" \" + value).trim());\n        }\n    }\n\n    /**\n     * Remove an attribute from an element\n     */\n    removeAttribute(element: JQuery, attribute: string): void {\n        element.removeAttr(attribute);\n    }\n\n    /**\n     * Toggle an attribute value on an element\n     * For regular attributes: adds if not present, removes if present\n     * For disabled/readonly: adds only when value is truthy\n     */\n    toggleAttribute(element: JQuery, attribute: string, value: string): void {\n        const doesNotHaveAttribute = (element.attr(attribute) || \"\").indexOf(value) < 0;\n        const disabledReadonly = [\"disabled\", \"readonly\"].indexOf(attribute) > -1;\n\n        if (doesNotHaveAttribute && !disabledReadonly) {\n            this.addAttribute(element, attribute, value);\n        } else if (disabledReadonly && value) {\n            this.addAttribute(element, attribute, value);\n        } else {\n            this.removeAttribute(element, attribute);\n        }\n    }\n\n    /**\n     * Bind a callback to the window resize event.\n     * On Android, the callback is delayed by 600ms to handle orientation changes properly.\n     * @param callback - Function to call on resize\n     * @returns The handler function (may be wrapped on Android)\n     */\n    onResize(callback: () => void): () => void {\n        let handler = callback;\n\n        if (this.supportService.mobileOS && this.supportService.mobileOS.android) {\n            handler = function () {\n                setTimeout(callback, 600);\n            };\n        }\n\n        this.$(window).on(this.supportService.resize, handler);\n        return handler;\n    }\n\n    /**\n     * Unbind a resize callback from the window.\n     * @param callback - The handler returned from onResize\n     */\n    unbindResize(callback: () => void): void {\n        this.$(window).off(this.supportService.resize, callback);\n    }\n\n    /**\n     * Get a data attribute value from an element using kendo namespace.\n     * @param element - jQuery element\n     * @param key - Attribute key (without kendo namespace prefix)\n     * @returns The attribute value\n     */\n    attrValue(element: JQuery, key: string): any {\n        return element.data(this.namespaceService.ns + key);\n    }\n\n    /**\n     * Get the kendo data attribute name with namespace prefix.\n     * @param value - The attribute name without prefix\n     * @returns The full attribute name (e.g., \"data-kendo-role\" or \"data-role\")\n     */\n    attr(value: string): string {\n        return \"data-\" + this.namespaceService.ns + value;\n    }\n\n    /**\n     * Get or set element dimensions.\n     * @param element - jQuery element\n     * @param dimensions - Optional dimensions to set\n     * @returns Object with width and height\n     */\n    dimensions(element: JQuery, dimensions?: { width?: number | string; height?: number | string }): { width: number; height: number } {\n        const domElement = element[0] as HTMLElement;\n\n        if (dimensions) {\n            element.css(dimensions);\n        }\n\n        return { width: domElement.offsetWidth, height: domElement.offsetHeight };\n    }\n\n    /**\n     * Check if an event was triggered by an input element\n     * @param e - Event object\n     * @returns True if event target is a form input element\n     */\n    triggeredByInput(e: Event | { target: HTMLElement }): boolean {\n        return (/^(label|input|textarea|select)$/i).test((e.target as HTMLElement).tagName);\n    }\n\n    /**\n     * Apply inline styles from kendo data attributes to elements\n     * @param element - Container element to search within\n     * @param styleProps - Array of CSS property names to apply\n     */\n    applyStylesFromKendoAttributes(element: JQuery, styleProps: string[]): void {\n        const $ = this.$;\n\n        const selector = styleProps.map(styleProp => `[${this.attr(`style-${styleProp}`)}]`).join(\",\");\n        element.find(selector).addBack(selector).each((_: number, currentElement: HTMLElement) => {\n            const $currentElement = $(currentElement);\n            styleProps.forEach((styleProp: string) => {\n                const kendoAttr = this.attr(`style-${styleProp}`);\n                if ($currentElement.attr(kendoAttr)) {\n                    $currentElement.css(styleProp, $currentElement.attr(kendoAttr)!);\n                    $currentElement.removeAttr(kendoAttr);\n                }\n            });\n        });\n    }\n\n    /**\n     * Show or hide a loading mask on a container element\n     * @param container - Container element for the mask\n     * @param toggle - Whether to show (true) or hide (false) the mask\n     * @param options - Optional configuration for the mask\n     */\n    progress(container: JQuery, toggle: boolean, options?: ProgressOptions): void {\n        let mask = container.find(\".k-loading-mask\");\n        const browser = this.supportService.browser;\n\n        const opts = this.$.extend({}, {\n            width: \"100%\",\n            height: \"100%\",\n            top: container.scrollTop(),\n            opacity: false\n        }, options);\n\n        const cssClass = opts.opacity ? \"k-loading-mask k-opaque\" : \"k-loading-mask\";\n\n        if (toggle) {\n            if (!mask.length) {\n                const isRtl = this.supportService.isRtl(container);\n                const leftRight = isRtl ? \"right\" : \"left\";\n                const containerScrollLeft = this.scrollLeft(container) as number;\n                let webkitCorrection = 0;\n                if (browser.webkit && isRtl) {\n                    webkitCorrection = container[0].scrollWidth - (container.width() || 0) - 2 * containerScrollLeft;\n                }\n\n                // Note: The loading text message is set via kendo.ui.progress.messages.loading\n                // which should be accessed from the calling code\n                const loadingText = (this.kendo.ui?.progress?.messages?.loading) || \"Loading...\";\n\n                this.$(`<div class='${cssClass}'><span role='alert' aria-live='polite' class='k-loading-text'>${loadingText}</span><div class='k-loading-image'></div><div class='k-loading-color'></div></div>`)\n                    .width(opts.width!)\n                    .height(opts.height!)\n                    .css(\"top\", opts.top!)\n                    .css(leftRight, Math.abs(containerScrollLeft) + webkitCorrection)\n                    .prependTo(container);\n            }\n        } else if (mask) {\n            mask.remove();\n        }\n    }\n\n    /**\n     * Get the actual target element from an event, handling touch events.\n     * For touch events, uses document.elementFromPoint with touch coordinates.\n     * @param e - Event object (mouse or touch)\n     * @returns The target element\n     */\n    eventTarget(e: Event | JQuery.Event): EventTarget | null {\n        if (!this.supportService.touch) {\n            return (e as Event).target;\n        }\n\n        // Handle touch events - get element at touch point\n        const originalEvent = (e as JQuery.TouchEventBase).originalEvent as TouchEvent | undefined;\n        const touches = originalEvent?.changedTouches || (e as unknown as TouchEvent).changedTouches;\n\n        if (touches && touches.length > 0) {\n            return document.elementFromPoint(touches[0].clientX, touches[0].clientY);\n        }\n\n        return (e as Event).target;\n    }\n\n    /**\n     * Create a drag-to-scroll handler for horizontal scrolling via mouse/touch drag.\n     * Encapsulates the drag state and event handling for scrollable containers.\n     * @param scrollContainer - The element that will be scrolled (or parent for delegation)\n     * @param options - Configuration options including namespace, capture element, and delegate selector\n     * @returns Handler with attach() and destroy() methods\n     */\n    createDragToScrollHandler(scrollContainer: JQuery, options: DragToScrollOptions): DragToScrollHandler {\n        return new DragToScrollHandlerImpl(this.$, scrollContainer, options);\n    }\n}\n\nclass DragToScrollHandlerImpl implements DragToScrollHandler {\n    private static readonly DRAG_THRESHOLD = 5;\n\n    private $: JQueryStatic;\n    private scrollContainer: JQuery;\n    private namespace: string;\n    private captureElement?: JQuery;\n    private delegateSelector?: string;\n\n    private isDragging = false;\n    private hasDragged = false;\n    private dragStartX = 0;\n    private scrollStartLeft = 0;\n    private currentDragTarget: HTMLElement | null = null;\n\n    constructor($: JQueryStatic, scrollContainer: JQuery, options: DragToScrollOptions) {\n        this.$ = $;\n        this.scrollContainer = scrollContainer;\n        this.namespace = options.namespace;\n        this.captureElement = options.captureElement;\n        this.delegateSelector = options.delegateSelector;\n\n        this.onDragStart = this.onDragStart.bind(this);\n        this.onDragMove = this.onDragMove.bind(this);\n        this.onDragEnd = this.onDragEnd.bind(this);\n        this.preventClickOnce = this.preventClickOnce.bind(this);\n    }\n\n    attach(): void {\n        if (!this.captureElement) {\n            return;\n        }\n\n        if (this.delegateSelector) {\n            this.scrollContainer\n                .on(\"mousedown\" + this.namespace, this.delegateSelector, this.onDragStart)\n                .on(\"touchstart\" + this.namespace, this.delegateSelector, this.onDragStart);\n        } else {\n            this.scrollContainer\n                .on(\"mousedown\" + this.namespace, this.onDragStart)\n                .on(\"touchstart\" + this.namespace, this.onDragStart);\n        }\n\n        this.bindCaptureEvents();\n    }\n\n    destroy(): void {\n        this.scrollContainer.off(this.namespace);\n        if (this.captureElement) {\n            this.unbindCaptureEvents();\n        }\n        this.scrollContainer[0].removeEventListener(\"click\", this.preventClickOnce, true);\n    }\n\n    private getClientX(e: any): number {\n        if (e.type.indexOf(\"touch\") !== -1) {\n            const touch = e.originalEvent?.touches?.[0] || e.originalEvent?.changedTouches?.[0];\n            return touch ? touch.clientX : 0;\n        }\n        return e.clientX || e.originalEvent?.clientX || 0;\n    }\n\n    private preventClickOnce(e: MouseEvent): void {\n        e.preventDefault();\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n        this.scrollContainer[0].removeEventListener(\"click\", this.preventClickOnce, true);\n    }\n\n    private onDragStart(e: any): void {\n        const target = this.$(e.currentTarget);\n        if (!target.length) {\n            return;\n        }\n\n        this.isDragging = true;\n        this.hasDragged = false;\n        this.currentDragTarget = target[0];\n        this.dragStartX = this.getClientX(e);\n        this.scrollStartLeft = target[0].scrollLeft;\n\n        target.css(\"cursor\", \"grabbing\");\n        target.css(\"user-select\", \"none\");\n    }\n\n    private onDragMove(e: any): void {\n        if (!this.isDragging || !this.currentDragTarget) {\n            return;\n        }\n\n        const clientX = this.getClientX(e);\n        const deltaX = this.dragStartX - clientX;\n\n        if (!this.hasDragged && Math.abs(deltaX) >= DragToScrollHandlerImpl.DRAG_THRESHOLD) {\n            this.hasDragged = true;\n        }\n\n        if (this.hasDragged) {\n            e.preventDefault();\n            this.currentDragTarget.scrollLeft = this.scrollStartLeft + deltaX;\n        }\n    }\n\n    private onDragEnd(): void {\n        if (!this.isDragging) {\n            return;\n        }\n\n        if (this.currentDragTarget) {\n            const target = this.$(this.currentDragTarget);\n            target.css(\"cursor\", \"\");\n            target.css(\"user-select\", \"\");\n        }\n\n        if (this.hasDragged) {\n            this.scrollContainer[0].addEventListener(\"click\", this.preventClickOnce, true);\n        }\n\n        this.isDragging = false;\n        this.hasDragged = false;\n        this.currentDragTarget = null;\n    }\n\n    private bindCaptureEvents(): void {\n        if (!this.captureElement) {\n            return;\n        }\n\n        // Bind all events to document so dragging continues when cursor leaves component\n        this.$(document)\n            .on(\"mousemove\" + this.namespace, this.onDragMove)\n            .on(\"touchmove\" + this.namespace, this.onDragMove)\n            .on(\"mouseup\" + this.namespace, this.onDragEnd)\n            .on(\"touchend\" + this.namespace, this.onDragEnd);\n    }\n\n    private unbindCaptureEvents(): void {\n        this.$(document).off(this.namespace);\n    }\n}","import { \n    IUtilsService, \n    ThrottledFunction,\n    Cloneable,\n    KendoDataNamespace,\n    KeyboardKeys,\n    DaysOfWeek\n} from \"../models/utils\";\n\n// Constants\nconst OBJECT = \"object\";\nconst UNDEFINED = \"undefined\";\n\n/**\n * Utility service providing general helper functions.\n \n */\nexport class UtilsService implements IUtilsService {\n    /**\n     * Keyboard key codes for handling keyboard events.\n     * Maps common key names to their numeric key codes.\n     */\n    readonly keys: KeyboardKeys = {\n        INSERT: 45,\n        DELETE: 46,\n        BACKSPACE: 8,\n        TAB: 9,\n        ENTER: 13,\n        ESC: 27,\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        DOWN: 40,\n        END: 35,\n        HOME: 36,\n        SPACEBAR: 32,\n        PAGEUP: 33,\n        PAGEDOWN: 34,\n        F2: 113,\n        F10: 121,\n        F12: 123,\n        SHIFT: 16,\n        NUMPAD_PLUS: 107,\n        NUMPAD_MINUS: 109,\n        NUMPAD_DOT: 110\n    };\n\n    /**\n     * Days of the week mapping.\n     * Sunday = 0, Saturday = 6 (matches JavaScript Date.getDay())\n     */\n    readonly days: DaysOfWeek = {\n        Sunday: 0,\n        Monday: 1,\n        Tuesday: 2,\n        Wednesday: 3,\n        Thursday: 4,\n        Friday: 5,\n        Saturday: 6\n    };\n\n    constructor(\n        private kendo: { data: KendoDataNamespace }\n    ) {\n        // kendo.data is accessed at call time, not construction time,\n        // because data types (ObservableArray, DataSource, etc.) are\n        // defined later in kendo.data.js\n    }\n\n    /**\n     * Get kendo.data namespace (accessed at call time for lazy loading)\n     */\n    private get kendoData(): KendoDataNamespace {\n        return this.kendo.data || {};\n    }\n\n    /**\n     * Convert camelCase to hyphen-case\n     */\n    toHyphens(str: string): string {\n        return str.replace(/([a-z][A-Z])/g, (g) => {\n            return g.charAt(0) + \"-\" + g.charAt(1).toLowerCase();\n        });\n    }\n\n    /**\n     * Convert hyphen-case to camelCase\n     */\n    toCamelCase(str: string): string {\n        return str.replace(/\\-(\\w)/g, (_strMatch, g1) => {\n            return g1.toUpperCase();\n        });\n    }\n\n    /**\n     * Count properties in an object (excluding toJSON for IE7 compat)\n     */\n    size(obj: object): number {\n        let result = 0;\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key) && key !== \"toJSON\") {\n                result++;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Deep extend an object with one or more source objects.\n     * \n     * IMPORTANT BEHAVIOR NOTES:\n     * - Does NOT copy properties with undefined values (matches jQuery.extend behavior)\n     * - Handles Date objects by creating new Date instances\n     * - Handles objects with clone() method by calling clone()\n     * - Skips Kendo special types: ObservableArray, LazyObservableArray, DataSource, HierarchicalDataSource\n     * - Skips Array, RegExp, ArrayBuffer, and HTMLElement instances\n     * - Protects against prototype pollution (__proto__, constructor, prototype)\n     */\n    deepExtend<T extends object>(destination: T, ...sources: object[]): T {\n        for (let i = 0; i < sources.length; i++) {\n            this.deepExtendOne(destination, sources[i]);\n        }\n        return destination;\n    }\n\n    /**\n     * Deep extend destination with a single source object.\n     * This is the core implementation that handles all the special cases.\n     */\n    deepExtendOne<T extends object>(destination: T, source: object): T {\n        const ObservableArray = this.kendoData.ObservableArray;\n        const LazyObservableArray = this.kendoData.LazyObservableArray;\n        const DataSource = this.kendoData.DataSource;\n        const HierarchicalDataSource = this.kendoData.HierarchicalDataSource;\n\n        for (const property in source) {\n            // Protect against prototype pollution\n            if (property === \"__proto__\" || property === \"constructor\" || property === \"prototype\") {\n                continue;\n            }\n\n            const propValue = (source as any)[property];\n            const propType = typeof propValue;\n            let propInit: (new (...args: any[]) => any) | null = null;\n\n            if (propType === OBJECT && propValue !== null) {\n                propInit = propValue.constructor;\n            }\n\n            let isRegExp = propInit?.name === 'RegExp';\n            let isArrayBuffer = propInit?.name === 'ArrayBuffer';\n            let isDate = propInit?.name === 'Date';\n\n            if (propInit &&\n                !Array.isArray(propValue) && \n                propInit !== ObservableArray && \n                propInit !== LazyObservableArray &&\n                propInit !== DataSource && \n                propInit !== HierarchicalDataSource && \n                !isRegExp &&\n                (!this.isFunction((window as any).ArrayBuffer) || !isArrayBuffer) && \n                !(propValue instanceof HTMLElement)) {\n\n                if (isDate) {\n                    // Clone Date objects\n                    (destination as any)[property] = new Date(propValue.getTime());\n                } else if (this.isCloneable(propValue)) {\n                    // Use clone() method if available\n                    (destination as any)[property] = propValue.clone();\n                } else {\n                    // Recursively extend plain objects\n                    const destProp = (destination as any)[property];\n                    if (typeof destProp === OBJECT) {\n                        (destination as any)[property] = destProp || {};\n                    } else {\n                        (destination as any)[property] = {};\n                    }\n                    this.deepExtendOne((destination as any)[property], propValue);\n                }\n            } else if (propType !== UNDEFINED) {\n                // Only copy if value is not undefined\n                // This is critical - it matches jQuery.extend behavior\n                // and differs from spread operator which copies undefined\n                (destination as any)[property] = propValue;\n            }\n        }\n\n        return destination;\n    }\n\n    /**\n     * Check if an object has a clone method\n     */\n    private isCloneable(obj: any): obj is Cloneable {\n        return typeof obj.clone === \"function\";\n    }\n\n    /**\n     * Create a throttled version of a function.\n     * The throttled function will only execute at most once per delay period.\n     * Includes a cancel() method to clear any pending execution.\n     * \n     * If delay is falsy (0, null, undefined), returns the original function unchanged.\n     */\n    throttle<T extends (...args: any[]) => any>(fn: T, delay: number): ThrottledFunction<T> | T {\n        if (!delay || delay <= 0) {\n            // Return the original function unchanged when delay is falsy\n            return fn;\n        }\n\n        let timeout: ReturnType<typeof setTimeout> | undefined;\n        let lastExecTime = 0;\n\n        const throttled = function(this: any, ...args: Parameters<T>): ReturnType<T> | void {\n            const that = this;\n            const elapsed = +new Date() - lastExecTime;\n\n            function exec(): ReturnType<T> {\n                const result = fn.apply(that, args);\n                lastExecTime = +new Date();\n                return result;\n            }\n\n            // First execution\n            if (!lastExecTime) {\n                return exec();\n            }\n\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n\n            if (elapsed > delay) {\n                return exec();\n            } else {\n                timeout = setTimeout(exec, delay - elapsed);\n            }\n        } as ThrottledFunction<T>;\n\n        throttled.cancel = function(): void {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = undefined;\n            }\n        };\n\n        return throttled;\n    }\n\n    /**\n     * Generate a UUID.\n     * Uses crypto.randomUUID() when available (HTTPS only),\n     * falls back to crypto.getRandomValues().\n     */\n    guid(): string {\n        const cryptoObj = window.crypto;\n        \n        try {\n            // crypto.randomUUID() is available only in secure contexts (HTTPS)\n            return cryptoObj.randomUUID();\n        } catch (e) {\n            // Fallback using crypto.getRandomValues()\n            const randomValues = cryptoObj.getRandomValues(new Uint8Array(16));\n            return randomValues.reduce((acc: string, curr: number, i: number) => {\n                if (i === 4 || i === 6 || i === 8 || i === 10) {\n                    acc += \"-\";\n                }\n                acc += curr.toString(16).padStart(2, \"0\");\n                return acc;\n            }, \"\");\n        }\n    }\n\n    /**\n     * Trim whitespace from a value.\n     * Converts to string first, returns empty string for falsy values.\n     */\n    trim(value: any): string {\n        if (value) {\n            return value.toString().trim();\n        }\n        return \"\";\n    }\n\n    /**\n     * Check if a value is present (not null and not undefined)\n     */\n    isPresent(value: any): boolean {\n        return value !== null && value !== undefined;\n    }\n\n    /**\n     * Check if a value is blank (null or undefined)\n     */\n    isBlank(value: any): boolean {\n        return value === null || value === undefined;\n    }\n\n    /**\n     * Check if a value is empty (has length 0)\n     */\n    isEmpty(value: { length: number }): boolean {\n        return value.length === 0;\n    }\n\n    /**\n     * Check if a value is a string\n     */\n    isString(value: any): value is string {\n        return typeof value === \"string\";\n    }\n\n    /**\n     * Check if a value is an integer\n     */\n    isInteger(value: any): value is number {\n        return Number.isInteger(value);\n    }\n\n    /**\n     * Check if a value is numeric\n     */\n    isNumeric(value: any): boolean {\n        return !isNaN(value - parseFloat(value));\n    }\n\n    /**\n     * Check if a value is a Date object\n     */\n    isDate(value: any): value is Date {\n        return value && value.getTime;\n    }\n\n    /**\n     * Check if a value is a function\n     */\n    isFunction(value: any): value is Function {\n        return typeof value === \"function\";\n    }\n\n    /**\n     * Check if a value is an object (and not null)\n     */\n    isObject(value: any): value is object {\n        return value !== null && typeof value === OBJECT;\n    }\n\n    /**\n     * Log a message to the console.\n     * Respects kendo.suppressLog setting.\n     * @param message - The message to log\n     * @param type - Console method to use (\"log\", \"warn\", \"error\", etc.). Defaults to \"log\"\n     */\n    logToConsole(message: string, type?: string): void {\n        const console = window.console;\n        const kendo = this.kendo as any;\n\n        if (!kendo.suppressLog && typeof console !== \"undefined\" && console.log) {\n            (console as any)[type || \"log\"](message);\n        }\n    }\n\n    /**\n     * Wait for all promises to resolve, similar to Promise.all but for jQuery Deferreds.\n     * Unlike $.when(), this handles failures gracefully and reports all results.\n     * \n     * Influenced from: https://gist.github.com/fearphage/4341799\n     * \n     * @param array - Array of deferreds/promises, or multiple arguments\n     * @returns A jQuery Promise that resolves when all inputs resolve, or rejects if any fail\n     */\n    whenAll<T = any>(array: JQueryPromise<T>[] | JQueryPromise<T>): JQueryPromise<T[]> {\n        const $ = (window as any).jQuery;\n        const resolveValues: any[] = arguments.length === 1 && Array.isArray(array) \n            ? array \n            : Array.prototype.slice.call(arguments);\n        const length = resolveValues.length;\n        let remaining = length;\n        const deferred = $.Deferred();\n        let i = 0;\n        let failed = 0;\n        const rejectContexts: any[] = new Array(length);\n        const rejectValues: any[] = new Array(length);\n        const resolveContexts: any[] = new Array(length);\n        let value: any;\n\n        const updateFunc = (index: number, contexts: any[], values: any[]) => {\n            return function(this: any) {\n                if (values !== resolveValues) {\n                    failed++;\n                }\n\n                deferred.notifyWith(\n                    contexts[index] = this,\n                    values[index] = Array.prototype.slice.call(arguments)\n                );\n\n                if (!(--remaining)) {\n                    deferred[(!failed ? \"resolve\" : \"reject\") + \"With\"](contexts, values);\n                }\n            };\n        };\n\n        for (; i < length; i++) {\n            value = resolveValues[i];\n            if (value && this.isFunction(value.promise)) {\n                value.promise()\n                    .done(updateFunc(i, resolveContexts, resolveValues))\n                    .fail(updateFunc(i, rejectContexts, rejectValues));\n            } else {\n                deferred.notifyWith(this, value);\n                --remaining;\n            }\n        }\n\n        if (!remaining) {\n            deferred.resolveWith(resolveContexts, resolveValues);\n        }\n\n        return deferred.promise();\n    }\n\n    /**\n     * Check if a URL is local (doesn't start with a protocol)\n     * @param url - URL to check\n     * @returns True if the URL is local\n     */\n    isLocalUrl(url: string): boolean {\n        return url && !/^([a-z]+:)?\\/\\//i.test(url);\n    }\n\n    /**\n     * Get all method names (static and instance) from a class\n     * @param targetClass - The class to inspect\n     * @returns Array of method names\n     */\n    getAllMethods(targetClass: new (...args: any[]) => any): string[] {\n        const allStatic = Object.getOwnPropertyNames(targetClass)\n            .filter(prop => typeof (targetClass as any)[prop] === \"function\");\n        const allNonStatic = Object.getOwnPropertyNames(Object.getPrototypeOf(new targetClass({})))\n            .filter(prop => prop !== \"constructor\");\n\n        return allStatic.concat(allNonStatic);\n    }\n\n    /**\n     * Get the base class (parent class) of a given class\n     * @param targetClass - The class to get the parent of\n     * @returns The parent class or null if none\n     */\n    getBaseClass(targetClass: Function): Function | null {\n        if (targetClass instanceof Function) {\n            const baseClass = targetClass;\n            const newBaseClass = Object.getPrototypeOf(baseClass);\n\n            if (newBaseClass && newBaseClass !== Object && newBaseClass.name) {\n                return newBaseClass;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Create a proxy member on a prototype that delegates to an instance\n     * @param proto - The prototype object to add the member to\n     * @param name - The name of the member to create\n     */\n    createProxyMember(proto: { fn: Record<string, Function> }, name: string): void {\n        proto.fn[name] = function(this: { _instance?: Record<string, Function> }) {\n            const instance = this._instance;\n            if (instance) {\n                return instance[name].apply(instance, arguments);\n            }\n        };\n    }\n\n    /**\n     * Convert a native Promise to a jQuery Deferred\n     * @param promise - The native Promise to convert\n     * @returns A jQuery Promise\n     */\n    convertPromiseToDeferred<T = any>(promise: Promise<T>): JQueryPromise<T> {\n        const deferred = $.Deferred<T>();\n\n        (promise.finally as any)(deferred.always).then(deferred.resolve).catch(deferred.reject);\n\n        return deferred.promise();\n    }\n}\n","/**\n * Kendo UI Widget Class\n *\n * Base widget class for all Kendo UI components.\n * Extends Observable to provide event handling and adds:\n * - Element binding and management\n * - Options handling with deep extend\n * - Resize management\n * - CSS class application based on options\n * - ARIA accessibility support\n * - Licensing watermark support\n *\n \n *\n * @example\n * // ES6 class inheritance\n * class MyWidget extends Widget {\n *     init(element, options) {\n *         super.init(element, options);\n *         // widget-specific initialization\n *     }\n * }\n *\n * @example\n * // Legacy extend pattern\n * const MyWidget = Widget.extend({\n *     init: function(element, options) {\n *         Widget.fn.init.call(this, element, options);\n *         // widget-specific initialization\n *     },\n *     options: {\n *         name: \"MyWidget\"\n *     }\n * });\n */\n\nimport { Observable } from \"./observable\";\nimport type {\n    IWidget,\n    IWidgetOptions,\n    IWidgetSize,\n    IComponentTypes\n} from \"../models/widget\";\nimport type { IKendoJQuery } from \"../models/kendo-jquery\";\nimport { inject } from \"../service-container\";\nimport { KendoJQueryService } from \"../services/kendo-jquery.service\";\nimport { DomUtilsService } from \"../services/dom-utils.service\";\nimport { UtilsService } from \"../services/utils.service\";\nimport { CssPropertiesService } from \"../services/css-properties.service\";\nimport * as licensing from \"../../kendo.licensing.js\";\nimport { WidgetPropertyEntry } from \"../models\";\n\n// CSS property names that can be applied to widgets\nconst cssPropertiesNames = [\"themeColor\", \"fillMode\", \"shape\", \"size\", \"rounded\", \"positionMode\"];\n\n// ARIA constants\nconst ARIA_LABELLEDBY = \"aria-labelledby\";\nconst ARIA_LABEL = \"aria-label\";\nconst LABELIDPART = \"_label\";\n\n/**\n * Base Widget class for Kendo UI components.\n */\nexport class Widget<TOptions extends IWidgetOptions = IWidgetOptions> extends Observable implements IWidget<TOptions> {\n    /**\n     * Static reference to prototype (jQuery-like pattern used throughout Kendo)\n     */\n    static fn: Widget;\n\n    /**\n     * Static call method to support legacy pattern: Widget.call(this, element, options)\n     * \n     * ES6 classes cannot be invoked with Function.prototype.call(), but some legacy\n     * code uses `kendo.ui.Widget.call(this, element, options)` instead of the proper\n     * `Widget.fn.init.call(this, element, options)` pattern.\n     * \n     * By defining a static `call` method, we intercept these calls and route them\n     * to the init method, maintaining backward compatibility.\n     * \n     * @param thisArg - The context (this) to call init on\n     * @param element - The DOM element to bind the widget to\n     * @param options - Widget configuration options\n     */\n    static call(thisArg: any, element?: HTMLElement | IKendoJQuery, options?: Partial<IWidgetOptions>): void {\n        Widget.fn.init.call(thisArg, element, options);\n    }\n\n    /**\n     * Static apply method to support legacy pattern: Widget.apply(this, arguments)\n     * \n     * Similar to call(), this intercepts Function.prototype.apply() calls.\n     * \n     * @param thisArg - The context (this) to call init on\n     * @param args - Array of arguments [element, options]\n     */\n    static apply(thisArg: any, args?: [HTMLElement | IKendoJQuery, Partial<IWidgetOptions>?] | IArguments): void {\n        Widget.fn.init.apply(thisArg, args as any);\n    }\n\n    /**\n     * The wrapped element for this widget\n     */\n    element!: IKendoJQuery;\n\n    /**\n     * The wrapper element (may differ from element for some widgets)\n     */\n    wrapper?: IKendoJQuery;\n\n    /**\n     * Widget options - defined on prototype, not instance.\n     * Subclasses override this on their prototype via extend().\n     */\n    declare options: TOptions;\n\n    /**\n     * Default options for the widget\n     */\n    defaults?: Partial<IWidgetOptions>;\n\n    /**\n     * Component type variations\n     */\n    componentTypes?: IComponentTypes;\n\n    /**\n     * Array of event names this widget can trigger.\n     * Defined on prototype, not instance.\n     */\n    declare events: string[];\n\n    /**\n     * Internal size cache\n     */\n    _size?: IWidgetSize;\n\n    /**\n     * Watermark overlay function (set when license validation fails)\n     */\n    _showWatermarkOverlay?: (element: HTMLElement) => void;\n\n    /**\n     * Constructor - receives element and options and calls init().\n     * This mirrors the legacy extend() pattern where the constructor IS the init function.\n     * \n     * @param element - The DOM element to bind the widget to\n     * @param options - Widget configuration options\n     */\n    constructor(element?: HTMLElement | IKendoJQuery, options?: Partial<TOptions>) {\n        super();\n        // Call init with the provided arguments\n        if (element !== undefined) {\n            this.init(element, options);\n        }\n    }\n\n    /**\n     * Initialize the widget\n     * @param element - The DOM element to bind to\n     * @param options - Widget configuration options\n     */\n    init(element: HTMLElement | IKendoJQuery, options?: Partial<TOptions>): void {\n        const that = this;\n\n        // Check licensing\n        if (!licensing.validatePackage()) {\n            that._showWatermarkOverlay = licensing.addWatermarkOverlayAndBanner;\n        }\n\n        // Wrap element with KendoJQuery and bind handler\n        const kendoJQuery = inject(KendoJQueryService).getConstructor();\n        that.element = kendoJQuery(element).handler(that) as IKendoJQuery;\n\n        // Initialize Observable\n        Observable.fn.init.call(that);\n\n        // Handle dataSource special case - avoid deep cloning\n        let dataSource = options ? (options as any).dataSource : null;\n        let props: Partial<IWidgetOptions> | undefined;\n\n        if (options) {\n            props = (that.componentTypes || {})[options.componentType as string];\n        }\n\n        if (dataSource) {\n            // Avoid deep cloning the data source\n            options = kendoJQuery.extend({}, options, { dataSource: {} });\n        }\n\n        options = that.options = kendoJQuery.extend(true, {}, that.options, that.defaults, props || {}, options) as TOptions;\n\n        // Restore dataSource reference\n        if (dataSource) {\n            (options as any).dataSource = dataSource;\n        }\n\n        // Set data-role attribute if not present\n        const roleAttr = inject(DomUtilsService).attr(\"role\");\n        if (!that.element.attr(roleAttr)) {\n            that.element.attr(roleAttr, (options.name || \"\").toLowerCase());\n        }\n\n        // Store widget instance on element\n        that.element.data(\"kendo\" + options.prefix + options.name, that);\n\n        // Bind events from options\n        that.bind(that.events, options);\n    }\n\n    /**\n     * Check if the element has a MVVM binding target\n     * @returns true if the element has a bindingTarget\n     */\n    _hasBindingTarget(): boolean {\n        return !!(this.element[0] as any).kendoBindingTarget;\n    }\n\n    /**\n     * Set up tabindex on target element\n     * @param target - Target element (defaults to wrapper)\n     */\n    _tabindex(target?: IKendoJQuery): void {\n        target = target || this.wrapper;\n\n        const element = this.element;\n        const TABINDEX = \"tabindex\";\n        const tabindex = target!.attr(TABINDEX) || element.attr(TABINDEX);\n\n        element.removeAttr(TABINDEX);\n\n        target!.attr(TABINDEX, !isNaN(tabindex as any) ? tabindex : 0);\n    }\n\n    /**\n     * Update widget options\n     * @param options - New options to merge\n     */\n    setOptions(options: Partial<TOptions>): void {\n        this._clearCssClasses(options);\n        this._setEvents(options);\n        inject(KendoJQueryService).getConstructor().extend(this.options, options);\n        this._applyCssClasses();\n    }\n\n    /**\n     * Internal method to update event bindings when options change\n     * @param options - New options containing event handlers\n     */\n    _setEvents(options: Partial<TOptions>): void {\n        const that = this;\n        let idx = 0;\n        const length = that.events.length;\n        let e: string;\n\n        for (; idx < length; idx++) {\n            e = that.events[idx];\n            if (that.options[e] && options[e]) {\n                that.unbind(e, that.options[e]);\n                if (that._events && that._events[e]) {\n                    delete that._events[e];\n                }\n            }\n        }\n\n        that.bind(that.events, options);\n    }\n\n    /**\n     * Handle resize events\n     * @param force - Force resize even if size hasn't changed\n     */\n    resize(force?: boolean): void {\n        const size = this.getSize();\n        const currentSize = this._size;\n\n        if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\n            this._size = size;\n            this._resize(size, force);\n            this.trigger(\"resize\", size);\n        }\n    }\n\n    /**\n     * Get current widget dimensions\n     * @returns Size object with width and height\n     */\n    getSize(): IWidgetSize {\n        return inject(DomUtilsService).dimensions(this.element as any);\n    }\n\n    /**\n     * Get or set widget size\n     * @param size - Optional size to set\n     * @returns Current size if no argument, undefined if setting\n     */\n    size(size?: IWidgetSize): IWidgetSize | void {\n        if (!size) {\n            return this.getSize();\n        } else {\n            this.setSize(size);\n        }\n    }\n\n    /**\n     * Set widget size (override in subclasses)\n     * @param size - Size to set\n     */\n    setSize(_size: IWidgetSize): void {\n        // noop - override in subclasses\n    }\n\n    /**\n     * Internal resize handler (override in subclasses)\n     * @param size - New size\n     * @param force - Whether resize was forced\n     */\n    _resize(_size: IWidgetSize, _force?: boolean): void {\n        // noop - override in subclasses\n    }\n\n    /**\n     * Destroy the widget and clean up resources\n     */\n    destroy(): void {\n        const that = this;\n\n        that.element.removeData(\"kendo\" + that.options.prefix + that.options.name);\n        that.element.removeData(\"handler\");\n        that.unbind();\n    }\n\n    /**\n     * Internal destroy method\n     */\n    _destroy(): void {\n        this.destroy();\n    }\n\n    /**\n     * Apply CSS classes based on widget options\n     * @param element - Optional element to apply classes to\n     */\n    _applyCssClasses(element?: IKendoJQuery): void {\n        const protoOptions = (this as any).__proto__.options;\n        const options = this.options;\n        const el = element || this.wrapper || this.element;\n        const classes: string[] = [];\n        let i: number;\n        let prop: string;\n        let widgetName: string;\n        let widgetProperties: WidgetPropertyEntry;\n\n        const cssProps = inject(CssPropertiesService);\n\n        widgetName = this.options._altname || protoOptions.name;\n        widgetProperties = cssProps.propertyDictionary[widgetName];\n\n        if (!cssProps || !widgetProperties) {\n            return;\n        }\n\n        for (i = 0; i < cssPropertiesNames.length; i++) {\n            prop = cssPropertiesNames[i];\n            widgetName = this.options._altname || protoOptions.name;\n\n            if ((prop in protoOptions) || (prop in options)) {\n                classes.push(cssProps.getValidClass({\n                    widget: widgetName,\n                    propName: prop,\n                    value: options[prop as keyof TOptions]\n                }));\n            }\n        }\n\n        el.addClass(classes.join(\" \"));\n    }\n\n    /**\n     * Set up ARIA label for accessibility\n     * @param target - Target element to apply ARIA attributes to\n     */\n    _ariaLabel(target: IKendoJQuery): void {\n        const that = this;\n        const inputElm = that.element;\n        const inputId = inputElm.attr(\"id\");\n        const $ = inject(KendoJQueryService).getConstructor();\n        const labelElm = $(\"label[for=\\\"\" + inputId + \"\\\"]\");\n        const ariaLabel = inputElm.attr(ARIA_LABEL);\n        const ariaLabelledBy = inputElm.attr(ARIA_LABELLEDBY);\n        let labelId: string;\n\n        if (target[0] === inputElm[0]) {\n            return;\n        }\n\n        if (ariaLabel) {\n            target.attr(ARIA_LABEL, ariaLabel);\n        } else if (ariaLabelledBy) {\n            target.attr(ARIA_LABELLEDBY, ariaLabelledBy);\n        } else if (labelElm.length) {\n            // Use utils.guid() for generating unique IDs\n            const guid = inject(UtilsService).guid();\n            labelId = labelElm.attr(\"id\") || that._generateLabelId(labelElm, inputId || guid);\n            target.attr(ARIA_LABELLEDBY, labelId);\n        }\n    }\n\n    /**\n     * Clear CSS classes before updating options\n     * @param newOptions - New options being applied\n     * @param element - Optional element to clear classes from\n     */\n    _clearCssClasses(newOptions: Partial<IWidgetOptions>, element?: IKendoJQuery): void {\n        const protoOptions = (this as any).__proto__.options;\n        const currentOptions = this.options;\n        const el = element || this.wrapper || this.element;\n        let i: number;\n        let prop: string;\n        let widgetName: string;\n        let widgetProperties: WidgetPropertyEntry;\n\n        const cssProps = inject(CssPropertiesService);\n\n        widgetName = this.options._altname || protoOptions.name;\n        widgetProperties = cssProps.propertyDictionary[widgetName];\n\n        if (!cssProps || !widgetProperties) {\n            return;\n        }\n\n        for (i = 0; i < cssPropertiesNames.length; i++) {\n            prop = cssPropertiesNames[i];\n\n            if (((prop in protoOptions) || (prop in currentOptions)) && newOptions.hasOwnProperty(prop)) {\n                if (prop === \"themeColor\") {\n                    el.removeClass(cssProps.getValidClass({\n                        widget: widgetName,\n                        propName: prop,\n                        value: currentOptions[prop],\n                        fill: currentOptions.fillMode\n                    }));\n                } else {\n                    if (prop === \"fillMode\") {\n                        el.removeClass(cssProps.getValidClass({\n                            widget: widgetName,\n                            propName: \"themeColor\",\n                            value: currentOptions.themeColor,\n                            fill: currentOptions.fillMode\n                        }));\n                    }\n\n                    el.removeClass(cssProps.getValidClass({\n                        widget: widgetName,\n                        propName: prop,\n                        value: currentOptions[prop]\n                    }));\n                }\n            }\n        }\n    }\n\n    /**\n     * Generate a unique label ID for ARIA\n     * @param label - Label element\n     * @param inputId - Input element ID\n     * @returns Generated label ID\n     */\n    _generateLabelId(label: IKendoJQuery, inputId: string): string {\n        const labelId = inputId + LABELIDPART;\n\n        label.attr(\"id\", labelId);\n\n        return labelId;\n    }\n}\n\n// Set up static fn reference (jQuery-like pattern)\nWidget.fn = Widget.prototype;\n\n// Define options and events on prototype (like original Kendo extend pattern)\n// This is critical for the legacy extend() pattern to work correctly\nWidget.prototype.options = {\n    prefix: \"\"\n};\nWidget.prototype.events = [];\n\n// Re-export types for convenience\nexport type {\n    IWidget,\n    IWidgetOptions,\n    IWidgetSize,\n    IComponentTypes,\n    WidgetConstructor\n} from \"../models/widget\";\n","import { IHtmlService } from \"../models/html\";\n\n// Regex patterns for HTML encoding\nconst ampRegExp = /&/g;\nconst ltRegExp = /</g;\nconst quoteRegExp = /\"/g;\nconst aposRegExp = /'/g;\nconst gtRegExp = />/g;\n\n// Allowed protocols for sanitized links\nconst ALLOWED_PROTOCOLS = [\"http:\", \"https:\"];\n\n/**\n * Service for HTML encoding, decoding, and sanitization\n */\nexport class HtmlService implements IHtmlService {\n    /**\n     * Decode HTML entities to their character equivalents\n     */\n    decode(value: string): string {\n        const entities: { [key: string]: string } = {\n            '&amp;': '&',\n            '&lt;': '<',\n            '&gt;': '>',\n            '&quot;': '\"',\n            '&#39;': \"'\"\n        };\n\n        return value.replace(/&(?:amp|lt|gt|quot|#39);/g, function(match) {\n            return entities[match];\n        });\n    }\n\n    /**\n     * Encode special characters to HTML entities\n     */\n    encode(value: string, shouldDecode?: boolean): string {\n        if (shouldDecode === true) {\n            value = this.decode(value);\n        }\n\n        return (\"\" + value)\n            .replace(ampRegExp, \"&amp;\")\n            .replace(ltRegExp, \"&lt;\")\n            .replace(gtRegExp, \"&gt;\")\n            .replace(quoteRegExp, \"&quot;\")\n            .replace(aposRegExp, \"&#39;\");\n    }\n\n    /**\n     * Sanitize a URL to prevent XSS attacks\n     * Only allows http: and https: protocols\n     */\n    sanitizeLink(value: string): string {\n        let link = \"\";\n\n        try {\n            // Use the default origin in case the value is a relative URL.\n            const url = new URL(value, window.location.origin);\n            if (ALLOWED_PROTOCOLS.includes(url.protocol)) {\n                link = value;\n            } else {\n                throw new Error(\"Invalid protocol\");\n            }\n        } catch {\n            link = \"#INVALIDLINK\";\n        }\n\n        return this.encode(link);\n    }\n\n    /**\n     * Convert text URLs to clickable HTML links\n     */\n    convertTextUrlToLink(text: string, skipSanitization?: boolean): string {\n        const urlRegex = /((https?:\\/\\/[^\\s\"'<>]+)|(www\\.[^\\s\"'<>]+))/gi;\n        const processedText = skipSanitization ? text : this.encode(text);\n\n        return processedText.replace(urlRegex, (match, _p1, _p2, _p3, offset, fullString) => {\n            const lastTagClose = fullString.lastIndexOf('>', offset - 1);\n            const beforeMatch = fullString.substring(lastTagClose + 1, offset);\n\n            if (/\\w+\\s*=\\s*[\"']$/.test(beforeMatch)) {\n                return match;\n            }\n\n            let url = match.trim();\n            const displayText = match.trim();\n\n            if (/^www\\./i.test(url)) {\n                url = 'https://' + url;\n            }\n\n            try {\n                url = new URL(url).href;\n\n                const target = '_blank';\n                const rel = 'noopener noreferrer';\n\n                return `<a href=\"${url}\" target=\"${target}\"${rel ? ` rel=\"${rel}\"` : ''}>${displayText}</a>`;\n            } catch (e) { //NOSONAR - No need to handle/log the error here.\n                // If URL is invalid, return original text\n                return match;\n            }\n        });\n    }\n\n    /**\n     * Unescape URL-encoded strings\n     */\n    unescape(value: string): string {\n        let template: string;\n\n        try {\n            template = window.decodeURIComponent(value);\n        } catch (error) {\n            // If the string contains Unicode characters\n            // the decodeURIComponent() will throw an error.\n            // Therefore: convert to UTF-8 character\n            template = value.replace(/%u([\\dA-F]{4})|%([\\dA-F]{2})/gi, function (_, m1, m2) {\n                return String.fromCharCode(parseInt(\"0x\" + (m1 || m2), 16));\n            });\n        }\n\n        return template;\n    }\n}\n","import { \n    IFileUtilsService, \n    FileGroupMap,\n    SaveAsOptions\n} from \"../models/file-utils\";\nimport { ISupportService } from \"../models/support\";\nimport { IInputService } from \"../models/input\";\n\n/**\n * File Utils Service - provides file-related utilities\n \n */\nexport class FileUtilsService implements IFileUtilsService {\n    private _fileGroupMap: FileGroupMap;\n    private fileSaver: HTMLAnchorElement;\n    private downloadAttribute: boolean;\n\n    constructor(\n        private $: JQueryStatic,\n        private support: ISupportService,\n        private inputService: IInputService\n    ) {\n        this._fileGroupMap = this.createFileGroupMap();\n        this.fileSaver = document.createElement(\"a\");\n        this.downloadAttribute = \"download\" in this.fileSaver && !this.support.browser.edge;\n    }\n\n    /**\n     * Create the default file group mapping\n     */\n    private createFileGroupMap(): FileGroupMap {\n        return {\n            audio: [\".aif\", \".iff\", \".m3u\", \".m4a\", \".mid\", \".mp3\", \".mpa\", \".wav\", \".wma\", \".ogg\", \".wav\", \".wma\", \".wpl\"],\n            video: [\".3g2\", \".3gp\", \".avi\", \".asf\", \".flv\", \".m4u\", \".rm\", \".h264\", \".m4v\", \".mkv\", \".mov\", \".mp4\", \".mpg\",\n                    \".rm\", \".swf\", \".vob\", \".wmv\"],\n            image: [\".ai\", \".dds\", \".heic\", \".jpe\", \"jfif\", \".jif\", \".jp2\", \".jps\", \".eps\", \".bmp\", \".gif\", \".jpeg\",\n                    \".jpg\", \".png\", \".ps\", \".psd\", \".svg\", \".svgz\", \".tif\", \".tiff\"],\n            txt: [\".doc\", \".docx\", \".log\", \".pages\", \".tex\", \".wpd\", \".wps\", \".odt\", \".rtf\", \".text\", \".txt\", \".wks\"],\n            presentation: [\".key\", \".odp\", \".pps\", \".ppt\", \".pptx\"],\n            data: [\".xlr\", \".xls\", \".xlsx\"],\n            programming: [\".tmp\", \".bak\", \".msi\", \".cab\", \".cpl\", \".cur\", \".dll\", \".dmp\", \".drv\", \".icns\", \".ico\", \".link\",\n                          \".sys\", \".cfg\", \".ini\", \".asp\", \".aspx\", \".cer\", \".csr\", \".css\", \".dcr\", \".htm\", \".html\", \".js\",\n                          \".php\", \".rss\", \".xhtml\"],\n            pdf: [\".pdf\"],\n            config: [\".apk\", \".app\", \".bat\", \".cgi\", \".com\", \".exe\", \".gadget\", \".jar\", \".wsf\"],\n            zip: [\".7z\", \".cbr\", \".gz\", \".sitx\", \".arj\", \".deb\", \".pkg\", \".rar\", \".rpm\", \".tar.gz\", \".z\", \".zip\", \".zipx\"],\n            \"disc-image\": [\".dmg\", \".iso\", \".toast\", \".vcd\", \".bin\", \".cue\", \".mdf\"]\n        };\n    }\n\n    /**\n     * Get the file group mapping\n     */\n    get fileGroupMap(): FileGroupMap {\n        return this._fileGroupMap;\n    }\n\n    /**\n     * Get file group/type based on extension\n     */\n    getFileGroup(extension: string | undefined, withPrefix?: boolean): string {\n        const fileTypeMap = this._fileGroupMap;\n        const groups = Object.keys(fileTypeMap);\n        const type = \"file\";\n\n        if (extension === undefined || !extension.length) {\n            return type;\n        }\n\n        let normalizedExt = extension.toLowerCase();\n        if (!normalizedExt.startsWith(\".\")) {\n            normalizedExt = \".\" + normalizedExt;\n        }\n\n        for (let i = 0; i < groups.length; i += 1) {\n            const extensions = fileTypeMap[groups[i]];\n\n            if (extensions.indexOf(normalizedExt) > -1) {\n               return withPrefix ? \"file-\" + groups[i] : groups[i];\n            }\n        }\n\n        return type;\n    }\n\n    /**\n     * Get human-readable file size message\n     */\n    getFileSizeMessage(size: number): string {\n        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n\n        if (size === 0) {\n            return '0 Byte';\n        }\n\n        const i = parseInt(String(Math.floor(Math.log(size) / Math.log(1024))), 10);\n        return Math.round(size / Math.pow(1024, i)) + ' ' + sizes[i];\n    }\n\n    /**\n     * Post data to a proxy URL\n     */\n    private postToProxy(dataURI: string, fileName: string, proxyURL: string, proxyTarget?: string): void {\n        const $ = this.$;\n        const form = $(\"<form>\").attr({\n            action: proxyURL,\n            method: \"POST\",\n            target: proxyTarget\n        });\n\n        const data: Record<string, string> = this.inputService.antiForgeryTokens();\n        data.fileName = fileName;\n\n        const parts = dataURI.split(\";base64,\");\n        data.contentType = parts[0].replace(\"data:\", \"\");\n        data.base64 = parts[1];\n\n        for (const name in data) {\n            if (Object.prototype.hasOwnProperty.call(data, name)) {\n                $('<input>').attr({\n                    value: data[name],\n                    name: name,\n                    type: \"hidden\"\n                }).appendTo(form);\n            }\n        }\n\n        form.appendTo(\"body\").submit().remove();\n    }\n\n    /**\n     * Save using msSaveBlob (IE)\n     */\n    private saveAsBlob(dataURI: string | Blob, fileName: string): void {\n        let blob: Blob = dataURI as Blob; // could be a Blob object\n\n        if (typeof dataURI === \"string\") {\n            const parts = dataURI.split(\";base64,\");\n            const contentType = parts[0];\n            const base64 = atob(parts[1]);\n            const array = new Uint8Array(base64.length);\n\n            for (let idx = 0; idx < base64.length; idx++) {\n                array[idx] = base64.charCodeAt(idx);\n            }\n            blob = new Blob([array.buffer], { type: contentType });\n        }\n\n        (navigator as any).msSaveBlob(blob, fileName);\n    }\n\n    /**\n     * Save using data URI and download attribute\n     */\n    private saveAsDataURI(dataURI: string | Blob, fileName: string): void {\n        let uri: string = dataURI as string;\n\n        if (window.Blob && dataURI instanceof Blob) {\n            uri = URL.createObjectURL(dataURI);\n        }\n\n        this.fileSaver.download = fileName;\n        this.fileSaver.href = uri;\n\n        const e = document.createEvent(\"MouseEvents\");\n        e.initMouseEvent(\"click\", true, false, window,\n            0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\n        this.fileSaver.dispatchEvent(e);\n        setTimeout(function() {\n            URL.revokeObjectURL(uri);\n        });\n    }\n\n    /**\n     * Save data as a file download\n     */\n    saveAs(options: SaveAsOptions): void {\n        type SaveFn = (dataURI: string | Blob, fileName: string, proxyURL?: string, proxyTarget?: string) => void;\n        let save: SaveFn = this.postToProxy.bind(this);\n\n        if (!options.forceProxy) {\n            if (this.downloadAttribute) {\n                save = this.saveAsDataURI.bind(this);\n            } else if ((navigator as any).msSaveBlob) {\n                save = this.saveAsBlob.bind(this);\n            }\n        }\n\n        save(options.dataURI, options.fileName, options.proxyURL, options.proxyTarget);\n    }\n}\n","/**\n * PromptBox component constants\n *\n * This module contains all constants used throughout the PromptBox widget.\n */\n\n/** Namespace for event binding */\nexport const NS = \".kendoPromptBox\";\n\n/** Line mode options */\nexport const LINE_MODE = {\n    SINGLE: \"single\",\n    MULTI: \"multi\",\n    AUTO: \"auto\"\n} as const;\n\n/** Icon identifiers used in the PromptBox component */\nexport const ICONS = {\n    send: \"paper-plane\",\n    stop: \"stop-sm\",\n    attachment: \"paperclip-outline-alt-right\"\n} as const;\n\n/** CSS class names used in the PromptBox component */\nexport const STYLES = {\n    // Core structure (matching kendo-themes)\n    promptBox: \"k-prompt-box\",\n    promptBoxContent: \"k-prompt-box-content\",\n    promptBoxHeader: \"k-prompt-box-header\",\n    promptBoxAffix: \"k-prompt-box-affix\",\n    promptBoxTextarea: \"k-prompt-box-textarea\",\n    promptBoxInput: \"k-prompt-box-input\",\n    promptBoxSingleline: \"k-prompt-box-singleline\",\n    promptBoxMultiline: \"k-prompt-box-multiline\",\n\n    // Input base class\n    input: \"k-input\",\n    inputInner: \"k-input-inner\",\n\n    // State classes\n    disabled: \"k-disabled\",\n    hidden: \"k-hidden\",\n    focus: \"k-focus\",\n    generating: \"k-generating\",\n    active: \"k-active\",\n\n    // Button reference classes (semantic identifiers)\n    speechToTextButton: \"k-speech-to-text-button\",\n    fileSelectButton: \"k-file-select-button\",\n\n    // File attachments (in header)\n    fileBoxWrapper: \"k-file-box-wrapper\",\n    fileBoxWrapperScrollableStart: \"k-file-box-wrapper-scrollable-start\",\n    filesScroll: \"k-files-scroll\",\n    fileBox: \"k-file-box\",\n    fileInfo: \"k-file-info\",\n    fileName: \"k-file-name\",\n    fileSize: \"k-file-size\",\n\n    // Layout\n    spacer: \"k-spacer\"\n} as const;\n\n/** Attribute references for element selection (used as [ref-*] selectors) */\nexport const REFERENCES = {\n    sendButton: \"ref-promptbox-send-button\",\n    fileSelectButton: \"ref-promptbox-file-select-button\",\n    fileInput: \"ref-promptbox-file-input\",\n    attachmentsHost: \"ref-promptbox-attachments-host\",\n    attachmentRemoveButton: \"ref-promptbox-attachment-remove-button\",\n    input: \"ref-promptbox-input\",\n    header: \"ref-promptbox-header\",\n    startAffix: \"ref-promptbox-start-affix\",\n    endAffix: \"ref-promptbox-end-affix\",\n    topAffix: \"ref-promptbox-top-affix\",\n    affixSpacer: \"ref-promptbox-affix-spacer\"\n} as const;\n\n/** Event names triggered by the PromptBox component */\nexport const EVENTS = {\n    valueChange: \"valueChange\",\n    input: \"input\",\n    promptAction: \"promptAction\",\n    fileSelect: \"fileSelect\",\n    fileRemove: \"fileRemove\",\n    speechToTextClick: \"speechToTextClick\",\n    speechToTextStart: \"speechToTextStart\",\n    speechToTextEnd: \"speechToTextEnd\",\n    speechToTextError: \"speechToTextError\",\n    speechToTextResult: \"speechToTextResult\",\n    focus: \"focus\",\n    blur: \"blur\",\n    inputFocus: \"inputFocus\",\n    inputBlur: \"inputBlur\",\n    multilineStateChange: \"multilineStateChange\"\n} as const;\n\n/** Common DOM event names */\nexport const CLICK = \"click\";\nexport const INPUT = \"input\";\nexport const KEYDOWN = \"keydown\";\nexport const FOCUS = \"focus\";\nexport const BLUR = \"blur\";\nexport const CHANGE = \"change\";\nexport const FOCUSIN = \"focusin\";\nexport const FOCUSOUT = \"focusout\";\n\n/** CSS selector prefix */\nexport const DOT = \".\";\n\n// Type exports for const objects\nexport type ModeValue = typeof LINE_MODE[keyof typeof LINE_MODE];\nexport type IconName = typeof ICONS[keyof typeof ICONS];\nexport type StyleClass = typeof STYLES[keyof typeof STYLES];\nexport type ReferenceAttr = typeof REFERENCES[keyof typeof REFERENCES];\nexport type EventName = typeof EVENTS[keyof typeof EVENTS];\n","import \"../../kendo.icons.js\";\nimport \"../../kendo.html.button.js\";\nimport { STYLES, REFERENCES, ICONS } from \"../constants\";\nimport type { IPromptBoxMessages, IActionButtonSettings, IFileSelectButtonSettings, ISpeechToTextButtonSettings } from \"../models\";\nimport type { ModeValue } from \"../constants\";\nimport { LINE_MODE } from \"../constants\";\n\ndeclare const kendo: any;\n\n/**\n * Renders the PromptBox header section.\n * Returns empty string when no headerTemplate (header is created dynamically when needed).\n */\nexport const renderHeader = (\n    headerTemplate: (() => string) | null,\n    forceRender: boolean = false\n): string => {\n    let content = \"\";\n    if (headerTemplate) {\n        content = headerTemplate();\n    }\n\n    if (!content && !forceRender) {\n        return \"\";\n    }\n\n    const hiddenClass = content ? \"\" : ` ${STYLES.hidden}`;\n    return `<div class=\"${STYLES.promptBoxHeader}${hiddenClass}\" ${REFERENCES.header}><div ${REFERENCES.attachmentsHost}></div>${content}</div>`;\n};\n\n/**\n * Renders a template function.\n */\nconst renderTemplate = (template: (() => string) | null | undefined): string => {\n    if (!template) {\n        return \"\";\n    }\n    return template();\n};\n\n/**\n * Renders the send button using kendo.html.renderButton.\n */\nexport const renderSendButton = (\n    messages: IPromptBoxMessages,\n    enable: boolean = true,\n    settings?: IActionButtonSettings\n): string => {\n    const disabledClass = !enable ? ` ${STYLES.disabled}` : \"\";\n    const ariaDisabled = !enable ? ' aria-disabled=\"true\"' : '';\n\n    const buttonOptions: Record<string, any> = {\n        icon: settings?.icon || \"arrow-up-outline\",\n        size: settings?.size || \"small\",\n        rounded: settings?.rounded || \"full\"\n    };\n\n    if (settings?.fillMode) {\n        buttonOptions.fillMode = settings.fillMode;\n    }\n    if (settings?.themeColor) {\n        buttonOptions.themeColor = settings.themeColor;\n    }\n\n    return kendo.html.renderButton(\n        `<button title=\"${messages.actionButton}\" aria-label=\"${messages.actionButton}\" aria-live=\"polite\" class=\"${disabledClass}\"${ariaDisabled} ${REFERENCES.sendButton} type=\"button\"></button>`,\n        buttonOptions\n    );\n};\n\n/**\n * Renders the file select button and hidden file input using kendo.html.renderButton.\n */\nexport const renderFileSelectButton = (\n    fileInputId: string,\n    accept?: string,\n    multiple?: boolean,\n    settings?: IFileSelectButtonSettings,\n    enable: boolean = true,\n    messages?: IPromptBoxMessages\n): string => {\n    const multipleAttr = multiple ? ' multiple' : '';\n    const acceptAttr = accept ? ` accept=\"${accept}\"` : '';\n    const disabledAttr = !enable ? ' disabled' : '';\n    const ariaDisabledAttr = !enable ? ' aria-disabled=\"true\"' : '';\n    const disabledClass = !enable ? ` ${STYLES.disabled}` : '';\n    const buttonTitle = settings?.text || messages?.fileSelectButton || \"Attach file\";\n\n    const buttonOptions: Record<string, any> = {\n        icon: settings?.icon || ICONS.attachment,\n        fillMode: settings?.fillMode || \"clear\"\n    };\n\n    if (settings?.size) {\n        buttonOptions.size = settings.size;\n    }\n    if (settings?.rounded) {\n        buttonOptions.rounded = settings.rounded;\n    }\n    if (settings?.themeColor) {\n        buttonOptions.themeColor = settings.themeColor;\n    }\n\n    const button = kendo.html.renderButton(\n        `<button title=\"${buttonTitle}\" aria-label=\"${buttonTitle}\" class=\"${disabledClass}\" ${REFERENCES.fileSelectButton} type=\"button\"${disabledAttr}${ariaDisabledAttr}></button>`,\n        buttonOptions\n    );\n\n    return `${button}<input type=\"file\" id=\"${fileInputId}\" class=\"${STYLES.hidden}\" ${REFERENCES.fileInput}${multipleAttr}${acceptAttr} />`;\n};\n\n/**\n * Renders the speech-to-text button placeholder.\n * The actual icon is rendered by the SpeechToTextButton component.\n */\nexport const renderSpeechToTextButton = (settings?: ISpeechToTextButtonSettings): string => {\n    return `<button class=\"${STYLES.speechToTextButton}\" type=\"button\"></button>`;\n};\n\n/**\n * Affix configuration for rendering.\n */\nexport interface IAffixConfig {\n    startAffixTemplate?: (() => string) | null;\n    endAffixTemplate?: (() => string) | null;\n    topAffixTemplate?: (() => string) | null;\n}\n\n/**\n * File select button configuration for rendering.\n */\nexport interface IFileSelectButtonConfig {\n    enable?: boolean;\n    fileInputId: string;\n    accept?: string;\n    multiple?: boolean;\n    showSpacer?: boolean;\n    settings?: IFileSelectButtonSettings;\n}\n\n/**\n * Button settings configuration for rendering.\n */\nexport interface IButtonSettingsConfig {\n    actionButtonSettings?: IActionButtonSettings;\n    fileSelectButtonSettings?: IFileSelectButtonSettings;\n    speechToTextButtonSettings?: ISpeechToTextButtonSettings;\n}\n\n/**\n * Combined rendering configuration.\n */\nexport interface IRenderConfig {\n    affixConfig?: IAffixConfig;\n    fileSelectButtonConfig?: IFileSelectButtonConfig;\n    buttonSettingsConfig?: IButtonSettingsConfig;\n}\n\n/**\n * Renders the start affix container (before the input).\n * Uses k-prompt-box-affix class; position is determined by DOM order.\n */\nexport const renderStartAffix = (\n    startAffixTemplate: (() => string) | null | undefined\n): string => {\n    const content = renderTemplate(startAffixTemplate);\n    if (!content) {\n        return \"\";\n    }\n    return `<div class=\"${STYLES.promptBoxAffix}\" ${REFERENCES.startAffix}>${content}</div>`;\n};\n\n/**\n * Renders the end affix container with buttons (after the input).\n * Returns empty string when no content.\n */\nexport const renderEndAffix = (\n    messages: IPromptBoxMessages,\n    showSendButton: boolean,\n    showSpeechToText: boolean = true,\n    endAffixTemplate?: (() => string) | null,\n    fileSelectButtonConfig?: IFileSelectButtonConfig,\n    buttonSettingsConfig?: IButtonSettingsConfig\n): string => {\n    const endAffix = renderTemplate(endAffixTemplate);\n    const fileSelectButtonEnabled = fileSelectButtonConfig?.enable !== false;\n    const fileSelectButton = fileSelectButtonConfig\n        ? renderFileSelectButton(fileSelectButtonConfig.fileInputId, fileSelectButtonConfig.accept, fileSelectButtonConfig.multiple, fileSelectButtonConfig.settings, fileSelectButtonEnabled, messages)\n        : \"\";\n    const spacer = fileSelectButtonConfig?.showSpacer ? `<div class=\"${STYLES.spacer}\"></div>` : \"\";\n    const speechButton = showSpeechToText ? renderSpeechToTextButton(buttonSettingsConfig?.speechToTextButtonSettings) : \"\";\n    const sendButton = showSendButton ? renderSendButton(messages, true, buttonSettingsConfig?.actionButtonSettings) : \"\";\n\n    const content = `${endAffix}${fileSelectButton}${spacer}${speechButton}${sendButton}`.trim();\n    if (!content) {\n        return \"\";\n    }\n\n    return `<div class=\"${STYLES.promptBoxAffix}\" ${REFERENCES.endAffix}>\n        ${endAffix}\n        ${fileSelectButton}\n        ${spacer}\n        ${speechButton}\n        ${sendButton}\n    </div>`;\n};\n\n/**\n * Renders the end affix container with start affix content (for multi mode).\n * In multi mode: fileSelectButton + startAffix content + spacer + endAffix content + buttons\n * The spacer is only rendered if there's content on both sides to separate.\n */\nexport const renderEndAffixWithStartAffix = (\n    messages: IPromptBoxMessages,\n    showSendButton: boolean,\n    showSpeechToText: boolean = true,\n    startAffixTemplate?: (() => string) | null,\n    endAffixTemplate?: (() => string) | null,\n    fileSelectButtonConfig?: IFileSelectButtonConfig,\n    buttonSettingsConfig?: IButtonSettingsConfig\n): string => {\n    const startAffix = renderTemplate(startAffixTemplate);\n    const endAffix = renderTemplate(endAffixTemplate);\n    const fileSelectButtonEnabled = fileSelectButtonConfig?.enable !== false;\n    const fileSelectButton = fileSelectButtonConfig\n        ? renderFileSelectButton(fileSelectButtonConfig.fileInputId, fileSelectButtonConfig.accept, fileSelectButtonConfig.multiple, fileSelectButtonConfig.settings, fileSelectButtonEnabled, messages)\n        : \"\";\n    const speechButton = showSpeechToText ? renderSpeechToTextButton(buttonSettingsConfig?.speechToTextButtonSettings) : \"\";\n    const sendButton = showSendButton ? renderSendButton(messages, true, buttonSettingsConfig?.actionButtonSettings) : \"\";\n\n    const spacer = `<div class=\"${STYLES.spacer}\"></div>`;\n\n    if (!fileSelectButtonConfig?.showSpacer) {\n         return `<div class=\"${STYLES.promptBoxAffix}\" ${REFERENCES.endAffix}>\n            ${startAffix}\n            ${spacer}\n            ${endAffix}\n            ${fileSelectButton}\n            ${speechButton}\n            ${sendButton}\n        </div>`;\n    }\n\n    return `<div class=\"${STYLES.promptBoxAffix}\" ${REFERENCES.endAffix}>\n        ${fileSelectButton}\n        ${startAffix}\n        ${spacer}\n        ${endAffix}\n        ${speechButton}\n        ${sendButton}\n    </div>`;\n};\n\n/**\n * Renders the top affix section (only for multi mode).\n * Note: This is placed at the beginning of content for multi-mode layout.\n */\nexport const renderTopAffix = (\n    topAffixTemplate: (() => string) | null | undefined\n): string => {\n    const content = renderTemplate(topAffixTemplate);\n    if (!content) {\n        return \"\";\n    }\n    return `<div class=\"${STYLES.promptBoxAffix}\" ${REFERENCES.topAffix}>${content}</div>`;\n};\n\n/**\n * Renders the complete PromptBox structure.\n * For multi mode: startAffix content is rendered inside the end affix container with a spacer.\n * For auto mode: startAffix is rendered as a separate container (JS handles reorganization on expand).\n */\nexport const renderPromptBox = (\n    headerTemplate: (() => string) | null,\n    messages: IPromptBoxMessages,\n    showSendButton: boolean,\n    mode: ModeValue,\n    showSpeechToText: boolean = true,\n    renderConfig: IRenderConfig = {}\n): string => {\n    const { affixConfig = {}, fileSelectButtonConfig, buttonSettingsConfig } = renderConfig;\n    const forceRenderHeader = !!fileSelectButtonConfig;\n    const header = renderHeader(headerTemplate, forceRenderHeader);\n    const topAffix = mode === LINE_MODE.MULTI ? renderTopAffix(affixConfig.topAffixTemplate) : \"\";\n\n    const isMultiMode = mode === LINE_MODE.MULTI;\n\n    const startAffix = isMultiMode ? \"\" : renderStartAffix(affixConfig.startAffixTemplate);\n    const endAffix = isMultiMode\n        ? renderEndAffixWithStartAffix(messages, showSendButton, showSpeechToText, affixConfig.startAffixTemplate, affixConfig.endAffixTemplate, fileSelectButtonConfig, buttonSettingsConfig)\n        : renderEndAffix(messages, showSendButton, showSpeechToText, affixConfig.endAffixTemplate, fileSelectButtonConfig, buttonSettingsConfig);\n\n    return `${header}\n        <div class=\"${STYLES.promptBoxContent}\">\n            ${topAffix}\n            ${startAffix}\n            <span ${REFERENCES.input}></span>\n            ${endAffix}\n        </div>`;\n};\n","import type { IPromptBoxOptions } from \"../models\";\nimport type { IKendoJQuery } from \"../../core\";\n\nexport interface IAccessibilityManagerContext {\n    wrapper: IKendoJQuery;\n    getOptions: () => IPromptBoxOptions;\n    getInputElement: () => JQuery | null;\n}\n\nexport class AccessibilityManager {\n    private context: IAccessibilityManagerContext;\n\n    constructor(context: IAccessibilityManagerContext) {\n        this.context = context;\n    }\n\n    applyInitial(): void {\n        const options = this.context.getOptions();\n        const input = this.context.getInputElement();\n        input.attr(\"aria-label\", options.messages?.messageBoxTitle || \"Message\");\n\n        if (!options.enable) {\n            this.context.wrapper.attr(\"aria-disabled\", \"true\");\n        }\n\n        if (options.readonly) {\n            this.updateInputAccessibility();\n        }\n\n        if (options.loading) {\n            this.context.wrapper.attr(\"aria-busy\", \"true\");\n        }\n    }\n\n    updateInputAccessibility(): void {\n        const options = this.context.getOptions();\n        const input = this.context.getInputElement();\n\n        if (!input) {\n            return;\n        }\n\n        input.attr(\"aria-label\", options.messages?.messageBoxTitle || \"Message\");\n\n        if (options.readonly) {\n            input.attr(\"aria-readonly\", \"true\");\n        } else {\n            input.removeAttr(\"aria-readonly\");\n        }\n\n        if (!options.enable) {\n            input.attr(\"aria-disabled\", \"true\");\n        } else {\n            input.removeAttr(\"aria-disabled\");\n        }\n    }\n\n    updateWrapper(state: { disabled?: boolean; loading?: boolean }): void {\n        if (state.disabled !== undefined) {\n            if (state.disabled) {\n                this.context.wrapper.attr(\"aria-disabled\", \"true\");\n            } else {\n                this.context.wrapper.removeAttr(\"aria-disabled\");\n            }\n        }\n\n        if (state.loading !== undefined) {\n            if (state.loading) {\n                this.context.wrapper.attr(\"aria-busy\", \"true\");\n            } else {\n                this.context.wrapper.removeAttr(\"aria-busy\");\n            }\n        }\n    }\n}\n","import { STYLES, REFERENCES } from \"../constants\";\nimport type { IPromptBoxMessages, IActionButtonSettings } from \"../models\";\nimport type { IKendoJQuery } from \"../../core\";\n\ndeclare const kendo: any;\n\nexport interface IActionButtonManagerContext {\n    wrapper: IKendoJQuery;\n    getMessages: () => IPromptBoxMessages;\n    getSettings: () => IActionButtonSettings | undefined;\n    isDisabled: () => boolean;\n    isLoading: () => boolean;\n    hasContent: () => boolean;\n}\n\nexport class ActionButtonManager {\n    private context: IActionButtonManagerContext;\n\n    constructor(context: IActionButtonManagerContext) {\n        this.context = context;\n    }\n\n    private getSendButton(): JQuery {\n        return this.context.wrapper.find(`[${REFERENCES.sendButton}]`);\n    }\n\n    setLoading(loading: boolean): void {\n        const sendButton = this.getSendButton();\n        const messages = this.context.getMessages();\n        const settings = this.context.getSettings();\n\n        if (loading) {\n            sendButton.addClass(`${STYLES.generating} ${STYLES.active}`);\n            sendButton.attr(\"title\", messages.actionButtonLoading);\n            sendButton.attr(\"aria-label\", messages.actionButtonLoading);\n            const icon = sendButton.find(\".k-icon, .k-svg-icon\");\n            if (icon.length) {\n                const loadingIcon = settings?.loadingIcon || \"stop-sm\";\n                kendo.ui.icon(icon, { icon: loadingIcon });\n            }\n        } else {\n            sendButton.removeClass(`${STYLES.generating} ${STYLES.active}`);\n            sendButton.attr(\"title\", messages.actionButton);\n            sendButton.attr(\"aria-label\", messages.actionButton);\n            const icon = sendButton.find(\".k-icon, .k-svg-icon\");\n            if (icon.length) {\n                const sendIcon = settings?.icon || \"arrow-up-outline\";\n                kendo.ui.icon(icon, { icon: sendIcon });\n            }\n        }\n\n        this.updateState();\n    }\n\n    updateState(): void {\n        const sendButton = this.getSendButton();\n        const isDisabled = this.context.isDisabled();\n\n        if (isDisabled) {\n            sendButton.addClass(STYLES.disabled);\n            sendButton.attr(\"aria-disabled\", \"true\");\n            return;\n        }\n\n        sendButton.removeAttr(\"aria-disabled\");\n\n        if (this.context.isLoading()) {\n            sendButton.removeClass(STYLES.disabled);\n            return;\n        }\n\n        if (this.context.hasContent()) {\n            sendButton.removeClass(STYLES.disabled);\n        } else {\n            sendButton.addClass(STYLES.disabled);\n        }\n    }\n\n    updateMessages(): void {\n        const sendButton = this.getSendButton();\n        const messages = this.context.getMessages();\n\n        if (this.context.isLoading()) {\n            sendButton.attr(\"title\", messages.actionButtonLoading);\n            sendButton.attr(\"aria-label\", messages.actionButtonLoading);\n        } else {\n            sendButton.attr(\"title\", messages.actionButton);\n            sendButton.attr(\"aria-label\", messages.actionButton);\n        }\n    }\n}\n","import { DOT, STYLES } from \"../constants\";\nimport type { ISpeechToTextButtonSettings } from \"../models\";\nimport type { IKendoJQuery } from \"../../core\";\n\ndeclare const kendo: any;\n\nexport interface ISpeechHandlerCallbacks {\n    onStart: (e: any) => void;\n    onEnd: (e: any) => void;\n    onResult: (e: any) => void;\n    onError: (e: any) => void;\n}\n\nexport interface ISpeechHandlerContext {\n    wrapper: IKendoJQuery;\n    getSpeechToTextButtonOption: () => boolean | ISpeechToTextButtonSettings | null;\n    callbacks: ISpeechHandlerCallbacks;\n}\n\nexport class SpeechHandler {\n    private context: ISpeechHandlerContext;\n    private instance: any = null;\n\n    constructor(context: ISpeechHandlerContext) {\n        this.context = context;\n    }\n\n    init(): void {\n        const option = this.context.getSpeechToTextButtonOption();\n\n        if (option === false) {\n            return;\n        }\n\n        const speechToTextButton = this.context.wrapper.find(DOT + STYLES.speechToTextButton);\n        if (!speechToTextButton.length) {\n            return;\n        }\n\n        const defaultSettings: ISpeechToTextButtonSettings = {\n            fillMode: \"flat\",\n            size: \"small\",\n            enable: true\n        };\n\n        const userSettings = typeof option === \"object\" && option !== null ? option : {};\n        const isEnabled = (userSettings as ISpeechToTextButtonSettings).enable !== false;\n\n        const buttonOptions = {\n            ...defaultSettings,\n            ...userSettings,\n            start: (e: any) => this.context.callbacks.onStart(e),\n            end: (e: any) => this.context.callbacks.onEnd(e),\n            result: (e: any) => this.context.callbacks.onResult(e),\n            error: (e: any) => this.context.callbacks.onError(e)\n        };\n\n        this.instance = new kendo.ui.SpeechToTextButton(speechToTextButton, buttonOptions);\n\n        if (!isEnabled) {\n            this.instance.enable(false);\n        }\n    }\n\n    enable(enabled: boolean): void {\n        if (this.instance) {\n            this.instance.enable(enabled);\n        }\n    }\n\n    destroy(): void {\n        if (this.instance) {\n            this.instance.destroy();\n            this.instance = null;\n        }\n    }\n}\n","import { STYLES, REFERENCES, NS } from \"../constants\";\nimport type { IPromptBoxOptions, IFileSelectButtonSettings } from \"../models\";\nimport type { HtmlService } from \"../../core/services/html.service\";\nimport type { UtilsService } from \"../../core/services/utils.service\";\nimport type { FileUtilsService } from \"../../core/services/file-utils.service\";\nimport type { DomUtilsService } from \"../../core/services/dom-utils.service\";\nimport type { DragToScrollHandler } from \"../../core/models/dom-utils\";\nimport type { IKendoJQuery } from \"../../core\";\nimport type { IFile } from \"../../upload\";\n\ndeclare const kendo: any;\n\nexport interface IFileHandlerCallbacks {\n    onFilesChanged: () => void;\n    onFileSelect: (files: IFile[]) => void;\n    onFileRemove: (file: IFile, remainingFiles: IFile[]) => void;\n}\n\nexport interface IFileHandlerContext {\n    wrapper: IKendoJQuery;\n    getOptions: () => IPromptBoxOptions;\n    htmlService: HtmlService;\n    fileUtilsService: FileUtilsService;\n    utilsService: UtilsService;\n    domUtilsService: DomUtilsService;\n    callbacks: IFileHandlerCallbacks;\n}\n\nexport class FileHandler {\n    private context: IFileHandlerContext;\n    private files: IFile[] = [];\n    private uploadInstance?: any;\n    private _dragHandler: DragToScrollHandler | null = null;\n\n    constructor(context: IFileHandlerContext) {\n        this.context = context;\n    }\n\n    initUpload(): void {\n        const options = this.context.getOptions();\n        if (!this.showFileSelectButton(options)) {\n            return;\n        }\n\n        const fileInput = this.context.wrapper.find(`[${REFERENCES.fileInput}]`);\n        if (fileInput.length === 0) {\n            return;\n        }\n\n        const settings = this.getFileSelectButtonSettings(options);\n        const multiple = settings?.multiple !== false;\n\n        const upload = new kendo.ui.Upload(fileInput, {\n            multiple: multiple,\n            async: false,\n            uniqueFileUids: true,\n            select: this.onUploadSelect.bind(this)\n        });\n\n        upload?.wrapper?.addClass(STYLES.hidden);\n        this.uploadInstance = upload;\n    }\n\n    getFiles(): IFile[] {\n        return [...this.files];\n    }\n\n    setFiles(newFiles: IFile[]): void {\n        this.files = [...newFiles];\n        this.renderAttachments();\n        this.context.callbacks.onFilesChanged();\n    }\n\n    clearFiles(): void {\n        this.files = [];\n        this.renderAttachments();\n        this.context.callbacks.onFilesChanged();\n    }\n\n    hasFiles(): boolean {\n        return this.files.length > 0;\n    }\n\n    handleFileSelectClick(): void {\n        const options = this.context.getOptions();\n        const settings = this.getFileSelectButtonSettings(options);\n\n        if (!options.enable || options.readonly || settings?.enable === false) {\n            return;\n        }\n\n        const uploadInput = this.uploadInstance?.element?.[0] || null;\n        const fileInput = uploadInput || this.context.wrapper.find(`[${REFERENCES.fileInput}]`)[0];\n\n        if (fileInput && typeof (fileInput as HTMLInputElement).click === \"function\") {\n            (fileInput as HTMLInputElement).click();\n        }\n    }\n\n    removeAttachmentByUid(uid: string): void {\n        const removedFile = this.files.find(file => this.getFileUid(file) === uid);\n        const newFiles = this.files.filter(file => this.getFileUid(file) !== uid);\n\n        if (newFiles.length === this.files.length) {\n            return;\n        }\n\n        this.files = newFiles;\n        this.renderAttachments();\n        this.context.callbacks.onFilesChanged();\n\n        if (removedFile) {\n            this.context.callbacks.onFileRemove(removedFile, [...this.files]);\n        }\n    }\n\n    renderAttachments(): void {\n        this._destroyDragHandler();\n\n        const header = this.context.wrapper.find(`[${REFERENCES.header}]`);\n        const host = this.context.wrapper.find(`[${REFERENCES.attachmentsHost}]`);\n        if (host.length === 0) {\n            return;\n        }\n\n        if (!this.files.length) {\n            host.empty();\n\n            if (!this.context.getOptions().headerTemplate) {\n                header.addClass(STYLES.hidden);\n            }\n            return;\n        }\n\n        header.removeClass(STYLES.hidden);\n\n        let html = `<ul class=\"${STYLES.fileBoxWrapper} ${STYLES.fileBoxWrapperScrollableStart}\">`;\n        html += `<div class=\"${STYLES.filesScroll}\">`;\n\n        for (let i = 0; i < this.files.length; i++) {\n            const fileObj = this.files[i];\n            const rawFile = fileObj?.rawFile || fileObj;\n            const uid = this.getFileUid(fileObj);\n            const name = rawFile?.name || fileObj?.name || \"\";\n            const size = rawFile?.size || fileObj?.size || 0;\n            const extension = name.lastIndexOf(\".\") > -1 ? name.substring(name.lastIndexOf(\".\")).toLowerCase() : \"\";\n            const iconName = this.context.fileUtilsService.getFileGroup(extension, true);\n            const fileSizeMessage = this.context.fileUtilsService.getFileSizeMessage(size);\n            const icon = kendo.ui.icon({ icon: iconName, size: \"xlarge\" });\n            const removeButton = kendo.html.renderButton(\n                `<button type=\"button\" ${REFERENCES.attachmentRemoveButton} data-uid=\"${this.context.htmlService.encode(uid)}\" aria-label=\"Remove attachment\" title=\"Remove attachment\"></button>`,\n                { icon: \"x-mark-sm-outline\", fillMode: \"flat\" }\n            );\n\n            html += `<li class=\"${STYLES.fileBox}\">`;\n            html += icon;\n            html += `<div class=\"${STYLES.fileInfo}\">`;\n            html += `<span class=\"${STYLES.fileName}\">${this.context.htmlService.encode(name)}</span>`;\n            html += `<span class=\"${STYLES.fileSize}\">${this.context.htmlService.encode(fileSizeMessage)}</span>`;\n            html += `</div>`;\n            html += removeButton;\n            html += `</li>`;\n        }\n\n        html += \"</div></ul>\";\n        host.html(html);\n\n        this._attachDragToScroll();\n    }\n\n    private _attachDragToScroll(): void {\n        const host = this.context.wrapper.find(`[${REFERENCES.attachmentsHost}]`);\n        const scrollContainer = host.find(\".\" + STYLES.filesScroll) as IKendoJQuery;\n        if (!scrollContainer.length) {\n            return;\n        }\n\n        this._dragHandler = this.context.domUtilsService.createDragToScrollHandler(\n            scrollContainer,\n            {\n                namespace: NS + \".promptBoxFileDrag\",\n                captureElement: this.context.wrapper\n            }\n        );\n        this._dragHandler.attach();\n    }\n\n    private _destroyDragHandler(): void {\n        if (this._dragHandler) {\n            this._dragHandler.destroy();\n            this._dragHandler = null;\n        }\n    }\n\n    destroy(): void {\n        this._destroyDragHandler();\n        if (this.uploadInstance) {\n            this.uploadInstance.destroy();\n            this.uploadInstance = null;\n        }\n    }\n\n    private onUploadSelect(e: any): void {\n        e.preventDefault();\n        const files = e.files;\n        const options = this.context.getOptions();\n        const settings = this.getFileSelectButtonSettings(options);\n        const validFiles = this.validateFiles(files, settings);\n\n        if (validFiles.length > 0) {\n            this.files = [...this.files, ...validFiles];\n            this.renderAttachments();\n            this.context.callbacks.onFilesChanged();\n            this.context.callbacks.onFileSelect(validFiles);\n        }\n    }\n\n    private validateFiles(files: IFile[], settings?: IFileSelectButtonSettings): IFile[] {\n        const validFiles: IFile[] = [];\n        const restrictions = settings?.restrictions;\n\n        for (let i = 0; i < files.length; i++) {\n            const fileObj = files[i];\n            const file = fileObj.rawFile || fileObj;\n            let isValid = true;\n\n            if (restrictions) {\n                if (restrictions.allowedExtensions && restrictions.allowedExtensions.length > 0) {\n                    const ext = file.name.split('.').pop()?.toLowerCase() || '';\n                    const allowedExts = restrictions.allowedExtensions.map((e: string) => e.toLowerCase().replace('.', ''));\n                    if (!allowedExts.includes(ext)) {\n                        isValid = false;\n                    }\n                }\n\n                if (restrictions.maxFileSize && file.size > restrictions.maxFileSize) {\n                    isValid = false;\n                }\n\n                if (restrictions.minFileSize && file.size < restrictions.minFileSize) {\n                    isValid = false;\n                }\n            }\n\n            if (isValid) {\n                validFiles.push(fileObj);\n            }\n        }\n\n        return validFiles;\n    }\n\n    private getFileUid(file: IFile): string {\n        if (!file) {\n            return \"\";\n        }\n\n        if (!file.uid) {\n            file.uid = this.context.utilsService.guid();\n        }\n\n        return file.uid;\n    }\n\n    private showFileSelectButton(options: IPromptBoxOptions): boolean {\n        return options.fileSelectButton === true ||\n            (typeof options.fileSelectButton === \"object\" && options.fileSelectButton !== null);\n    }\n\n    private getFileSelectButtonSettings(options: IPromptBoxOptions): IFileSelectButtonSettings | undefined {\n        if (typeof options.fileSelectButton === \"object\" && options.fileSelectButton !== null) {\n            return options.fileSelectButton as IFileSelectButtonSettings;\n        }\n        return undefined;\n    }\n}\n","import { STYLES, REFERENCES, NS, INPUT, KEYDOWN, FOCUS, BLUR, LINE_MODE } from \"../constants\";\nimport type { IPromptBoxOptions, IPromptBoxMessages } from \"../models\";\nimport type { IKendoJQuery } from \"../../core\";\n\ndeclare const $: any;\n\nconst DEFAULT_MESSAGES: IPromptBoxMessages = {\n    placeholder: \"Type a message...\",\n    actionButton: \"Send\",\n    actionButtonLoading: \"Stop\",\n    messageBoxTitle: \"Message\"\n};\n\nexport interface IInputManagerCallbacks {\n    onInput: () => void;\n    onKeyDown: (e: any) => void;\n    onFocus: () => void;\n    onBlur: () => void;\n    onMultilineStateChange: (isMultiline: boolean, wasMultiline: boolean) => void;\n}\n\nexport interface IInputManagerContext {\n    wrapper: IKendoJQuery;\n    getOptions: () => IPromptBoxOptions;\n    getMode: () => string;\n    callbacks: IInputManagerCallbacks;\n}\n\nexport class InputManager {\n    private context: IInputManagerContext;\n    private inputInstance: any = null;\n    private singleRowHeight: number = 0;\n    private singleLineWidth: number = 0;\n    private initialHeight: number = 0;\n    private minMultiRowHeight: number = 0;\n    private multiline: boolean = false;\n\n    constructor(context: IInputManagerContext) {\n        this.context = context;\n    }\n\n    init(): void {\n        const inputContainer = this.context.wrapper.find(`[${REFERENCES.input}]`);\n        const mode = this.context.getMode();\n        const inputElement = this.createInputElement(mode);\n        inputContainer.replaceWith(inputElement);\n\n        const value = this.context.getOptions().value || \"\";\n        if (value) {\n            inputElement.val(value);\n        }\n\n        this.captureInitialDimensions();\n        this.attachInputEvents();\n    }\n\n    getElement(): JQuery | null {\n        return this.inputInstance?.element || null;\n    }\n\n    getValue(): string {\n        return this.inputInstance ? this.inputInstance.value() : \"\";\n    }\n\n    setValue(value: string): void {\n        if (this.inputInstance) {\n            this.inputInstance.value(value);\n        }\n        this.updateAutoResize();\n        this.updateMultiResize();\n    }\n\n    enable(enabled: boolean): void {\n        if (this.inputInstance) {\n            this.inputInstance.enable(enabled);\n        }\n    }\n\n    setReadonly(readonly: boolean): void {\n        if (this.inputInstance?.element) {\n            this.inputInstance.element.prop(\"readonly\", readonly);\n        }\n    }\n\n    focus(): void {\n        if (this.inputInstance) {\n            this.inputInstance.focus();\n        }\n    }\n\n    blur(): void {\n        if (this.inputInstance?.element) {\n            this.inputInstance.element.blur();\n        }\n    }\n\n    isMultiline(): boolean {\n        return this.multiline;\n    }\n\n    updateAutoResize(): void {\n        const mode = this.context.getMode();\n\n        if (mode !== LINE_MODE.AUTO || !this.inputInstance) {\n            return;\n        }\n\n        const textarea = this.inputInstance.element;\n        if (!textarea.is(\"textarea\")) {\n            return;\n        }\n\n        const el = textarea[0] as HTMLTextAreaElement;\n\n        if (!this.multiline) {\n            const needsExpansion = el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight;\n\n            if (needsExpansion) {\n                this.updateMultilineState(true);\n                this.updateHeight();\n            }\n        } else {\n            this.updateHeight();\n\n            if (this.shouldCollapse()) {\n                this.updateMultilineState(false);\n                textarea.css(\"height\", \"\");\n            }\n        }\n    }\n\n    updateMultiResize(): void {\n        const mode = this.context.getMode();\n\n        if (mode !== LINE_MODE.MULTI || !this.inputInstance) {\n            return;\n        }\n\n        const textarea = this.inputInstance.element;\n        if (!textarea.is(\"textarea\")) {\n            return;\n        }\n\n        const el = textarea[0];\n        const options = this.context.getOptions();\n\n        textarea.css(\"overflow\", \"hidden\");\n        textarea.css(\"height\", this.initialHeight + \"px\");\n\n        const scrollHeight = el.scrollHeight;\n        const newHeight = this.calculateMultiHeight(scrollHeight, options.maxTextAreaHeight);\n\n        if (newHeight === options.maxTextAreaHeight) {\n            textarea.css(\"overflow\", \"\");\n        }\n\n        textarea.css(\"height\", newHeight + \"px\");\n    }\n\n    updatePlaceholder(): void {\n        const options = this.context.getOptions();\n        const messages = $.extend({}, DEFAULT_MESSAGES, options.messages);\n        const placeholder = options.placeholder || messages.placeholder;\n\n        if (this.inputInstance?.element) {\n            this.inputInstance.element.attr(\"placeholder\", placeholder);\n        }\n    }\n\n    destroy(): void {\n        if (this.inputInstance) {\n            this.inputInstance.element.off(NS);\n            this.inputInstance.destroy();\n            this.inputInstance = null;\n        }\n    }\n\n    private createInputElement(mode: string): JQuery {\n        const options = this.context.getOptions();\n        const messages = $.extend({}, DEFAULT_MESSAGES, options.messages);\n        const title = options.title ? `title=\"${options.title}\"` : \"\";\n        const readonly = options.readonly ? \"readonly\" : \"\";\n\n        let inputElement: JQuery;\n\n        if (mode === LINE_MODE.SINGLE) {\n            inputElement = $(`<input type=\"text\" class=\"${STYLES.promptBoxInput} ${STYLES.inputInner}\" placeholder=\"${options.placeholder || messages.placeholder}\" autocomplete=\"off\" ${title} ${readonly} />`);\n\n            this.inputInstance = {\n                element: inputElement,\n                value: (val?: string) => {\n                    if (val === undefined) {\n                        return inputElement.val() as string;\n                    }\n                    inputElement.val(val);\n                },\n                enable: (enabled: boolean) => {\n                    inputElement.prop(\"disabled\", !enabled);\n                },\n                focus: () => inputElement.trigger(\"focus\"),\n                destroy: () => { }\n            };\n        } else {\n            const rows = mode === LINE_MODE.AUTO ? 1 : (options.rows || 1);\n            inputElement = $(`<textarea class=\"${STYLES.promptBoxTextarea} ${STYLES.inputInner}\" placeholder=\"${options.placeholder || messages.placeholder}\" rows=\"${rows}\" aria-multiline=\"true\" ${title} ${readonly}></textarea>`);\n\n            if (options.maxTextAreaHeight) {\n                inputElement.css(\"max-height\", options.maxTextAreaHeight + \"px\");\n                inputElement.css(\"overflow-y\", \"auto\");\n            }\n\n            this.inputInstance = {\n                element: inputElement,\n                value: (val?: string) => {\n                    if (val === undefined) {\n                        return inputElement.val() as string;\n                    }\n                    inputElement.val(val);\n                },\n                enable: (enabled: boolean) => {\n                    inputElement.prop(\"disabled\", !enabled);\n                },\n                focus: () => inputElement.trigger(\"focus\"),\n                destroy: () => { }\n            };\n        }\n\n        return inputElement;\n    }\n\n    private captureInitialDimensions(): void {\n        const mode = this.context.getMode();\n\n        if (mode === LINE_MODE.SINGLE || !this.inputInstance) {\n            return;\n        }\n\n        const textarea = this.inputInstance.element;\n        if (!textarea.is(\"textarea\")) {\n            return;\n        }\n\n        const el = textarea[0] as HTMLTextAreaElement;\n        const computedStyle = window.getComputedStyle(el);\n        const lineHeight = parseFloat(computedStyle.lineHeight) || 20;\n        const paddingTop = parseFloat(computedStyle.paddingTop) || 0;\n        const paddingBottom = parseFloat(computedStyle.paddingBottom) || 0;\n\n        const options = this.context.getOptions();\n        const rows = options.rows || 1;\n\n        this.singleRowHeight = lineHeight + paddingTop + paddingBottom;\n        this.initialHeight = el.offsetHeight || this.singleRowHeight;\n        this.singleLineWidth = el.offsetWidth;\n        this.minMultiRowHeight = lineHeight * rows + paddingTop + paddingBottom;\n    }\n\n    private shouldCollapse(): boolean {\n        if (!this.inputInstance || this.singleLineWidth <= 0) {\n            return false;\n        }\n\n        const textarea = this.inputInstance.element as JQuery;\n        if (!textarea.is(\"textarea\")) {\n            return false;\n        }\n\n        const el = textarea[0];\n        const currentHeight = el.style.height;\n\n        textarea.css({\n            overflow: \"hidden\",\n            width: this.singleLineWidth + \"px\",\n            whiteSpace: \"nowrap\",\n            height: this.initialHeight + \"px\"\n        });\n\n        const fitsSingleLine =\n            el.scrollWidth <= this.singleLineWidth && el.scrollHeight <= this.initialHeight;\n\n        textarea.css({\n            overflow: \"\",\n            width: \"\",\n            whiteSpace: \"\"\n        });\n\n        if (currentHeight) {\n            textarea.css(\"height\", currentHeight);\n        } else {\n            textarea.css(\"height\", \"\");\n        }\n\n        return fitsSingleLine;\n    }\n\n    private updateHeight(): void {\n        const options = this.context.getOptions();\n\n        if (!this.inputInstance) {\n            return;\n        }\n\n        const textarea = this.inputInstance.element as JQuery;\n        if (!textarea.is(\"textarea\")) {\n            return;\n        }\n\n        const el = textarea[0];\n\n        textarea.css(\"overflow\", \"hidden\");\n        textarea.css(\"height\", this.initialHeight + \"px\");\n\n        const scrollHeight = el.scrollHeight;\n        const newHeight = options.maxTextAreaHeight\n            ? Math.min(scrollHeight, options.maxTextAreaHeight)\n            : scrollHeight;\n\n        if (newHeight === options.maxTextAreaHeight) {\n            textarea.css(\"overflow\", \"\");\n        }\n\n        textarea.css(\"height\", newHeight + \"px\");\n    }\n\n    private calculateMultiHeight(scrollHeight: number, maxTextAreaHeight: number | undefined): number {\n        if (maxTextAreaHeight && scrollHeight > maxTextAreaHeight) {\n            return maxTextAreaHeight;\n        }\n        return Math.max(this.minMultiRowHeight, scrollHeight);\n    }\n\n    private updateMultilineState(isMultiline: boolean): void {\n        const mode = this.context.getMode();\n\n        if (mode !== LINE_MODE.AUTO) {\n            return;\n        }\n\n        if (this.multiline === isMultiline) {\n            return;\n        }\n\n        const wasMultiline = this.multiline;\n        this.multiline = isMultiline;\n\n        if (isMultiline) {\n            this.context.wrapper.addClass(STYLES.promptBoxMultiline);\n        } else {\n            this.context.wrapper.removeClass(STYLES.promptBoxMultiline);\n        }\n\n        this.context.callbacks.onMultilineStateChange(isMultiline, wasMultiline);\n    }\n\n    private attachInputEvents(): void {\n        if (!this.inputInstance) {\n            return;\n        }\n\n        const inputElement = this.inputInstance.element as JQuery;\n\n        inputElement.on(INPUT + NS, () => {\n            this.updateAutoResize();\n            this.updateMultiResize();\n            this.context.callbacks.onInput();\n        });\n\n        inputElement.on(KEYDOWN + NS, (e: any) => {\n            this.context.callbacks.onKeyDown(e);\n        });\n\n        inputElement.on(FOCUS + NS, () => {\n            this.context.callbacks.onFocus();\n        });\n\n        inputElement.on(BLUR + NS, () => {\n            this.context.callbacks.onBlur();\n        });\n    }\n}\n","import \"../kendo.html.button.js\";\nimport \"../kendo.icons.js\";\nimport \"../kendo.speechtotextbutton.js\";\nimport \"../kendo.textarea.js\";\nimport \"../kendo.textbox.js\";\nimport \"../kendo.upload.js\";\nimport { Widget } from \"../core/base/widget\";\nimport { inject } from \"../core/service-container\";\nimport { HtmlService } from \"../core/services/html.service\";\nimport { UtilsService } from \"../core/services/utils.service\";\nimport { FileUtilsService } from \"../core/services/file-utils.service\";\nimport { DomUtilsService } from \"../core/services/dom-utils.service\";\nimport { NS, STYLES, REFERENCES, EVENTS, LINE_MODE, CLICK, FOCUSIN, FOCUSOUT } from \"./constants\";\nimport { renderPromptBox, IAffixConfig, IFileSelectButtonConfig, IButtonSettingsConfig, IRenderConfig } from \"./templates\";\nimport { IKendoJQueryStatic, IKendoJQuery } from \"../core\";\nimport { AccessibilityManager, ActionButtonManager, SpeechHandler, FileHandler, InputManager } from \"./collaborators\";\nimport type { IPromptBoxOptions, IPromptBoxMessages, IActionButtonEvent, IFileSelectButtonSettings } from \"./models\";\nimport type { IFile } from \"../upload\";\n\ndeclare const kendo: any;\ndeclare const $: IKendoJQueryStatic;\n\nconst DEFAULT_MESSAGES: IPromptBoxMessages = {\n    placeholder: \"Type a message...\",\n    actionButton: \"Send\",\n    actionButtonLoading: \"Stop\",\n    messageBoxTitle: \"Message\",\n    fileSelectButton: \"Attach file\"\n};\n\n/**\n * PromptBox widget - A composite input component for chat-like interfaces.\n *\n * Supports three modes:\n * - \"single\": Single-line text input\n * - \"multi\": Multi-line textarea with fixed rows\n * - \"auto\": Auto-expanding textarea (starts from 1 row)\n */\nexport class PromptBox extends Widget {\n    static readonly options = {\n        name: \"PromptBox\",\n        prefix: \"\",\n        mode: LINE_MODE.AUTO,\n        placeholder: \"\",\n        value: \"\",\n        enable: true,\n        readonly: false,\n        title: \"\",\n        fillMode: undefined,\n        maxTextAreaHeight: undefined,\n        rows: 1,\n        headerTemplate: null,\n        loading: false,\n        actionButton: null,\n        fileSelectButton: false,\n        speechToTextButton: true,\n        startAffixTemplate: null,\n        endAffixTemplate: null,\n        topAffixTemplate: null,\n        messages: DEFAULT_MESSAGES\n    };\n\n    events: string[] = [\n        EVENTS.valueChange,\n        EVENTS.input,\n        EVENTS.promptAction,\n        EVENTS.fileSelect,\n        EVENTS.fileRemove,\n        EVENTS.speechToTextClick,\n        EVENTS.speechToTextStart,\n        EVENTS.speechToTextEnd,\n        EVENTS.speechToTextError,\n        EVENTS.speechToTextResult,\n        EVENTS.focus,\n        EVENTS.blur,\n        EVENTS.inputFocus,\n        EVENTS.inputBlur,\n        EVENTS.multilineStateChange\n    ];\n\n    private _value: string = \"\";\n    private _loading: boolean = false;\n    private _readonly: boolean = false;\n    private _hasFocus: boolean = false;\n    private _fileInputId: string = \"\";\n\n    private utilsService: UtilsService;\n    private htmlService: HtmlService;\n    private fileUtilsService: FileUtilsService;\n    private domUtilsService: DomUtilsService;\n    private accessibilityManager!: AccessibilityManager;\n    private actionButtonManager!: ActionButtonManager;\n    private speechHandler!: SpeechHandler;\n    private fileHandler!: FileHandler;\n    private inputManager!: InputManager;\n\n    /**\n     * Constructs a new PromptBox instance.\n     */\n    constructor(\n        element: HTMLElement | IKendoJQuery,\n        options?: Partial<IPromptBoxOptions>,\n        utilsService = inject(UtilsService),\n        htmlService = inject(HtmlService),\n        fileUtilsService = inject(FileUtilsService),\n        domUtilsService = inject(DomUtilsService)\n    ) {\n        super(element as any, $.extend(true, {}, PromptBox.options, options));\n\n        this.utilsService = utilsService;\n        this.htmlService = htmlService;\n        this.fileUtilsService = fileUtilsService;\n        this.domUtilsService = domUtilsService;\n\n        this._value = (this.options as IPromptBoxOptions).value || \"\";\n        this._loading = (this.options as IPromptBoxOptions).loading || false;\n        this._fileInputId = \"promptbox_file_\" + this.utilsService.guid();\n\n        this._initWrapper();\n        this._initInputManager();\n        this._initSpeechHandler();\n        this._initFileHandler();\n        this._attachEvents();\n        this.fileHandler.renderAttachments();\n        this._initAccessibilityManager();\n        this._initActionButtonManager();\n\n        this.bind(this.events, this.options);\n\n        if (!(this.options as IPromptBoxOptions).enable) {\n            this.enable(false);\n        }\n\n        if ((this.options as IPromptBoxOptions).readonly) {\n            this.readonly(true);\n        }\n\n        if (this._value && this._getMode() === LINE_MODE.AUTO) {\n            this.inputManager.updateAutoResize();\n        }\n\n        this.actionButtonManager.updateState();\n    }\n\n    /**\n     * Gets or sets the input value.\n     */\n    value(newValue?: string): string | void {\n        if (newValue === undefined) {\n            return this._value;\n        }\n\n        this._value = newValue;\n        this.inputManager.setValue(newValue);\n        this.actionButtonManager.updateState();\n    }\n\n    /**\n     * Enables or disables the PromptBox.\n     * When enabling, this also clears the readonly state (similar to TextBox behavior).\n     */\n    enable(enabled: boolean = true): void {\n        const options = this.options as IPromptBoxOptions;\n        options.enable = enabled;\n\n        if (enabled) {\n            this._readonly = false;\n            options.readonly = false;\n            this.inputManager.setReadonly(false);\n            this.wrapper.removeClass(STYLES.disabled);\n        } else {\n            this.wrapper.addClass(STYLES.disabled);\n        }\n\n        this.inputManager.enable(enabled);\n        this.speechHandler.enable(enabled);\n        this._updateFileSelectButtonState();\n        this.actionButtonManager.updateState();\n\n        this.accessibilityManager.updateWrapper({ disabled: !enabled });\n        this.accessibilityManager.updateInputAccessibility();\n    }\n\n    /**\n     * Gets or sets the read-only state of the PromptBox.\n     */\n    readonly(value?: boolean): boolean | void {\n        if (value === undefined) {\n            return this._readonly;\n        }\n\n        this._readonly = value;\n        const options = this.options as IPromptBoxOptions;\n        options.readonly = value;\n        this.inputManager.setReadonly(value);\n\n        this.accessibilityManager.updateInputAccessibility();\n\n        this.actionButtonManager.updateState();\n        this.speechHandler.enable(!value);\n        this._updateFileSelectButtonState();\n    }\n\n    /**\n     * Gets or sets the loading state (shows stop button instead of send).\n     */\n    loading(value?: boolean): boolean | void {\n        if (value === undefined) {\n            return this._loading;\n        }\n\n        this._loading = value;\n\n        this.accessibilityManager.updateWrapper({ loading: value });\n        this.actionButtonManager.setLoading(value);\n    }\n\n    /**\n     * Focuses the input element.\n     */\n    focus(): void {\n        this.inputManager.focus();\n    }\n\n    /**\n     * Blurs the input element.\n     */\n    blur(): void {\n        this.inputManager.blur();\n    }\n\n    /**\n     * Gets or sets the attached files.\n     * @param newFiles - Optional array of files to set. If not provided, returns current files.\n     * @returns Array of attached files when getting, void when setting.\n     */\n    files(newFiles?: IFile[]): IFile[] | void {\n        if (newFiles === undefined) {\n            return this.fileHandler.getFiles();\n        }\n\n        this.fileHandler.setFiles(newFiles);\n    }\n\n    /**\n     * Clears all attached files.\n     */\n    clearFiles(): void {\n        this.fileHandler.clearFiles();\n    }\n\n    /**\n     * Destroys the widget.\n     */\n    destroy(): void {\n        this._detachEvents();\n        this._destroyCollaborators();\n        super.destroy();\n    }\n\n    private _destroyCollaborators(): void {\n        this.fileHandler.destroy();\n        this.speechHandler.destroy();\n        this.inputManager.destroy();\n    }\n\n    /**\n     * Updates widget options dynamically.\n     * For complex changes (templates, buttons, mode), the widget is rebuilt.\n     */\n    setOptions(options: Partial<IPromptBoxOptions>): void {\n        const requiresRebuild = options.headerTemplate !== undefined ||\n            options.startAffixTemplate !== undefined ||\n            options.endAffixTemplate !== undefined ||\n            options.topAffixTemplate !== undefined ||\n            options.actionButton !== undefined ||\n            options.actionButtonSettings !== undefined ||\n            options.fileSelectButton !== undefined ||\n            options.speechToTextButton !== undefined ||\n            options.mode !== undefined;\n\n        if (requiresRebuild) {\n            const currentValue = this._value;\n            const wasLoading = this._loading;\n            const attachments = (this.options as IPromptBoxOptions).attachments;\n            const currentFiles = this.fileHandler.getFiles();\n\n            this._detachEvents();\n            this._destroyCollaborators();\n\n            super.setOptions(options as any);\n\n            // Remove old wrapper completely (element was moved outside wrapper in _initWrapper)\n            this.wrapper.remove();\n\n            this._initWrapper();\n            this._initInputManager();\n            this._initSpeechHandler();\n            this._initFileHandler();\n            this._attachEvents();\n\n            // Restore files that were attached before the rebuild\n            if (currentFiles.length > 0) {\n                this.fileHandler.setFiles(currentFiles);\n            }\n\n            this._initAccessibilityManager();\n            this._initActionButtonManager();\n\n            if (currentValue) {\n                this.value(currentValue);\n            }\n            if (wasLoading) {\n                this.loading(true);\n            }\n            if (attachments) {\n                (this.options as IPromptBoxOptions).attachments = attachments;\n                this.fileHandler.renderAttachments();\n            }\n            return;\n        }\n\n        super.setOptions(options as any);\n\n        if (options.placeholder !== undefined || options.messages?.placeholder !== undefined) {\n            this.inputManager.updatePlaceholder();\n        }\n\n        if (options.messages?.actionButton !== undefined || options.messages?.actionButtonLoading !== undefined) {\n            this.actionButtonManager.updateMessages();\n        }\n\n        if (options.enable !== undefined) {\n            this.enable(options.enable);\n        }\n\n        if (options.readonly !== undefined) {\n            this.readonly(options.readonly);\n        }\n\n        if (options.loading !== undefined) {\n            this.loading(options.loading);\n        }\n    }\n\n    private _initInputManager(): void {\n        this.inputManager = new InputManager({\n            wrapper: this.wrapper,\n            getOptions: () => this.options as IPromptBoxOptions,\n            getMode: () => this._getMode(),\n            callbacks: {\n                onInput: () => this._handleInput(),\n                onKeyDown: (e) => this._handleKeyDown(e),\n                onFocus: () => this.trigger(EVENTS.inputFocus),\n                onBlur: () => this.trigger(EVENTS.inputBlur),\n                onMultilineStateChange: (isMultiline, wasMultiline) => {\n                    this._handleAffixReorganization(isMultiline);\n                    this.trigger(EVENTS.multilineStateChange, { isMultiline, wasMultiline });\n                }\n            }\n        });\n        this.inputManager.init();\n    }\n\n    /**\n     * Reorganizes affixes when auto mode switches between single-line and multiline.\n     * In multiline: startAffix content moves to endAffix (left side) with a spacer.\n     * In single-line: startAffix content returns to its original container.\n     */\n    private _handleAffixReorganization(isMultiline: boolean): void {\n        const options = this.options as IPromptBoxOptions;\n        if (!options.startAffixTemplate) {\n            return;\n        }\n\n        const startAffix = this.wrapper.find(`[${REFERENCES.startAffix}]`);\n        const endAffix = this.wrapper.find(`[${REFERENCES.endAffix}]`);\n\n        if (!startAffix.length || !endAffix.length) {\n            return;\n        }\n\n        if (isMultiline) {\n            const startAffixContent = startAffix.contents().detach();\n            startAffix.addClass(STYLES.hidden);\n\n            const spacer = $(`<div class=\"${STYLES.spacer}\" ${REFERENCES.affixSpacer}></div>`);\n\n            endAffix.prepend(spacer);\n            endAffix.prepend(startAffixContent);\n        } else {\n            const spacer = endAffix.find(`[${REFERENCES.affixSpacer}]`);\n            if (spacer.length) {\n                const startAffixContent = spacer.prevAll().detach();\n\n                startAffix.empty().append(startAffixContent);\n                startAffix.removeClass(STYLES.hidden);\n\n                spacer.remove();\n            }\n        }\n    }\n\n    private _initSpeechHandler(): void {\n        this.speechHandler = new SpeechHandler({\n            wrapper: this.wrapper,\n            getSpeechToTextButtonOption: () => (this.options as IPromptBoxOptions).speechToTextButton,\n            callbacks: {\n                onStart: (e) => this.trigger(EVENTS.speechToTextStart, e),\n                onEnd: (e) => this.trigger(EVENTS.speechToTextEnd, e),\n                onResult: (e) => {\n                    const transcript = e.alternatives?.[0]?.transcript || \"\";\n                    if (transcript) {\n                        const currentValue = this._value || \"\";\n                        const newValue = currentValue + (currentValue ? \" \" : \"\") + transcript;\n                        this.value(newValue);\n                    }\n                    this.trigger(EVENTS.speechToTextResult, { ...e, transcript });\n                },\n                onError: (e) => this.trigger(EVENTS.speechToTextError, e)\n            }\n        });\n        this.speechHandler.init();\n    }\n\n    private _initFileHandler(): void {\n        this.fileHandler = new FileHandler({\n            wrapper: this.wrapper,\n            getOptions: () => this.options as IPromptBoxOptions,\n            htmlService: this.htmlService,\n            fileUtilsService: this.fileUtilsService,\n            utilsService: this.utilsService,\n            domUtilsService: this.domUtilsService,\n            callbacks: {\n                onFilesChanged: () => this.actionButtonManager.updateState(),\n                onFileSelect: (files) => this.trigger(EVENTS.fileSelect, { files }),\n                onFileRemove: (file, remainingFiles) => this.trigger(EVENTS.fileRemove, { file, files: remainingFiles })\n            }\n        });\n        this.fileHandler.initUpload();\n    }\n\n    private _initAccessibilityManager(): void {\n        this.accessibilityManager = new AccessibilityManager({\n            wrapper: this.wrapper,\n            getOptions: () => this.options as IPromptBoxOptions,\n            getInputElement: () => this.inputManager.getElement()\n        });\n        this.accessibilityManager.applyInitial();\n    }\n\n    private _initActionButtonManager(): void {\n        this.actionButtonManager = new ActionButtonManager({\n            wrapper: this.wrapper,\n            getMessages: () => this._getMessages(),\n            getSettings: () => (this.options as IPromptBoxOptions).actionButton,\n            isDisabled: () => {\n                const options = this.options as IPromptBoxOptions;\n                const widgetDisabled = !options.enable;\n                const widgetReadonly = options.readonly;\n                const actionButtonDisabled = options.actionButton?.enable === false;\n                return widgetDisabled || widgetReadonly || actionButtonDisabled;\n            },\n            isLoading: () => this._loading,\n            hasContent: () => !!this._value?.trim() || this.fileHandler.hasFiles()\n        });\n    }\n\n    /**\n     * Gets the input mode (single, multi, or auto).\n     */\n    private _getMode(): string {\n        const options = this.options as IPromptBoxOptions;\n        return options.mode || LINE_MODE.AUTO;\n    }\n\n    /**\n     * Gets the merged messages, including overrides from button settings.\n     */\n    private _getMessages(): IPromptBoxMessages {\n        const options = this.options as IPromptBoxOptions;\n        const actionButtonSettings = options.actionButton;\n        const fileSelectButtonSettings = typeof options.fileSelectButton === \"object\" ? options.fileSelectButton as IFileSelectButtonSettings : null;\n        const baseMessages = $.extend({}, DEFAULT_MESSAGES, options.messages);\n        if (actionButtonSettings?.text) {\n            baseMessages.actionButton = actionButtonSettings.text;\n        }\n        if (actionButtonSettings?.loadingText) {\n            baseMessages.actionButtonLoading = actionButtonSettings.loadingText;\n        }\n        if (fileSelectButtonSettings?.text) {\n            baseMessages.fileSelectButton = fileSelectButtonSettings.text;\n        }\n        return baseMessages;\n    }\n\n    /**\n     * Gets whether the action button should be shown. Always returns true.\n     */\n    private _showActionButton(): boolean {\n        return true;\n    }\n\n    /**\n     * Gets whether the speech-to-text button should be shown.\n     */\n    private _showSpeechToTextButton(): boolean {\n        const options = this.options as IPromptBoxOptions;\n        return options.speechToTextButton === true ||\n            options.speechToTextButton === null ||\n            options.speechToTextButton === undefined ||\n            (typeof options.speechToTextButton === \"object\" && options.speechToTextButton !== null);\n    }\n\n    /**\n     * Gets whether the file select button should be shown.\n     */\n    private _showFileSelectButton(): boolean {\n        const options = this.options as IPromptBoxOptions;\n        return options.fileSelectButton === true ||\n            (typeof options.fileSelectButton === \"object\" && options.fileSelectButton !== null);\n    }\n\n    /**\n     * Updates the file select button state based on enable/readonly options.\n     */\n    private _updateFileSelectButtonState(): void {\n        const options = this.options as IPromptBoxOptions;\n        const fileSelectButton = this.wrapper.find(`[${REFERENCES.fileSelectButton}]`);\n\n        if (!fileSelectButton.length) {\n            return;\n        }\n\n        const fileSelectSettings = this._getFileSelectButtonSettings();\n        const isDisabled = !options.enable || options.readonly || fileSelectSettings?.enable === false;\n\n        if (isDisabled) {\n            fileSelectButton.addClass(STYLES.disabled);\n            fileSelectButton.attr(\"aria-disabled\", \"true\");\n        } else {\n            fileSelectButton.removeClass(STYLES.disabled);\n            fileSelectButton.removeAttr(\"aria-disabled\");\n        }\n    }\n\n    /**\n     * Gets the file select button settings.\n     */\n    private _getFileSelectButtonSettings(): IFileSelectButtonSettings | undefined {\n        const options = this.options as IPromptBoxOptions;\n        if (typeof options.fileSelectButton === \"object\" && options.fileSelectButton !== null) {\n            return options.fileSelectButton as IFileSelectButtonSettings;\n        }\n        return undefined;\n    }\n\n    /**\n     * Creates the wrapper element using wrap instead of replaceWith.\n     * This keeps the original element in the DOM so jQuery data binding works.\n     */\n    private _initWrapper(): void {\n        const options = this.options as IPromptBoxOptions;\n        const messages = this._getMessages();\n        const mode = this._getMode();\n\n        let modeClass = \"\";\n        if (mode === LINE_MODE.SINGLE) {\n            modeClass = ` ${STYLES.promptBoxSingleline}`;\n        } else if (mode === LINE_MODE.MULTI) {\n            modeClass = ` ${STYLES.promptBoxMultiline}`;\n        }\n\n        const stylingClasses = this._getAppearanceClasses();\n\n        const affixConfig: IAffixConfig = {\n            startAffixTemplate: options.startAffixTemplate,\n            endAffixTemplate: options.endAffixTemplate,\n            topAffixTemplate: options.topAffixTemplate\n        };\n\n        const fileSelectButtonConfig = this._getFileSelectButtonConfig();\n        const buttonSettingsConfig = this._getButtonSettingsConfig();\n\n        const renderConfig: IRenderConfig = {\n            affixConfig,\n            fileSelectButtonConfig,\n            buttonSettingsConfig\n        };\n\n        const wrapperContent = renderPromptBox(\n            options.headerTemplate,\n            messages,\n            this._showActionButton(),\n            mode as any,\n            this._showSpeechToTextButton(),\n            renderConfig\n        );\n\n        this.wrapper = this.element.wrap(`<div class=\"${STYLES.input}${stylingClasses} ${STYLES.promptBox}${modeClass}\" role=\"group\"></div>`).parent() as IKendoJQuery;\n        this.wrapper.prepend(wrapperContent);\n        this.element.addClass(STYLES.hidden);\n        this.wrapper.after(this.element);\n    }\n\n    /**\n     * Gets appearance CSS classes for fillMode.\n     * PromptBox only supports fillMode at the root level per kendo-themes spec.\n     */\n    private _getAppearanceClasses(): string {\n        const options = this.options as IPromptBoxOptions;\n\n        if (options.fillMode) {\n            return ` k-input-${options.fillMode}`;\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Gets the file select button configuration for template rendering.\n     */\n    private _getFileSelectButtonConfig(): IFileSelectButtonConfig | undefined {\n        if (!this._showFileSelectButton()) {\n            return undefined;\n        }\n\n        const settings = this._getFileSelectButtonSettings();\n        let accept = settings?.accept;\n\n        if (!accept && settings?.restrictions?.allowedExtensions?.length) {\n            accept = settings.restrictions.allowedExtensions\n                .map(ext => ext.startsWith(\".\") ? ext : `.${ext}`)\n                .join(\",\");\n        }\n\n        return {\n            enable: settings?.enable,\n            fileInputId: this._fileInputId,\n            accept: accept,\n            multiple: settings?.multiple,\n            showSpacer: settings?.showSpacer,\n            settings: settings\n        };\n    }\n\n    /**\n     * Gets the button settings configuration for template rendering.\n     */\n    private _getButtonSettingsConfig(): IButtonSettingsConfig {\n        const options = this.options as IPromptBoxOptions;\n        const speechOption = options.speechToTextButton;\n        const speechSettings = typeof speechOption === \"object\" && speechOption !== null ? speechOption : undefined;\n        return {\n            actionButtonSettings: options.actionButton || undefined,\n            fileSelectButtonSettings: this._getFileSelectButtonSettings(),\n            speechToTextButtonSettings: speechSettings\n        };\n    }\n\n    /**\n     * Gets the current multiline state (for auto mode).\n     */\n    isMultiline(): boolean {\n        return this.inputManager.isMultiline();\n    }\n\n    /**\n     * Attaches event handlers.\n     */\n    private _attachEvents(): void {\n        this.wrapper.on(CLICK + NS, `[${REFERENCES.sendButton}]`, (e: JQuery.ClickEvent) => {\n            e.preventDefault();\n            this._handleSend();\n        });\n\n        this.wrapper.on(CLICK + NS, `[${REFERENCES.fileSelectButton}]`, (e: JQuery.ClickEvent) => {\n            e.preventDefault();\n            this.fileHandler.handleFileSelectClick();\n        });\n\n        this.wrapper.on(CLICK + NS, `[${REFERENCES.attachmentRemoveButton}]`, (e: JQuery.ClickEvent) => {\n            e.preventDefault();\n            const target = e.currentTarget as HTMLElement;\n            const uid = target.getAttribute(\"data-uid\");\n            if (uid) {\n                this.fileHandler.removeAttachmentByUid(uid);\n            }\n        });\n\n        this.wrapper.on(FOCUSIN + NS, (e: JQuery.FocusInEvent) => {\n            this._handleFocusIn(e);\n        });\n\n        this.wrapper.on(FOCUSOUT + NS, (e: JQuery.FocusOutEvent) => {\n            this._handleFocusOut(e);\n        });\n    }\n\n    /**\n     * Detaches event handlers.\n     */\n    private _detachEvents(): void {\n        this.wrapper.off(NS);\n    }\n\n    /**\n     * Handles focus entering the widget.\n     */\n    private _handleFocusIn(e: JQuery.FocusInEvent): void {\n        if (!this._hasFocus) {\n            this._hasFocus = true;\n            this.wrapper.addClass(STYLES.focus);\n            this.trigger(EVENTS.focus);\n        }\n    }\n\n    /**\n     * Handles focus leaving the widget.\n     */\n    private _handleFocusOut(e: JQuery.FocusOutEvent): void {\n        const relatedTarget = e.relatedTarget as HTMLElement;\n        const isInsideWidget = relatedTarget && this.wrapper[0].contains(relatedTarget);\n\n        if (!isInsideWidget && this._hasFocus) {\n            this._hasFocus = false;\n            this.wrapper.removeClass(STYLES.focus);\n            this.trigger(EVENTS.blur);\n        }\n    }\n\n    /**\n     * Handles the send action.\n     */\n    private _handleSend(): void {\n        const options = this.options as IPromptBoxOptions;\n\n        if (!options.enable || options.readonly || options.actionButton?.enable === false) {\n            return;\n        }\n\n        if (this._loading) {\n            const eventData: IActionButtonEvent = { actionType: \"stop\" };\n            this.trigger(EVENTS.promptAction, eventData);\n            this.loading(false);\n            return;\n        }\n\n        const value = this._value;\n        const hasValue = value?.trim();\n        const hasFiles = this.fileHandler.hasFiles();\n\n        if (!hasValue && !hasFiles) {\n            return;\n        }\n\n        const eventData: IActionButtonEvent = {\n            actionType: \"send\",\n            value: hasValue ? value.trim() : \"\",\n            files: this.fileHandler.getFiles()\n        };\n        this.trigger(EVENTS.promptAction, eventData);\n\n        this.value(\"\");\n        this.clearFiles();\n        this.focus();\n    }\n\n    /**\n     * Handles input changes.\n     */\n    private _handleInput(): void {\n        const oldValue = this._value;\n        this._value = this.inputManager.getValue();\n\n        this.actionButtonManager.updateState();\n\n        this.trigger(EVENTS.input, { value: this._value });\n\n        if (oldValue !== this._value) {\n            this.trigger(EVENTS.valueChange, {\n                oldValue,\n                newValue: this._value\n            });\n        }\n    }\n\n    /**\n     * Handles keydown events.\n     * Enter sends the message in all modes.\n     * Shift+Enter adds a newline in multi/auto modes.\n     * Enter is ignored when loading to prevent accidental stops.\n     */\n    private _handleKeyDown(e: JQuery.KeyDownEvent): void {\n        const mode = this._getMode();\n        const isEnter = e.key === \"Enter\" || e.which === 13 || e.keyCode === 13;\n\n        if (isEnter) {\n            if (e.shiftKey && mode !== LINE_MODE.SINGLE) {\n                return;\n            }\n\n            e.preventDefault();\n\n            if (!this._loading) {\n                this._handleSend();\n            }\n        }\n    }\n}\n","import { inject } from \"../core/service-container\";\nimport { CssPropertiesService } from \"../core/services/css-properties.service\";\n\n// Main PromptBox widget export\nexport { PromptBox } from \"./promptbox.widget\";\n\n// Models\nexport * from \"./models\";\n\n// Constants\nexport * from \"./constants\";\n\n// Templates\nexport * from \"./templates\";\n\n// Register PromptBox CSS properties\n// PromptBox uses k-input prefix for fillMode (k-input-solid, k-input-outline, k-input-flat)\nconst cssProps = inject(CssPropertiesService);\ncssProps.registerPrefix(\"PromptBox\", \"k-input-\");\ncssProps.registerValues(\"PromptBox\", [{\n    prop: \"fillMode\",\n    values: cssProps.fillModeValues\n}]);\n","/**\n * Date utility type definitions\n */\n\n/**\n * Date field mapping for format parsing\n */\nexport const DATE_FIELD_MAP: Record<string, string> = {\n    \"G\": \"era\",\n    \"y\": \"year\",\n    \"q\": \"quarter\",\n    \"Q\": \"quarter\",\n    \"M\": \"month\",\n    \"L\": \"month\",\n    \"d\": \"day\",\n    \"E\": \"weekday\",\n    \"c\": \"weekday\",\n    \"e\": \"weekday\",\n    \"h\": \"hour\",\n    \"H\": \"hour\",\n    \"k\": \"hour\",\n    \"K\": \"hour\",\n    \"m\": \"minute\",\n    \"s\": \"second\",\n    \"a\": \"dayperiod\",\n    \"t\": \"dayperiod\",\n    \"x\": \"zone\",\n    \"X\": \"zone\",\n    \"z\": \"zone\",\n    \"Z\": \"zone\"\n};\n\n/**\n * Name type configuration for date parts\n */\nexport interface NameTypeConfig {\n    type: string;\n    minLength: number | Record<string, number>;\n    standAlone?: string;\n}\n\n/**\n * Name types for date formatting\n */\nexport const NAME_TYPES: Record<string, NameTypeConfig> = {\n    month: {\n        type: \"months\",\n        minLength: 3,\n        standAlone: \"L\"\n    },\n    quarter: {\n        type: \"quarters\",\n        minLength: 3,\n        standAlone: \"q\"\n    },\n    weekday: {\n        type: \"days\",\n        minLength: {\n            E: 0,\n            c: 3,\n            e: 3\n        },\n        standAlone: \"c\"\n    },\n    dayperiod: {\n        type: \"dayPeriods\",\n        minLength: 0\n    },\n    era: {\n        type: \"eras\",\n        minLength: 0\n    }\n};\n\n/**\n * Date format part structure\n */\nexport interface DateFormatPart {\n    type: string;\n    pattern: string;\n    hour12?: boolean;\n    names?: {\n        type: string;\n        nameType: string;\n        standAlone: boolean;\n    };\n}\n\n/**\n * Options for date format names\n */\nexport interface DateFormatNamesOptions {\n    type: string;\n    nameType: string;\n}\n\n/**\n * Options for date field name\n */\nexport interface DateFieldNameOptions {\n    type: string;\n    nameType: string;\n}\n\n/**\n * Interface for date utility service\n */\nexport interface IDateUtilsService {\n    /** Milliseconds per minute constant */\n    readonly MS_PER_MINUTE: number;\n    /** Milliseconds per hour constant */\n    readonly MS_PER_HOUR: number;\n    /** Milliseconds per day constant */\n    readonly MS_PER_DAY: number;\n\n    /**\n     * Adjust date for DST changes\n     */\n    adjustDST(date: Date, hours: number): boolean;\n\n    /**\n     * Set the day of week on a date (mutates the date)\n     */\n    setDayOfWeek(date: Date, day: number, dir?: number): void;\n\n    /**\n     * Get a new date set to the specified day of week\n     */\n    dayOfWeek(date: Date, day: number, dir?: number): Date;\n\n    /**\n     * Get the first day of the month\n     */\n    firstDayOfMonth(date: Date): Date;\n\n    /**\n     * Get the last day of the month\n     */\n    lastDayOfMonth(date: Date): Date;\n\n    /**\n     * Get the first day of the year\n     */\n    firstDayOfYear(date: Date): Date;\n\n    /**\n     * Get the last day of the year\n     */\n    lastDayOfYear(date: Date): Date;\n\n    /**\n     * Get the week number in the year\n     */\n    weekInYear(date: Date, weekStartDay?: number): number;\n\n    /**\n     * Get a date with time set to midnight\n     */\n    getDate(date: Date): Date;\n\n    /**\n     * Convert date to UTC time\n     */\n    toUtcTime(date: Date): number;\n\n    /**\n     * Get milliseconds from midnight\n     */\n    getMilliseconds(date: Date): number;\n\n    /**\n     * Check if a time value is within a range\n     */\n    isInTimeRange(value: Date | null, min: Date, max: Date): boolean;\n\n    /**\n     * Check if a date value is within a range\n     */\n    isInDateRange(value: Date, min: Date, max: Date): boolean;\n\n    /**\n     * Add days to a date\n     */\n    addDays(date: Date, offset: number): Date;\n\n    /**\n     * Set time on a date (mutates the date)\n     */\n    setTime(date: Date, milliseconds: number, ignoreDST?: boolean): void;\n\n    /**\n     * Set hours from another date/time\n     */\n    setHours(date: Date, time: Date): Date;\n\n    /**\n     * Get today's date (midnight)\n     */\n    today(): Date;\n\n    /**\n     * Check if a date is today\n     */\n    isToday(date: Date): boolean;\n\n    /**\n     * Convert date to invariant time (fixed date, preserves time)\n     */\n    toInvariantTime(date?: Date): Date;\n\n    /**\n     * Get the next day\n     */\n    nextDay(date: Date): Date;\n\n    /**\n     * Get the previous day\n     */\n    previousDay(date: Date): Date;\n\n    /**\n     * Get the next year\n     */\n    nextYear(date: Date): Date;\n\n    /**\n     * Get the previous year\n     */\n    previousYear(date: Date): Date;\n\n    /**\n     * Split a date format string into parts\n     */\n    splitDateFormat(format: string): DateFormatPart[];\n\n    /**\n     * Get date format names (month names, day names, etc.)\n     */\n    dateFormatNames(options: DateFormatNamesOptions): string[];\n\n    /**\n     * Get date field name\n     */\n    dateFieldName(options: DateFieldNameOptions): string | undefined;\n\n    /**\n     * Generates a relative date string (Today, Yesterday, Last Wednesday, etc.)\n     * @param date - The date to compare against\n     * @param currentDate - The current date (defaults to new Date())\n     * @returns Relative date string\n     */\n    getRelativeDateString(date: Date | null | undefined, currentDate?: Date): string;\n}\n","/**\n * DOM utility type definitions\n */\n\nimport { ISupportService } from \"./support\";\n\n/**\n * Offset result from element position calculations\n */\nexport interface ElementOffset {\n    top: number;\n    right: number;\n    bottom: number;\n    left: number;\n}\n\n/**\n * Dimensions for hidden elements\n */\nexport interface HiddenDimensions {\n    width: number;\n    height: number;\n}\n\n/**\n * Shadow dimensions from box-shadow CSS\n */\nexport interface ShadowDimensions {\n    left: number;\n    right: number;\n    bottom: number;\n}\n\n/**\n * Parsed effects object\n */\nexport interface ParsedEffects {\n    [key: string]: string;\n}\n\n/**\n * Direction mapping for animations\n */\nexport interface DirectionInfo {\n    reverse: string;\n}\n\n/**\n * Animation directions\n */\nexport const DIRECTIONS: Record<string, DirectionInfo> = {\n    left: { reverse: \"right\" },\n    right: { reverse: \"left\" },\n    down: { reverse: \"up\" },\n    up: { reverse: \"down\" },\n    top: { reverse: \"bottom\" },\n    bottom: { reverse: \"top\" },\n    \"in\": { reverse: \"out\" },\n    out: { reverse: \"in\" }\n};\n\n/**\n * Interface for DOM utility service\n */\nexport interface IDomUtilsService {\n    /**\n     * Get outer width of element\n     * @param element - Element to measure\n     * @param includeMargin - Whether to include margin\n     * @param calculateFromHidden - Calculate width even if hidden\n     */\n    outerWidth(element: HTMLElement | JQuery | Window, includeMargin?: boolean, calculateFromHidden?: boolean): number;\n\n    /**\n     * Get outer height of element\n     * @param element - Element to measure\n     * @param includeMargin - Whether to include margin\n     * @param calculateFromHidden - Calculate height even if hidden\n     */\n    outerHeight(element: HTMLElement | JQuery | Window, includeMargin?: boolean, calculateFromHidden?: boolean): number;\n\n    /**\n     * Get computed styles for an element\n     */\n    getComputedStyles(element: HTMLElement, properties?: string[]): Record<string, string>;\n\n    /**\n     * Check if an element is scrollable\n     */\n    isScrollable(element: HTMLElement): boolean;\n\n    /**\n     * Get or set scroll left position (RTL-aware)\n     */\n    scrollLeft(element: HTMLElement | JQuery, value?: number): number | void;\n\n    /**\n     * Get element offset position\n     */\n    getOffset(element: JQuery, type?: string, positioned?: boolean): ElementOffset;\n\n    /**\n     * Get dimensions of a hidden element by temporarily cloning and showing it\n     */\n    getHiddenDimensions(element: JQuery, includeMargin?: boolean): HiddenDimensions;\n\n    /**\n     * Parse effects string into object\n     */\n    parseEffects(input: string | string[]): ParsedEffects;\n\n    /**\n     * Remove whitespace text nodes from an element\n     */\n    stripWhitespace(element: HTMLElement): void;\n\n    /**\n     * Request animation frame wrapper\n     */\n    animationFrame(callback: FrameRequestCallback): void;\n\n    /**\n     * Queue an animation callback\n     */\n    queueAnimation(callback: () => void): void;\n\n    /**\n     * Run the next animation in queue\n     */\n    runNextAnimation(): void;\n\n    /**\n     * Parse query string parameters from URL\n     */\n    parseQueryStringParams(url: string): Record<string, string>;\n\n    /**\n     * Get element under cursor position\n     */\n    elementUnderCursor(e: { x: { client?: number }; y: { client?: number } }): Element | null;\n\n    /**\n     * Get wheel delta Y from jQuery event\n     */\n    wheelDeltaY(jQueryEvent: JQuery.MouseEventBase): number | undefined;\n\n    /**\n     * Get box-shadow dimensions from an element\n     */\n    getShadows(element: JQuery): ShadowDimensions;\n\n    /**\n     * Wrap element with animation container\n     */\n    wrap(element: JQuery, autosize?: boolean, resize?: boolean, shouldCorrectWidth?: boolean, autowidth?: boolean): JQuery;\n\n    /**\n     * Resize wrapped element\n     */\n    wrapResize(element: JQuery, autosize?: boolean, shouldCorrectWidth?: boolean): void;\n\n    /**\n     * Scroll element horizontally by a delta\n     */\n    scrollByDelta(element: JQuery, delta: number): ScrollResult;\n\n    /**\n     * Scroll element vertically by a delta\n     */\n    scrollVerticalByDelta(element: JQuery, delta: number, options?: VerticalScrollOptions): VerticalScrollResult;\n\n    /**\n     * Smoothly scroll to a specific element within a container\n     */\n    scrollToElement(container: JQuery, targetElement: JQuery, options?: ScrollToElementOptions): boolean;\n\n    /**\n     * Add a value to an element's attribute, avoiding duplicates\n     * @param element - jQuery element\n     * @param attribute - Attribute name\n     * @param value - Value to add\n     */\n    addAttribute(element: JQuery, attribute: string, value: string): void;\n\n    /**\n     * Remove an attribute from an element\n     * @param element - jQuery element\n     * @param attribute - Attribute name to remove\n     */\n    removeAttribute(element: JQuery, attribute: string): void;\n\n    /**\n     * Toggle an attribute value on an element\n     * Adds if not present, removes if present (with special handling for disabled/readonly)\n     * @param element - jQuery element\n     * @param attribute - Attribute name\n     * @param value - Value to toggle\n     */\n    toggleAttribute(element: JQuery, attribute: string, value: string): void;\n\n    /**\n     * Bind a callback to the window resize event.\n     * On Android, the callback is delayed by 600ms.\n     * @param callback - Function to call on resize\n     * @returns The handler function (may be wrapped)\n     */\n    onResize(callback: () => void): () => void;\n\n    /**\n     * Unbind a resize callback from the window.\n     * @param callback - The handler returned from onResize\n     */\n    unbindResize(callback: () => void): void;\n\n    /**\n     * Get a data attribute value from an element using kendo namespace.\n     * @param element - jQuery element\n     * @param key - Attribute key (without kendo namespace prefix)\n     * @returns The attribute value\n     */\n    attrValue(element: JQuery, key: string): any;\n\n    /**\n     * Get the kendo data attribute name with namespace prefix.\n     * @param value - The attribute name without prefix\n     * @returns The full attribute name (e.g., \"data-kendo-role\" or \"data-role\")\n     */\n    attr(value: string): string;\n\n    /**\n     * Get or set element dimensions.\n     * @param element - jQuery element\n     * @param dimensions - Optional dimensions to set\n     * @returns Object with width and height\n     */\n    dimensions(element: JQuery, dimensions?: { width?: number | string; height?: number | string }): { width: number; height: number };\n\n    /**\n     * Check if an object is an HTML element or document\n     * @param element - Object to check\n     * @returns True if element is Element or HTMLDocument\n     */\n    isElement(element: any): boolean;\n\n    /**\n     * Check if an event was triggered by an input element\n     * @param e - Event object\n     * @returns True if event target is a form input element\n     */\n    triggeredByInput(e: Event | { target: HTMLElement }): boolean;\n\n    /**\n     * Apply inline styles from kendo data attributes to elements\n     * @param element - Container element to search within\n     * @param styleProps - Array of CSS property names to apply\n     */\n    applyStylesFromKendoAttributes(element: JQuery, styleProps: string[]): void;\n\n    /**\n     * Show or hide a loading mask on a container element\n     * @param container - Container element for the mask\n     * @param toggle - Whether to show (true) or hide (false) the mask\n     * @param options - Optional configuration for the mask\n     */\n    progress(container: JQuery, toggle: boolean, options?: ProgressOptions): void;\n\n    /**\n     * Get the actual target element from an event, handling touch events.\n     * For touch events, uses document.elementFromPoint with touch coordinates.\n     * @param e - Event object (mouse or touch)\n     * @returns The target element\n     */\n    eventTarget(e: Event | JQuery.Event): EventTarget | null;\n\n    /**\n     * Create a drag-to-scroll handler for horizontal scrolling via mouse/touch drag.\n     * @param scrollContainer - The element that will be scrolled\n     * @param options - Configuration options including namespace and capture element\n     * @returns Handler with attach() and destroy() methods\n     */\n    createDragToScrollHandler(scrollContainer: JQuery, options: DragToScrollOptions): DragToScrollHandler;\n}\n\n/**\n * Options for the progress/loading mask\n */\nexport interface ProgressOptions {\n    width?: string | number;\n    height?: string | number;\n    top?: number;\n    opacity?: boolean;\n}\n\n/**\n * Result of horizontal scroll operation\n */\nexport interface ScrollResult {\n    atStart: boolean;\n    atEnd: boolean;\n}\n\n/**\n * Result of vertical scroll operation\n */\nexport interface VerticalScrollResult {\n    atTop: boolean;\n    atBottom: boolean;\n}\n\n/**\n * Options for vertical scroll by delta\n */\nexport interface VerticalScrollOptions {\n    duration?: string | number;\n    easing?: string;\n}\n\n/**\n * Options for scrollToElement\n */\nexport interface ScrollToElementOptions {\n    duration?: number;\n    easing?: string;\n    position?: 'top' | 'center' | 'bottom';\n    offset?: number;\n    onComplete?: () => void;\n}\n\n/**\n * Options for drag-to-scroll handler\n */\nexport interface DragToScrollOptions {\n    namespace: string;\n    captureElement?: JQuery;\n    delegateSelector?: string;\n}\n\n/**\n * Drag-to-scroll handler returned by createDragToScrollHandler\n */\nexport interface DragToScrollHandler {\n    attach(): void;\n    destroy(): void;\n}\n","import { IDataboundWidget } from \"../models\";\nimport { Widget } from \"./widget\";\n\nexport class DataBoundWidget extends Widget implements IDataboundWidget {\n    /**\n     * Retrieves the data items currently bound to the widget.\n     * @returns An array of data items\n     */\n    dataItems(): any[] {\n        const dataSource = (this as any).dataSource;\n        if (dataSource && typeof dataSource.view === \"function\") {\n            return dataSource.flatView();\n        }\n        return [];\n    }\n}\n\nDataBoundWidget.fn = DataBoundWidget.prototype;\n\n// Re-export types for convenience\nexport type {\n    IDataboundWidget\n} from \"../models/databound-widget\";","import { Culture, Calendars, CulturesRegistry, ICultureService } from \"../models/culture\";\n\nconst DEFAULT_LANGUAGE: string = \"en-US\";\n\nconst DEFAULT_EN_US_CULTURE: Culture = {\n    name: DEFAULT_LANGUAGE,\n    numberFormat: {\n        pattern: [\"-n\"],\n        decimals: 2,\n        \",\": \",\",\n        \".\": \".\",\n        groupSize: [3],\n        percent: {\n            pattern: [\"-n %\", \"n %\"],\n            decimals: 2,\n            \",\": \",\",\n            \".\": \".\",\n            groupSize: [3],\n            symbol: \"%\"\n        },\n        currency: {\n            name: \"US Dollar\",\n            abbr: \"USD\",\n            pattern: [\"($n)\", \"$n\"],\n            decimals: 2,\n            \",\": \",\",\n            \".\": \".\",\n            groupSize: [3],\n            symbol: \"$\"\n        }\n    },\n    calendars: {\n        standard: {\n            days: {\n                names: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n                namesAbbr: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n                namesShort: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"]\n            },\n            months: {\n                names: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n                namesAbbr: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n            },\n            AM: [\"AM\", \"am\", \"AM\"],\n            PM: [\"PM\", \"pm\", \"PM\"],\n            patterns: {\n                d: \"M/d/yyyy\",\n                D: \"dddd, MMMM dd, yyyy\",\n                F: \"dddd, MMMM dd, yyyy h:mm:ss tt\",\n                g: \"M/d/yyyy h:mm tt\",\n                G: \"M/d/yyyy h:mm:ss tt\",\n                m: \"MMMM dd\",\n                M: \"MMMM dd\",\n                s: \"yyyy'-'MM'-'ddTHH':'mm':'ss\",\n                t: \"h:mm tt\",\n                T: \"h:mm:ss tt\",\n                u: \"yyyy'-'MM'-'dd HH':'mm':'ss'Z'\",\n                y: \"MMMM, yyyy\",\n                Y: \"MMMM, yyyy\"\n            },\n            \"/\": \"/\",\n            \":\": \":\",\n            firstDay: 0,\n            twoDigitYearMax: 2029\n        }\n    }\n};\n\nexport class CultureService implements ICultureService {\n    private cultures: CulturesRegistry;\n\n    constructor(culturesRegistry: CulturesRegistry) {\n        this.cultures = culturesRegistry;\n        \n        // Initialize with default en-US culture if not present\n        if (!this.cultures[DEFAULT_LANGUAGE]) {\n            this.cultures[DEFAULT_LANGUAGE] = DEFAULT_EN_US_CULTURE;\n        }\n    }\n\n    /**\n     * Finds a culture by name or returns the culture object if already in the correct format\n     * @param {string|Culture} culture - Culture name (e.g., \"en-US\") or culture object\n     * @returns {Culture|null} The found culture object or null\n     */\n    findCulture(culture: string | Culture | null | undefined): Culture | null {\n        if (culture) {\n            if (typeof culture === \"string\") {\n                return this.cultures[culture] || this.cultures[culture.split(\"-\")[0]] || null;\n            }\n\n            if ((culture as Culture).numberFormat) {\n                return culture as Culture;\n            }\n\n            return null;\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets a culture by name, returning current culture if not found\n     * @param {string|Culture} culture - Culture name or culture object\n     * @returns {Culture} The found culture or current culture\n     */\n    getCulture(culture: string | Culture | null | undefined): Culture {\n        if (culture) {\n            culture = this.findCulture(culture);\n        }\n\n        return (culture as Culture) || this.cultures.current!;\n    }\n\n    /**\n     * Appends AM/PM designators to the culture's AM/PM arrays\n     * @param {Calendars} calendars - The calendars object from a culture\n     */\n    appendDesignatorsToCultures(calendars: Calendars): void {\n        // Don't ask. It's temporary.\n        if ((calendars.standard.AM && calendars.standard.AM.length)\n            && (calendars.standard.PM && calendars.standard.PM.length)\n            && (calendars.standard.AM.indexOf(\"PMA0\") < 0)\n            && (calendars.standard.AM.indexOf(\"AM\") > -1 || calendars.standard.PM.indexOf(\"PM\") > -1)) {\n            calendars.standard.AM.push(\"a\", \"A\", \"PMa\", \"PMA\", \"PMa0\", \"PMA0\");\n            calendars.standard.PM.push(\"p\", \"P\", \"AMp\", \"AMP\", \"AMp0\", \"AMP0\");\n        }\n    }\n\n    /**\n     * Gets the current culture\n     * @returns {Culture} The current culture\n     */\n    culture(): Culture {\n        this.appendDesignatorsToCultures(this.cultures.current!.calendars);\n        return this.cultures.current!;\n    }\n\n    /**\n     * Sets the current culture\n     * @param {string} cultureName - The name of the culture to set\n     */\n    setCulture(cultureName: string): void {\n        const culture = this.findCulture(cultureName) || this.cultures[DEFAULT_LANGUAGE];\n        (culture as Culture).calendar = (culture as Culture).calendars.standard;\n        this.cultures.current = culture as Culture;\n    }\n\n    /**\n     * Register a culture (called when external culture files are loaded)\n     * @param {string} name - Culture name (e.g., \"de-DE\")\n     * @param {Culture} culture - Culture object\n     */\n    registerCulture(name: string, culture: Culture): void {\n        this.cultures[name] = culture;\n    }\n\n    /**\n     * Get the cultures registry (for creating proxy)\n     * @returns {CulturesRegistry} The cultures registry\n     */\n    getCulturesRegistry(): CulturesRegistry {\n        return this.cultures;\n    }\n}","import { Culture, ICultureService } from \"../models/culture\";\nimport { INumberFormatter } from \"../models/formatter\";\n\nconst DOT = \".\";\nconst COMMA = \",\";\nconst SHARP = \"#\";\nconst ZERO = \"0\";\nconst PLACEHOLDER = \"??\";\nconst EMPTY = \"\";\n\nconst STANDARD_FORMAT_REGEX = /^(n|c|p|e)(\\d*)$/i;\nconst LITERAL_REGEX = /(\\\\.)|(googol)|(['][^']*[']?)|([\"][^\"]*[\"]?)/g;\nconst COMMA_REGEX = /\\,/g;\n\n/**\n * Represents a number format that can be the main format or a sub-format (currency/percent)\n */\ninterface NumberFormatInfo {\n    pattern: string[];\n    decimals: number;\n    \",\": string;\n    \".\": string;\n    groupSize: number[];\n    symbol?: string;\n    percent?: NumberFormatInfo;\n    currency?: NumberFormatInfo;\n}\n\nexport class NumberFormatterService implements INumberFormatter {\n    constructor(private cultureService: ICultureService) {}\n\n    format(number: number, format: string, culture?: string | Culture): string {\n        const resolvedCulture = culture \n            ? this.cultureService.getCulture(culture) \n            : this.cultureService.culture();\n\n        let numberFormat: NumberFormatInfo = resolvedCulture.numberFormat as NumberFormatInfo;\n        let decimal = numberFormat[DOT];\n        let precision = numberFormat.decimals;\n        let pattern = numberFormat.pattern[0];\n        const literals: string[] = [];\n        let symbol: string | undefined;\n        let isCurrency: boolean;\n        let isPercent: boolean;\n        let customPrecision: string;\n        let formatAndPrecision: RegExpExecArray | null;\n        let negative = number < 0;\n        let integer: string;\n        let fraction: string;\n        let integerLength: number;\n        let value: string = EMPTY;\n        let length: number;\n        let hasGroup: boolean;\n        let hasNegativeFormat: boolean;\n        let decimalIndex: number;\n        let zeroIndex: number;\n        let start = -1;\n        let end: number;\n\n        // Return empty string if no number\n        if (number === undefined) {\n            return EMPTY;\n        }\n\n        if (!isFinite(number)) {\n            return String(number);\n        }\n\n        // If no format then return number.toString() or number.toLocaleString() if culture.name is not defined\n        if (!format) {\n            return resolvedCulture.name.length ? number.toLocaleString() : number.toString();\n        }\n\n        formatAndPrecision = STANDARD_FORMAT_REGEX.exec(format);\n\n        // Standard formatting\n        if (formatAndPrecision) {\n            format = formatAndPrecision[1].toLowerCase();\n\n            isCurrency = format === \"c\";\n            isPercent = format === \"p\";\n\n            if (isCurrency || isPercent) {\n                // Get specific number format information if format is currency or percent\n                numberFormat = isCurrency ? numberFormat.currency : numberFormat.percent;\n                decimal = numberFormat[DOT];\n                precision = numberFormat.decimals;\n                symbol = numberFormat.symbol;\n                pattern = numberFormat.pattern[negative ? 0 : 1];\n            }\n\n            customPrecision = formatAndPrecision[2];\n\n            if (customPrecision) {\n                precision = +customPrecision;\n            }\n\n            // Return number in exponential format\n            if (format === \"e\") {\n                const exp = customPrecision ? number.toExponential(precision) : number.toExponential();\n                return exp.replace(DOT, numberFormat[DOT]);\n            }\n\n            // Multiply if format is percent\n            if (isPercent) {\n                number *= 100;\n            }\n\n            const rounded = this.round(number, precision);\n            negative = parseFloat(rounded) < 0;\n            const parts = rounded.split(DOT);\n\n            integer = parts[0];\n            fraction = parts[1];\n\n            // Exclude \"-\" if number is negative\n            if (negative) {\n                integer = integer.substring(1);\n            }\n\n            value = this.groupInteger(integer, 0, integer.length, numberFormat);\n\n            if (fraction) {\n                value += decimal + fraction;\n            }\n\n            if (format === \"n\" && !negative) {\n                return value;\n            }\n\n            let result = EMPTY;\n\n            for (let idx = 0, len = pattern.length; idx < len; idx++) {\n                const ch = pattern.charAt(idx);\n\n                if (ch === \"n\") {\n                    result += value;\n                } else if (ch === \"$\" || ch === \"%\") {\n                    result += symbol;\n                } else {\n                    result += ch;\n                }\n            }\n\n            return result;\n        }\n\n        // Custom formatting\n        // Separate format by sections\n        format = this.extractLiterals(format, literals);\n\n        const formatSections = format.split(\";\");\n        const formatSectionResult = this.selectFormatSection(formatSections, negative, number);\n        format = formatSectionResult.format;\n        hasNegativeFormat = formatSectionResult.hasNegativeFormat;\n        \n        if (formatSectionResult.isZeroFormat) {\n            return format;\n        }\n\n        let percentIndex = format.indexOf(\"%\");\n        let currencyIndex = format.indexOf(\"$\");\n\n        isPercent = percentIndex !== -1;\n        isCurrency = currencyIndex !== -1;\n\n        // Multiply number if the format has percent\n        if (isPercent) {\n            number *= 100;\n        }\n\n        if (isCurrency && format[currencyIndex - 1] === \"\\\\\") {\n            format = format.split(\"\\\\\").join(\"\");\n            isCurrency = false;\n        }\n\n        if (isCurrency || isPercent) {\n            // Get specific number format information if format is currency or percent\n            numberFormat = isCurrency ? numberFormat.currency : numberFormat.percent;\n            decimal = numberFormat[DOT];\n            precision = numberFormat.decimals;\n            symbol = numberFormat.symbol;\n        }\n\n        hasGroup = format.indexOf(COMMA) > -1;\n        if (hasGroup) {\n            format = format.replace(COMMA_REGEX, EMPTY);\n        }\n\n        const decimalResult = this.calculateDecimalPrecision(format, number, negative);\n        format = decimalResult.format;\n        decimalIndex = decimalResult.decimalIndex;\n        length = decimalResult.length;\n        const roundedNumber = decimalResult.number;\n\n        const positionResult = this.findPlaceholderPositions(format);\n        start = positionResult.start;\n        end = positionResult.end;\n        zeroIndex = positionResult.zeroIndex;\n\n        if (start === length) {\n            end = start;\n        }\n\n        if (start !== -1) {\n            const valueParts = roundedNumber.toString().split(DOT);\n            integer = valueParts[0];\n            fraction = valueParts[1] || EMPTY;\n\n            integerLength = integer.length;\n\n            if (negative && (parseFloat(roundedNumber) * -1) >= 0) {\n                negative = false;\n            }\n\n            let result = this.applyPatternToNumber(\n                format, start, end, length, negative, hasNegativeFormat, \n                decimalIndex, integer, fraction, decimal, zeroIndex\n            );\n\n            if (hasGroup) {\n                result = this.groupInteger(\n                    result, \n                    start + (negative && !hasNegativeFormat ? 1 : 0), \n                    Math.max(end, (integerLength + start)), \n                    numberFormat\n                );\n            }\n\n            if (end >= start) {\n                result += format.substring(end + 1);\n            }\n\n            if (isCurrency || isPercent) {\n                result = this.replaceSymbols(result, symbol!);\n            }\n\n            if (literals.length) {\n                result = this.replaceLiterals(result, literals);\n            }\n\n            return result;\n        }\n\n        return String(roundedNumber);\n    }\n\n    private replaceSymbols(number: string, symbol: string): string {\n        let value = EMPTY;\n        for (let idx = 0, len = number.length; idx < len; idx++) {\n            const ch = number.charAt(idx);\n            value += (ch === \"$\" || ch === \"%\") ? symbol : ch;\n        }\n        return value;\n    }\n\n    private replaceLiterals(number: string, literals: string[]): string {\n        for (let idx = 0; idx < literals.length; idx++) {\n            number = number.replace(PLACEHOLDER, literals[idx]);\n        }\n        return number;\n    }\n\n    private applyPatternToNumber(\n        format: string, start: number, end: number, length: number, \n        negative: boolean, hasNegativeFormat: boolean, decimalIndex: number, \n        integer: string, fraction: string, decimal: string, zeroIndex: number\n    ): string {\n        let number = format.substring(0, start);\n        let replacement = EMPTY;\n        const integerLength = integer.length;\n\n        if (negative && !hasNegativeFormat) {\n            number += \"-\";\n        }\n\n        let idx = start;\n        while (idx < length) {\n            const ch = format.charAt(idx);\n\n            if (decimalIndex === -1) {\n                if (end - idx < integerLength) {\n                    number += integer;\n                    break;\n                }\n            } else {\n                if (zeroIndex !== -1 && zeroIndex < idx) {\n                    replacement = EMPTY;\n                }\n\n                if ((decimalIndex - idx) <= integerLength && decimalIndex - idx > -1) {\n                    number += integer;\n                    idx = decimalIndex;\n                }\n\n                if (decimalIndex === idx) {\n                    number += (fraction ? decimal : EMPTY) + fraction;\n                    idx += end - decimalIndex + 1;\n                    continue;\n                }\n            }\n\n            if (ch === ZERO) {\n                number += ch;\n                replacement = ch;\n            } else if (ch === SHARP) {\n                number += replacement;\n            }\n            idx++;\n        }\n\n        return number;\n    }\n\n    private selectFormatSection(\n        formatSections: string[], negative: boolean, number: number\n    ): { format: string; hasNegativeFormat: boolean; isZeroFormat: boolean } {\n        let format: string;\n        let hasNegativeFormat = false;\n        let isZeroFormat = false;\n\n        if (negative && formatSections[1]) {\n            format = formatSections[1];\n            hasNegativeFormat = true;\n        } else if (number === 0 && formatSections[2]) {\n            format = formatSections[2];\n            if (format.indexOf(SHARP) === -1 && format.indexOf(ZERO) === -1) {\n                isZeroFormat = true;\n            }\n        } else {\n            format = formatSections[0];\n        }\n\n        return { format, hasNegativeFormat, isZeroFormat };\n    }\n\n    private calculateDecimalPrecision(\n        format: string, number: number, negative: boolean\n    ): { format: string; decimalIndex: number; length: number; number: string } {\n        let decimalIndex = format.indexOf(DOT);\n        let idx = 0;\n        let length = format.length;\n        let fraction: string;\n        let zeroIndex: number;\n        let sharpIndex: number;\n        let hasZero: boolean;\n        let hasSharp: boolean;\n        let rounded: string;\n\n        if (decimalIndex !== -1) {\n            const expParts = number.toString().split(\"e\");\n            if (expParts[1]) {\n                fraction = this.round(number, Math.abs(parseInt(expParts[1], 10)));\n            } else {\n                fraction = expParts[0];\n            }\n            fraction = fraction.split(DOT)[1] || EMPTY;\n            zeroIndex = format.lastIndexOf(ZERO) - decimalIndex;\n            sharpIndex = format.lastIndexOf(SHARP) - decimalIndex;\n            hasZero = zeroIndex > -1;\n            hasSharp = sharpIndex > -1;\n            idx = fraction.length;\n\n            if (!hasZero && !hasSharp) {\n                format = format.substring(0, decimalIndex) + format.substring(decimalIndex + 1);\n                length = format.length;\n                decimalIndex = -1;\n                idx = 0;\n            }\n\n            if (hasZero && zeroIndex > sharpIndex) {\n                idx = zeroIndex;\n            } else if (sharpIndex > zeroIndex) {\n                if (hasSharp && idx > sharpIndex) {\n                    rounded = this.round(number, sharpIndex, negative);\n\n                    while (rounded.charAt(rounded.length - 1) === ZERO && sharpIndex > 0 && sharpIndex > zeroIndex) {\n                        sharpIndex--;\n                        rounded = this.round(number, sharpIndex, negative);\n                    }\n\n                    idx = sharpIndex;\n                } else if (hasZero && idx < zeroIndex) {\n                    idx = zeroIndex;\n                }\n            }\n        }\n\n        const resultNumber = this.round(number, idx, negative);\n\n        return { format, decimalIndex, length, number: resultNumber };\n    }\n\n    private findPlaceholderPositions(format: string): { start: number; end: number; zeroIndex: number } {\n        let sharpIndex = format.indexOf(SHARP);\n        const startZeroIndex = format.indexOf(ZERO);\n        let start: number;\n        let end: number;\n        let zeroIndex: number;\n\n        if (sharpIndex === -1 && startZeroIndex !== -1) {\n            start = startZeroIndex;\n        } else if (sharpIndex !== -1 && startZeroIndex === -1) {\n            start = sharpIndex;\n        } else {\n            start = sharpIndex > startZeroIndex ? startZeroIndex : sharpIndex;\n        }\n\n        sharpIndex = format.lastIndexOf(SHARP);\n        zeroIndex = format.lastIndexOf(ZERO);\n\n        if (sharpIndex === -1 && zeroIndex !== -1) {\n            end = zeroIndex;\n        } else if (sharpIndex !== -1 && zeroIndex === -1) {\n            end = sharpIndex;\n        } else {\n            end = sharpIndex > zeroIndex ? sharpIndex : zeroIndex;\n        }\n\n        return { start, end, zeroIndex };\n    }\n\n    private extractLiterals(format: string, literals: string[]): string {\n        if (format.indexOf(\"'\") > -1 || format.indexOf('\"') > -1 || format.indexOf(\"\\\\\") > -1) {\n            format = format.replace(LITERAL_REGEX, (match) => {\n                const quoteChar = match.charAt(0).replace(\"\\\\\", \"\");\n                const literal = match.slice(1).replace(quoteChar, \"\");\n                literals.push(literal);\n                return PLACEHOLDER;\n            });\n        }\n        return format;\n    }\n\n    private groupInteger(number: string, start: number, end: number, numberFormat: NumberFormatInfo): string {\n        const decimalIndex = number.indexOf(numberFormat[DOT]);\n        const groupSizes = numberFormat.groupSize.slice();\n        let groupSize = groupSizes.shift()!;\n        let integer: string;\n        let integerLength: number;\n        let idx: number;\n        let parts: string[];\n        let value: string;\n        let newGroupSize: number | undefined;\n\n        end = decimalIndex !== -1 ? decimalIndex : end + 1;\n\n        integer = number.substring(start, end);\n        integerLength = integer.length;\n\n        if (integerLength >= groupSize) {\n            idx = integerLength;\n            parts = [];\n\n            while (idx > -1) {\n                value = integer.substring(idx - groupSize, idx);\n                if (value) {\n                    parts.push(value);\n                }\n                idx -= groupSize;\n                newGroupSize = groupSizes.shift();\n                groupSize = newGroupSize !== undefined ? newGroupSize : groupSize;\n\n                if (groupSize === 0) {\n                    if (idx > 0) {\n                        parts.push(integer.substring(0, idx));\n                    }\n                    break;\n                }\n            }\n\n            integer = parts.reverse().join(numberFormat[COMMA]);\n            number = number.substring(0, start) + integer + number.substring(end);\n        }\n\n        return number;\n    }\n\n    /**\n     * Round a number to specified precision\n     */\n    round(value: number, precision: number, negative?: boolean): string {\n        return NumberFormatterService.round(value, precision, negative);\n    }\n\n    /**\n     * Static method for rounding numbers (used externally by other components)\n     */\n    static round(value: number, precision: number, negative?: boolean): string {\n        precision = precision || 0;\n\n        let parts = value.toString().split('e');\n        let rounded = Math.round(+(parts[0] + 'e' + (parts[1] ? (+parts[1] + precision) : precision)));\n\n        if (negative) {\n            rounded = -rounded;\n        }\n\n        parts = rounded.toString().split('e');\n        const result = +(parts[0] + 'e' + (parts[1] ? (+parts[1] - precision) : -precision));\n\n        return result.toFixed(Math.min(precision, 20));\n    }\n}\n","import { Culture, CalendarStandard, ICultureService } from \"../models/culture\";\nimport { IDateFormatter } from \"../models/formatter\";\n\nconst DATE_FORMAT_REGEX = /dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|HH|H|hh|h|mm|m|fff|ff|f|tt|aa|ss|s|zzz|zz|z|EEEE|\"[^\"]*\"|'[^']*'/g;\n\n/**\n * Pad a number with leading zeros\n */\nfunction pad(value: number, length: number = 2): string {\n    let str = String(value);\n    while (str.length < length) {\n        str = \"0\" + str;\n    }\n    return str;\n}\n\nexport class DateFormatterService implements IDateFormatter {\n    constructor(private cultureService: ICultureService) {}\n\n    format(date: Date, format: string, culture?: string | Culture): string {\n        const resolvedCulture = culture \n            ? this.cultureService.getCulture(culture) \n            : this.cultureService.culture();\n\n        const calendar = resolvedCulture.calendars.standard;\n        const days = calendar.days;\n        const months = calendar.months;\n\n        const resolvedFormat = (format as any).pattern || calendar.patterns[format as keyof typeof calendar.patterns] || format;\n\n        return resolvedFormat.replace(DATE_FORMAT_REGEX, (match: string) => {\n            return this.formatMatch(match, date, calendar, days, months);\n        });\n    }\n\n    private formatMatch(\n        match: string, \n        date: Date, \n        calendar: CalendarStandard,\n        days: { names: string[]; namesAbbr: string[]; namesShort: string[] },\n        months: { names: string[]; namesAbbr: string[] }\n    ): string | number {\n        let result: string | number | undefined;\n        let minutes: number;\n        let sign: boolean;\n\n        if (match === \"d\") {\n            result = date.getDate();\n        } else if (match === \"dd\") {\n            result = pad(date.getDate());\n        } else if (match === \"ddd\") {\n            result = days.namesAbbr[date.getDay()];\n        } else if (match === \"dddd\" || match === \"EEEE\") {\n            result = days.names[date.getDay()];\n        } else if (match === \"M\") {\n            result = date.getMonth() + 1;\n        } else if (match === \"MM\") {\n            result = pad(date.getMonth() + 1);\n        } else if (match === \"MMM\") {\n            result = months.namesAbbr[date.getMonth()];\n        } else if (match === \"MMMM\") {\n            result = months.names[date.getMonth()];\n        } else if (match === \"yy\") {\n            result = pad(date.getFullYear() % 100);\n        } else if (match === \"yyyy\") {\n            result = pad(date.getFullYear(), 4);\n        } else if (match === \"h\") {\n            result = date.getHours() % 12 || 12;\n        } else if (match === \"hh\") {\n            result = pad(date.getHours() % 12 || 12);\n        } else if (match === \"H\") {\n            result = date.getHours();\n        } else if (match === \"HH\") {\n            result = pad(date.getHours());\n        } else if (match === \"m\") {\n            result = date.getMinutes();\n        } else if (match === \"mm\") {\n            result = pad(date.getMinutes());\n        } else if (match === \"s\") {\n            result = date.getSeconds();\n        } else if (match === \"ss\") {\n            result = pad(date.getSeconds());\n        } else if (match === \"f\") {\n            result = Math.floor(date.getMilliseconds() / 100);\n        } else if (match === \"ff\") {\n            let ms = date.getMilliseconds();\n            if (ms > 99) {\n                ms = Math.floor(ms / 10);\n            }\n            result = pad(ms);\n        } else if (match === \"fff\") {\n            result = pad(date.getMilliseconds(), 3);\n        } else if (match === \"tt\" || match === \"aa\") {\n            result = date.getHours() < 12 ? calendar.AM[0] : calendar.PM[0];\n        } else if (match === \"zzz\") {\n            minutes = date.getTimezoneOffset();\n            sign = minutes < 0;\n\n            let hours = Math.abs(minutes / 60).toString().split(\".\")[0];\n            minutes = Math.abs(minutes) - (parseInt(hours, 10) * 60);\n\n            result = (sign ? \"+\" : \"-\") + pad(parseInt(hours, 10));\n            result += \":\" + pad(minutes);\n        } else if (match === \"zz\" || match === \"z\") {\n            let hours = date.getTimezoneOffset() / 60;\n            sign = hours < 0;\n\n            const absHours = Math.abs(hours).toString().split(\".\")[0];\n            result = (sign ? \"+\" : \"-\") + (match === \"zz\" ? pad(parseInt(absHours, 10)) : absHours);\n        }\n\n        return result !== undefined ? result : match.slice(1, match.length - 1);\n    }\n}\n","import { Culture } from \"../models/culture\";\nimport { IFormatterService, INumberFormatter, IDateFormatter, ToStringResult } from \"../models/formatter\";\nimport { NumberFormatterService } from \"./number-formatter.service\";\n\nconst DATE_OBJECT = \"[object Date]\";\nconst FORMAT_REGEX = /\\{(\\d+)(:[^\\}]+)?\\}/g;\nconst objectToString = {}.toString;\n\nexport class FormatterService implements IFormatterService {\n    constructor(\n        private numberFormatter: INumberFormatter,\n        private dateFormatter: IDateFormatter\n    ) {}\n\n    /**\n     * Format a value to string, or return it as-is if no format specified.\n     * The loose return type matches original kendo.toString behavior where\n     * unformatted values pass through (e.g., null stays null for jQuery .val())\n     */\n    toString(value: Date | number | null | undefined, format?: string, culture?: string | Culture): ToStringResult {\n        if (format) {\n            if (objectToString.call(value) === DATE_OBJECT) {\n                return this.dateFormatter.format(value as Date, format, culture);\n            } else if (typeof value === \"number\") {\n                return this.numberFormatter.format(value, format, culture);\n            }\n        }\n\n        // Match original behavior: return value as-is (not String(value))\n        // This allows jQuery .val(null) to work correctly (clears input)\n        return value !== undefined ? value : \"\";\n    }\n\n    format(fmt: string, ...values: unknown[]): string {\n        return fmt.replace(FORMAT_REGEX, (_, index, placeholderFormat) => {\n            const value = values[parseInt(index, 10)];\n            const result = this.toString(\n                value as Date | number | undefined, \n                placeholderFormat ? placeholderFormat.substring(1) : \"\"\n            );\n            // Let JS coerce to string (null becomes \"null\", undefined becomes \"undefined\")\n            // This matches original behavior where String.replace does implicit coercion\n            return String(result);\n        });\n    }\n\n    extractFormat(format: string): string {\n        if (format.slice(0, 3) === \"{0:\") {\n            format = format.slice(3, format.length - 1);\n        }\n        return format;\n    }\n\n    /**\n     * Get the number formatter instance (for direct access)\n     */\n    getNumberFormatter(): INumberFormatter {\n        return this.numberFormatter;\n    }\n\n    /**\n     * Get the date formatter instance (for direct access)\n     */\n    getDateFormatter(): IDateFormatter {\n        return this.dateFormatter;\n    }\n\n    /**\n     * Static round method exposed for external use (matches kendo._round)\n     */\n    static round(value: number, precision: number, negative?: boolean): string {\n        return NumberFormatterService.round(value, precision, negative);\n    }\n}\n","import { Culture, ICultureService } from \"../models/culture\";\nimport { INumberParserService } from \"../models/parser\";\n\nconst DOT = \".\";\nconst COMMA = \",\";\nconst SPACE = \" \";\nconst MINUS = \"-\";\n\nconst EXPONENT_REGEX = /[eE][\\-+]?[0-9]+/;\nconst NON_BREAKING_SPACE_REGEX = /\\u00A0/g;\nconst WHITESPACE_REGEX = /\\s/g;\n\nexport class NumberParserService implements INumberParserService {\n    constructor(private cultureService: ICultureService) {}\n\n    /**\n     * Parse a string value as an integer according to culture settings\n     */\n    parseInt(value: string | number | null | undefined, culture?: string | Culture): number | null {\n        const result = this.parseFloat(value, culture);\n        if (result) {\n            return result | 0;\n        }\n        return result;\n    }\n\n    /**\n     * Parse a string value as a float according to culture settings\n     */\n    parseFloat(value: string | number | null | undefined, culture?: string | Culture, format?: string): number | null {\n        if (!value && value !== 0) {\n            return null;\n        }\n\n        if (typeof value === \"number\") {\n            return value;\n        }\n\n        let strValue = value.toString();\n        const resolvedCulture = this.cultureService.getCulture(culture);\n\n        let numberFormat = resolvedCulture.numberFormat;\n        const percent = numberFormat.percent;\n        const currency = numberFormat.currency;\n        const percentSymbol = percent.symbol;\n        let symbol = currency.symbol;\n        let negative = strValue.indexOf(MINUS);\n        let parts: string[];\n        let isPercent = false;\n\n        // Handle exponential number\n        if (EXPONENT_REGEX.test(strValue)) {\n            const parsed = parseFloat(strValue.replace(numberFormat[DOT], DOT));\n            if (isNaN(parsed)) {\n                return null;\n            }\n            return parsed;\n        }\n\n        if (negative > 0) {\n            return null;\n        } else {\n            negative = negative > -1 ? 1 : 0;\n        }\n\n        if (strValue.indexOf(symbol) > -1 || (format && format.toLowerCase().indexOf(\"c\") > -1)) {\n            numberFormat = currency as any;\n            parts = numberFormat.pattern[0].replace(\"$\", symbol).split(\"n\");\n            if (strValue.indexOf(parts[0]) > -1 && strValue.indexOf(parts[1]) > -1) {\n                strValue = strValue.replace(parts[0], \"\").replace(parts[1], \"\");\n                negative = 1;\n            }\n        } else if (strValue.indexOf(percentSymbol) > -1) {\n            isPercent = true;\n            numberFormat = percent as any;\n            symbol = percentSymbol;\n        }\n\n        strValue = strValue\n            .replace(MINUS, \"\")\n            .replace(symbol, \"\")\n            .replace(NON_BREAKING_SPACE_REGEX, SPACE)\n            .split(numberFormat[COMMA].replace(NON_BREAKING_SPACE_REGEX, SPACE)).join(\"\")\n            .replace(WHITESPACE_REGEX, \"\")\n            .replace(numberFormat[DOT], DOT);\n\n        let result: number | null = parseFloat(strValue);\n\n        if (isNaN(result)) {\n            result = null;\n        } else if (negative) {\n            result *= -1;\n        }\n\n        if (result && isPercent) {\n            result /= 100;\n        }\n\n        return result;\n    }\n}\n","import { Culture, ICultureService, CalendarStandard } from \"../models/culture\";\nimport { IDateParserService } from \"../models/parser\";\n\nconst DATE_OBJECT = \"[object Date]\";\nconst objectToString = {}.toString;\n\nconst SHORT_TIMEZONE_REGEX = /[+|\\-]\\d{1,2}/;\nconst LONG_TIMEZONE_REGEX = /[+|\\-]\\d{1,2}:?\\d{2}/;\nconst MICROSOFT_DATE_REGEX = /^\\/Date\\((.*?)\\)\\/$/;\nconst OFFSET_REGEX = /[+-]\\d*/;\n\nconst FORMATS_SEQUENCE = [[], [\"G\", \"g\", \"F\"], [\"D\", \"d\", \"y\", \"m\", \"T\", \"t\"]];\nconst STANDARD_FORMATS = [\n    [\n        \"yyyy-MM-ddTHH:mm:ss.fffffffzzz\",\n        \"yyyy-MM-ddTHH:mm:ss.fffffff\",\n        \"yyyy-MM-ddTHH:mm:ss.fffzzz\",\n        \"yyyy-MM-ddTHH:mm:ss.fff\",\n        \"ddd MMM dd yyyy HH:mm:ss\",\n        \"yyyy-MM-ddTHH:mm:sszzz\",\n        \"yyyy-MM-ddTHH:mmzzz\",\n        \"yyyy-MM-ddTHH:mmzz\",\n        \"yyyy-MM-ddTHH:mm:ss\",\n        \"yyyy-MM-dd HH:mm:ss\",\n        \"yyyy/MM/dd HH:mm:ss\"\n    ],\n    [\n        \"yyyy-MM-ddTHH:mm\",\n        \"yyyy-MM-dd HH:mm\",\n        \"yyyy/MM/dd HH:mm\"\n    ],\n    [\n        \"yyyy/MM/dd\",\n        \"yyyy-MM-dd\",\n        \"HH:mm:ss\",\n        \"HH:mm\"\n    ]\n];\n\nconst NUMBER_REGEX: { [key: string]: RegExp } = {\n    2: /^\\d{1,2}/,\n    3: /^\\d{1,3}/,\n    4: /^\\d{4}/,\n    exact3: /^\\d{3}/\n};\n\ninterface TimezoneService {\n    apply(date: Date, offset: number): Date;\n    convert(date: Date, fromOffset: number, toOffset: number): Date;\n}\n\nexport class DateParserService implements IDateParserService {\n    private timezoneService: TimezoneService | null = null;\n\n    constructor(\n        private cultureService: ICultureService,\n        private roundFn: (value: number, precision: number) => string\n    ) {}\n\n    /**\n     * Set the timezone service (injected later due to circular dependency)\n     */\n    setTimezoneService(timezoneService: TimezoneService): void {\n        this.timezoneService = timezoneService;\n    }\n\n    /**\n     * Parse a date string according to specified formats and culture\n     */\n    parseDate(\n        value: string | Date | null | undefined,\n        formats?: string | string[],\n        culture?: string | Culture,\n        shouldUnpadZeros?: boolean\n    ): Date | null {\n        return this.internalParseDate(value, formats, culture, false, shouldUnpadZeros);\n    }\n\n    /**\n     * Parse a date string using exact format matching\n     */\n    parseExactDate(\n        value: string | Date | null | undefined,\n        formats?: string | string[],\n        culture?: string | Culture\n    ): Date | null {\n        return this.internalParseDate(value, formats, culture, true);\n    }\n\n    private internalParseDate(\n        value: string | Date | null | undefined,\n        formats: string | string[] | undefined,\n        culture: string | Culture | undefined,\n        strict: boolean,\n        shouldUnpadZeros?: boolean\n    ): Date | null {\n        if (objectToString.call(value) === DATE_OBJECT) {\n            return value as Date;\n        }\n\n        if (!value) {\n            return null;\n        }\n\n        const strValue = String(value);\n        let date: Date | null = null;\n        let tzoffset: RegExpExecArray | null;\n\n        // Handle Microsoft JSON date format: /Date(milliseconds)/\n        if (strValue.indexOf(\"/D\") === 0) {\n            const dateMatch = MICROSOFT_DATE_REGEX.exec(strValue);\n            if (dateMatch) {\n                let dateStr = dateMatch[1];\n                tzoffset = OFFSET_REGEX.exec(dateStr.substring(1));\n\n                date = new Date(parseInt(dateStr, 10));\n\n                if (tzoffset && this.timezoneService) {\n                    const offset = this.parseMicrosoftFormatOffset(tzoffset[0]);\n                    date = this.timezoneService.apply(date, 0);\n                    date = this.timezoneService.convert(date, 0, -1 * offset);\n                }\n\n                return date;\n            }\n        }\n\n        const resolvedCulture = this.cultureService.getCulture(culture);\n\n        let formatArray: string[];\n        if (!formats) {\n            formatArray = this.getDefaultFormats(resolvedCulture);\n        } else {\n            formatArray = Array.isArray(formats) ? formats : [formats];\n        }\n\n        for (let idx = 0; idx < formatArray.length; idx++) {\n            date = this.parseExact(strValue, formatArray[idx], resolvedCulture, strict, shouldUnpadZeros);\n            if (date) {\n                return date;\n            }\n        }\n\n        return date;\n    }\n\n    private parseExact(\n        value: string,\n        format: string,\n        culture: Culture,\n        strict: boolean,\n        shouldUnpadZeros?: boolean\n    ): Date | null {\n        if (!value) {\n            return null;\n        }\n\n        const calendar = culture.calendars.standard;\n        let idx = 0;\n        let valueIdx = 0;\n\n        const lookAhead = (match: string): number => {\n            let i = 0;\n            while (format[idx] === match) {\n                i++;\n                idx++;\n            }\n            if (i > 0) {\n                idx -= 1;\n            }\n            return i;\n        };\n\n        const getNumber = (size: number): number | null => {\n            let part = \"\";\n            if (size === 2) {\n                for (let i = 0; i <= size; i++) {\n                    part += value[valueIdx + i] || \"\";\n                }\n            }\n\n            // If the value comes in the form of 021, 022, 023 we must trim the leading zero\n            if (shouldUnpadZeros && part.match(NUMBER_REGEX.exact3) && Number.isInteger(Number(part)) && Number(part) > 0) {\n                part = this.unpadZero(part);\n            } else {\n                part = value.substr(valueIdx, size);\n            }\n\n            const rg = NUMBER_REGEX[size] || new RegExp('^\\\\d{1,' + size + '}');\n            const match = part.match(rg);\n\n            if (match) {\n                const matchStr = match[0];\n                valueIdx += matchStr.length;\n                return parseInt(matchStr, 10);\n            }\n            return null;\n        };\n\n        const getIndexByName = (names: string[], lower: boolean, subLength?: number): number | null => {\n            let matchLength = 0;\n            let matchIdx = 0;\n\n            for (let i = 0; i < names.length; i++) {\n                const name = names[i];\n                const nameLength = name.length;\n                let subValue = value.substr(valueIdx, subLength || nameLength);\n\n                if (lower) {\n                    subValue = subValue.toLowerCase();\n                }\n\n                if (subValue === name && nameLength > matchLength) {\n                    matchLength = nameLength;\n                    matchIdx = i;\n                }\n            }\n\n            if (matchLength) {\n                valueIdx += matchLength;\n                return matchIdx + 1;\n            }\n\n            return null;\n        };\n\n        const checkLiteral = (): boolean => {\n            if (value.charAt(valueIdx) === format[idx]) {\n                valueIdx++;\n                return true;\n            }\n            return false;\n        };\n\n        let year: number | null = null;\n        let month: number | null = null;\n        let day: number | null = null;\n        let hours: number | null = null;\n        let minutes: number | null = null;\n        let seconds: number | null = null;\n        let milliseconds: number | null = null;\n        let literal = false;\n        const date = new Date();\n        const twoDigitYearMax = calendar.twoDigitYearMax || 2029;\n        const defaultYear = date.getFullYear();\n        let pmHour: number | null = null;\n        let UTC: boolean | undefined;\n        let hoursOffset: number | null = null;\n        let minutesOffset: number | null = null;\n\n        if (!format) {\n            format = \"d\";\n        }\n\n        // If format is part of the patterns get real format\n        const pattern = (calendar.patterns as any)[format];\n        if (pattern) {\n            format = pattern;\n        }\n\n        const formatChars = format.split(\"\");\n        const length = formatChars.length;\n\n        // Ensure lower case versions exist\n        if (!(calendar as any)._lowerDays) {\n            (calendar as any)._lowerDays = this.lowerLocalInfo(calendar.days);\n        }\n        if (!(calendar as any)._lowerMonths) {\n            (calendar as any)._lowerMonths = this.lowerLocalInfo(calendar.months);\n        }\n\n        for (; idx < length; idx++) {\n            const ch = formatChars[idx];\n\n            if (literal) {\n                if (ch === \"'\") {\n                    literal = false;\n                } else {\n                    checkLiteral();\n                }\n            } else {\n                if (ch === \"d\") {\n                    const count = lookAhead(\"d\");\n\n                    if (day !== null && count > 2) {\n                        continue;\n                    }\n\n                    day = count < 3\n                        ? getNumber(2)\n                        : getIndexByName((calendar as any)._lowerDays[count === 3 ? \"namesAbbr\" : \"names\"], true);\n\n                    if (day === null || this.outOfRange(day, 1, 31)) {\n                        return null;\n                    }\n                } else if (ch === \"M\") {\n                    const count = lookAhead(\"M\");\n\n                    month = count < 3\n                        ? getNumber(2)\n                        : getIndexByName((calendar as any)._lowerMonths[count === 3 ? \"namesAbbr\" : \"names\"], true);\n\n                    if (month === null || this.outOfRange(month, 1, 12)) {\n                        return null;\n                    }\n                    month -= 1; // Month is zero based\n                } else if (ch === \"y\") {\n                    const count = lookAhead(\"y\");\n                    year = getNumber(count);\n\n                    if (year === null) {\n                        return null;\n                    }\n\n                    if (count === 2) {\n                        let maxYear = twoDigitYearMax;\n                        if (typeof maxYear === \"string\") {\n                            maxYear = defaultYear + parseInt(maxYear, 10);\n                        }\n\n                        year = (defaultYear - defaultYear % 100) + year;\n                        if (year > maxYear) {\n                            year -= 100;\n                        }\n                    }\n                } else if (ch === \"h\") {\n                    lookAhead(\"h\");\n                    hours = getNumber(2);\n                    if (hours === 12) {\n                        hours = 0;\n                    }\n                    if (hours === null || this.outOfRange(hours, 0, 11)) {\n                        return null;\n                    }\n                } else if (ch === \"H\") {\n                    lookAhead(\"H\");\n                    hours = getNumber(2);\n                    if (hours === null || this.outOfRange(hours, 0, 23)) {\n                        return null;\n                    }\n                } else if (ch === \"m\") {\n                    lookAhead(\"m\");\n                    minutes = getNumber(2);\n                    if (minutes === null || this.outOfRange(minutes, 0, 59)) {\n                        return null;\n                    }\n                } else if (ch === \"s\") {\n                    lookAhead(\"s\");\n                    seconds = getNumber(2);\n                    if (seconds === null || this.outOfRange(seconds, 0, 59)) {\n                        return null;\n                    }\n                } else if (ch === \"f\") {\n                    const count = lookAhead(\"f\");\n                    const match = value.substr(valueIdx, count).match(NUMBER_REGEX[3]);\n                    milliseconds = getNumber(count);\n\n                    if (milliseconds !== null && match) {\n                        let ms = parseFloat(\"0.\" + match[0]);\n                        ms = parseFloat(this.roundFn(ms, 3));\n                        milliseconds = ms * 1000;\n                    }\n\n                    if (milliseconds === null || this.outOfRange(milliseconds, 0, 999)) {\n                        return null;\n                    }\n                } else if (ch === \"t\") {\n                    const count = lookAhead(\"t\");\n                    let amDesignators = calendar.AM;\n                    let pmDesignators = calendar.PM;\n\n                    if (count === 1) {\n                        amDesignators = this.mapDesignators(amDesignators);\n                        pmDesignators = this.mapDesignators(pmDesignators);\n                    }\n\n                    pmHour = getIndexByName(pmDesignators, false, this.longestStringLength(pmDesignators));\n                    if (!pmHour && !getIndexByName(amDesignators, false, this.longestStringLength(amDesignators))) {\n                        return null;\n                    }\n                } else if (ch === \"z\") {\n                    UTC = true;\n                    const count = lookAhead(\"z\");\n\n                    if (value.substr(valueIdx, 1) === \"Z\") {\n                        checkLiteral();\n                        continue;\n                    }\n\n                    const matches = value.substr(valueIdx, 6).match(count > 2 ? LONG_TIMEZONE_REGEX : SHORT_TIMEZONE_REGEX);\n\n                    if (!matches) {\n                        return null;\n                    }\n\n                    const matchParts = matches[0].split(\":\");\n                    let hoursOffsetStr = matchParts[0];\n                    let minutesOffsetStr = matchParts[1];\n\n                    if (!minutesOffsetStr && hoursOffsetStr.length > 3) {\n                        valueIdx = hoursOffsetStr.length - 2;\n                        minutesOffsetStr = hoursOffsetStr.substring(valueIdx);\n                        hoursOffsetStr = hoursOffsetStr.substring(0, valueIdx);\n                    }\n\n                    hoursOffset = parseInt(hoursOffsetStr, 10);\n                    if (this.outOfRange(hoursOffset, -12, 13)) {\n                        return null;\n                    }\n\n                    if (count > 2) {\n                        minutesOffsetStr = matchParts[0][0] + minutesOffsetStr;\n                        minutesOffset = parseInt(minutesOffsetStr, 10);\n                        if (isNaN(minutesOffset) || this.outOfRange(minutesOffset, -59, 59)) {\n                            return null;\n                        }\n                    }\n                } else if (ch === \"'\") {\n                    literal = true;\n                    checkLiteral();\n                } else if (!checkLiteral()) {\n                    return null;\n                }\n            }\n        }\n\n        // If more characters follow, assume wrong format (strict mode)\n        if (strict && !/^\\s*$/.test(value.substr(valueIdx))) {\n            return null;\n        }\n\n        const hasTime = hours !== null || minutes !== null || seconds !== null;\n\n        if (year === null && month === null && day === null && hasTime) {\n            year = defaultYear;\n            month = date.getMonth();\n            day = date.getDate();\n        } else {\n            if (year === null) {\n                year = defaultYear;\n            }\n            if (day === null) {\n                day = 1;\n            }\n        }\n\n        if (pmHour && hours !== null && hours < 12) {\n            hours += 12;\n        }\n\n        let result: Date;\n        if (UTC) {\n            if (hoursOffset && hours !== null) {\n                hours += -hoursOffset;\n            }\n            if (minutesOffset && minutes !== null) {\n                minutes += -minutesOffset;\n            }\n            result = new Date(Date.UTC(year!, month ?? 0, day, hours ?? 0, minutes ?? 0, seconds ?? 0, milliseconds ?? 0));\n        } else {\n            result = new Date(year!, month ?? 0, day, hours ?? 0, minutes ?? 0, seconds ?? 0, milliseconds ?? 0);\n            this.adjustDST(result, hours);\n        }\n\n        if (year! < 100) {\n            result.setFullYear(year!);\n        }\n\n        if (result.getDate() !== day && UTC === undefined) {\n            return null;\n        }\n\n        return result;\n    }\n\n    private parseMicrosoftFormatOffset(offset: string): number {\n        const sign = offset.substr(0, 1) === \"-\" ? -1 : 1;\n        offset = offset.substring(1);\n        const result = (parseInt(offset.substr(0, 2), 10) * 60) + parseInt(offset.substring(2), 10);\n        return sign * result;\n    }\n\n    private getDefaultFormats(culture: Culture): string[] {\n        const length = Math.max(FORMATS_SEQUENCE.length, STANDARD_FORMATS.length);\n        const calendar = culture.calendar || culture.calendars.standard;\n        const patterns = calendar.patterns;\n        const formats: string[] = [];\n\n        for (let idx = 0; idx < length; idx++) {\n            const cultureFormats = FORMATS_SEQUENCE[idx] || [];\n            for (let formatIdx = 0; formatIdx < cultureFormats.length; formatIdx++) {\n                formats.push((patterns as any)[cultureFormats[formatIdx]]);\n            }\n            formats.push(...(STANDARD_FORMATS[idx] || []));\n        }\n\n        return formats;\n    }\n\n    private outOfRange(value: number, start: number, end: number): boolean {\n        return !(value >= start && value <= end);\n    }\n\n    private adjustDST(date: Date, hours: number | null): void {\n        if (!hours && date.getHours() === 23) {\n            date.setHours(date.getHours() + 2);\n        }\n    }\n\n    private lowerLocalInfo(data: { names: string[]; namesAbbr: string[] }): { names: string[]; namesAbbr: string[] } {\n        return {\n            names: data.names.map(s => s.toLowerCase()),\n            namesAbbr: data.namesAbbr.map(s => s.toLowerCase())\n        };\n    }\n\n    private unpadZero(value: string): string {\n        return value.replace(/^0*/, '');\n    }\n\n    private mapDesignators(designators: string[]): string[] {\n        return designators.map(d => d.charAt(0));\n    }\n\n    private longestStringLength(strings: string[]): number {\n        return strings.reduce((max, s) => Math.max(max, s.length), 0);\n    }\n}\n","import { Culture, ICultureService } from \"../models/culture\";\nimport { IntlCultureAdapter, IntlLocaleInfo, IKendoCultureToIntlService } from \"../models/intl\";\nimport { IDateParserService } from \"../models/parser\";\nimport { IFormatterService } from \"../models/formatter\";\n\n/**\n * Service that converts Kendo cultures to Intl-compatible format\n * Used for integration with @progress/kendo-intl\n */\nexport class KendoCultureToIntlService implements IKendoCultureToIntlService {\n    constructor(\n        private cultureService: ICultureService,\n        private dateParser: IDateParserService,\n        private formatter: IFormatterService\n    ) {}\n\n    /**\n     * Convert a Kendo culture to an Intl-compatible adapter\n     */\n    convert(culture?: string | Culture): IntlCultureAdapter {\n        const kendoCulture = this.cultureService.getCulture(culture) || this.cultureService.culture();\n        \n        const currencies: { [key: string]: any } = {};\n        currencies[kendoCulture.numberFormat.currency.abbr] = kendoCulture.numberFormat.currency;\n        \n        const localeInfoAll = this.buildLocaleInfoAll(kendoCulture, currencies);\n        \n        return {\n            localeInfo: () => this.buildLocaleInfo(kendoCulture, currencies),\n            parseDate: (value: string, fmt?: string) => this.dateParser.parseExactDate(value, fmt, kendoCulture),\n            toString: (value: any, fmt?: string) => {\n                const result = this.formatter.toString(value, fmt, kendoCulture);\n                // Coerce to string for Intl adapter compatibility\n                return result == null ? \"\" : String(result);\n            },\n            format: (fmt: string, ...values: any[]) => this.formatter.format(fmt, ...values)\n        };\n    }\n\n    private buildLocaleInfo(kendoCulture: Culture, currencies: { [key: string]: any }): IntlLocaleInfo {\n        return {\n            numbers: {\n                localeCurrency: kendoCulture.numberFormat.currency.abbr,\n                currencies: currencies,\n                symbols: {\n                    group: kendoCulture.numberFormat[','],\n                    decimal: kendoCulture.numberFormat['.'],\n                    percentSign: kendoCulture.numberFormat.percent.symbol,\n                }\n            },\n            calendar: {\n                patterns: kendoCulture.calendars.standard.patterns,\n                months: {\n                    format: {\n                        wide: kendoCulture.calendars.standard.months.names,\n                        abbreviated: kendoCulture.calendars.standard.months.namesAbbr\n                    }\n                },\n                days: {\n                    format: {\n                        wide: kendoCulture.calendars.standard.days.names,\n                        abbreviated: kendoCulture.calendars.standard.days.namesAbbr\n                    }\n                }\n            }\n        };\n    }\n\n    private buildLocaleInfoAll(kendoCulture: Culture, currencies: { [key: string]: any }): any {\n        const localeInfoAll: any = {};\n\n        // Extract the name and split into language and territory if possible\n        const [language, territory] = kendoCulture.name.split('-');\n        localeInfoAll.name = language;\n        localeInfoAll.identity = { language };\n        if (territory) {\n            localeInfoAll.territory = territory;\n        }\n\n        // Map number format symbols\n        if (kendoCulture.numberFormat) {\n            localeInfoAll.numbers = {\n                symbols: {\n                    decimal: kendoCulture.numberFormat[\".\"],\n                    group: kendoCulture.numberFormat[\",\"],\n                    percentSign: kendoCulture.numberFormat.percent?.symbol || \"%\"\n                },\n                decimal: {\n                    patterns: kendoCulture.numberFormat.pattern,\n                    groupSize: kendoCulture.numberFormat.groupSize\n                },\n                currency: {\n                    patterns: kendoCulture.numberFormat.currency?.pattern,\n                    groupSize: kendoCulture.numberFormat.currency?.groupSize\n                },\n                percent: {\n                    patterns: kendoCulture.numberFormat.percent?.pattern,\n                    groupSize: kendoCulture.numberFormat.percent?.groupSize,\n                    decimals: kendoCulture.numberFormat.percent?.decimals\n                }\n            };\n\n            // Map currency information if available\n            if (kendoCulture.numberFormat.currency) {\n                localeInfoAll.numbers.currencies = {\n                    [kendoCulture.numberFormat.currency.abbr]: kendoCulture.numberFormat.currency\n                };\n                localeInfoAll.numbers.localeCurrency = kendoCulture.numberFormat.currency.abbr;\n            }\n        }\n\n        // Map calendar information\n        if (kendoCulture.calendars && kendoCulture.calendars.standard) {\n            const standardCalendar = kendoCulture.calendars.standard;\n            localeInfoAll.calendar = {\n                patterns: {\n                    d: standardCalendar.patterns.d,\n                    D: standardCalendar.patterns.D,\n                    F: standardCalendar.patterns.F,\n                    g: standardCalendar.patterns.g,\n                    G: standardCalendar.patterns.G,\n                    m: standardCalendar.patterns.m,\n                    M: standardCalendar.patterns.M,\n                    s: standardCalendar.patterns.s,\n                    t: standardCalendar.patterns.t,\n                    T: standardCalendar.patterns.T,\n                    u: standardCalendar.patterns.u,\n                    y: standardCalendar.patterns.y,\n                    Y: standardCalendar.patterns.Y\n                },\n                days: {\n                    format: {\n                        wide: standardCalendar.days.names,\n                        abbreviated: standardCalendar.days.namesAbbr,\n                        short: standardCalendar.days.namesShort\n                    },\n                    \"stand-alone\": {\n                        wide: standardCalendar.days.names,\n                        abbreviated: standardCalendar.days.namesAbbr,\n                        short: standardCalendar.days.namesShort\n                    }\n                },\n                months: {\n                    format: {\n                        wide: standardCalendar.months.names,\n                        abbreviated: standardCalendar.months.namesAbbr,\n                        narrow: standardCalendar.months.namesAbbr.map((name: string) => name.charAt(0))\n                    },\n                    \"stand-alone\": {\n                        wide: standardCalendar.months.names,\n                        abbreviated: standardCalendar.months.namesAbbr,\n                        narrow: standardCalendar.months.namesAbbr.map((name: string) => name.charAt(0))\n                    }\n                },\n                dayPeriods: {\n                    format: {\n                        abbreviated: {\n                            am: standardCalendar.AM[0],\n                            pm: standardCalendar.PM[0]\n                        },\n                        narrow: {\n                            am: standardCalendar.AM[1],\n                            pm: standardCalendar.PM[1]\n                        },\n                        wide: {\n                            am: standardCalendar.AM[0],\n                            pm: standardCalendar.PM[0]\n                        }\n                    },\n                    \"stand-alone\": {\n                        abbreviated: {\n                            am: standardCalendar.AM[0],\n                            pm: standardCalendar.PM[0]\n                        },\n                        narrow: {\n                            am: standardCalendar.AM[1],\n                            pm: standardCalendar.PM[1]\n                        },\n                        wide: {\n                            am: standardCalendar.AM[0],\n                            pm: standardCalendar.PM[0]\n                        }\n                    }\n                }\n            };\n\n            // Include firstDay if defined\n            if ('firstDay' in standardCalendar) {\n                localeInfoAll.firstDay = standardCalendar.firstDay;\n            }\n        }\n\n        return localeInfoAll;\n    }\n}\n","import { TemplateOptions, CompiledTemplate, ITemplateService } from \"../models/template\";\nimport type { IFormatterService } from \"../models/formatter\";\n\n// Regex patterns for template parsing\nconst argumentNameRegExp = /^\\w+/;\nconst encodeRegExp = /\\$\\{([^}]*)\\}/g;\nconst escapedCurlyRegExp = /\\\\\\}/g;\nconst curlyRegExp = /__CURLY__/g;\nconst escapedSharpRegExp = /\\\\#/g;\nconst sharpRegExp = /__SHARP__/g;\n\n/**\n * Compile a template part (either string literal or code)\n */\nfunction compilePart(part: string, stringPart: boolean): string {\n    if (stringPart) {\n        return \"'\" +\n            part.split(\"'\").join(\"\\\\'\")\n                .split('\\\\\"').join('\\\\\\\\\\\\\"')\n                .replace(/\\n/g, \"\\\\n\")\n                .replace(/\\r/g, \"\\\\r\")\n                .replace(/\\t/g, \"\\\\t\") + \"'\";\n    } else {\n        const first = part.charAt(0);\n        const rest = part.substring(1);\n\n        if (first === \"=\") {\n            return \"+(\" + rest + \")+\";\n        } else if (first === \":\") {\n            return \"+$kendoHtmlEncode(\" + rest + \")+\";\n        } else {\n            return \";\" + part + \";$kendoOutput+=\";\n        }\n    }\n}\n\n/**\n * Template service for compiling and rendering Kendo UI templates\n * \n * Supports the legacy Kendo template syntax:\n * - #= expression # - Output expression result\n * - #: expression # - Output HTML-encoded expression result\n * - # code # - Execute JavaScript code\n */\nexport class TemplateService implements ITemplateService {\n    paramName = \"data\";\n    useWithBlock = true;\n    private debugTemplates = false;\n\n    constructor(private formatterService: IFormatterService) {}\n\n    /**\n     * Enable or disable template debugging\n     */\n    setDebugMode(enabled: boolean): void {\n        this.debugTemplates = enabled;\n    }\n\n    /**\n     * Render a template with an array of data items\n     */\n    render(template: CompiledTemplate, data: any[]): string {\n        let html = \"\";\n        for (let idx = 0; idx < data.length; idx++) {\n            html += template(data[idx]);\n        }\n        return html;\n    }\n\n    /**\n     * Compile a template string into a function\n     */\n    compile(template: string | CompiledTemplate, options?: TemplateOptions): CompiledTemplate {\n        // If already a function, return as-is\n        if (typeof template === \"function\") {\n            return template;\n        }\n\n        // Use options values only if they're not undefined (matches original jQuery extend behavior)\n        const settings = {\n            paramName: options?.paramName !== undefined ? options.paramName : this.paramName,\n            useWithBlock: options?.useWithBlock !== undefined ? options.useWithBlock : this.useWithBlock\n        };\n\n        const paramName = settings.paramName;\n        const argumentName = paramName.match(argumentNameRegExp)![0];\n        const useWithBlock = settings.useWithBlock;\n\n        let functionBody = \"var $kendoOutput, $kendoHtmlEncode = kendo.htmlEncode;\";\n        \n        functionBody += useWithBlock ? \"with(\" + paramName + \"){\" : \"\";\n        functionBody += \"$kendoOutput=\";\n\n        const parts = template\n            .replace(escapedCurlyRegExp, \"__CURLY__\")\n            .replace(encodeRegExp, \"#=$kendoHtmlEncode($1)#\")\n            .replace(curlyRegExp, \"}\")\n            .replace(escapedSharpRegExp, \"__SHARP__\")\n            .split(\"#\");\n\n        for (let idx = 0; idx < parts.length; idx++) {\n            functionBody += compilePart(parts[idx], idx % 2 === 0);\n        }\n\n        functionBody += useWithBlock ? \";}\" : \";\";\n        functionBody += \"return $kendoOutput;\";\n        functionBody = functionBody.replace(sharpRegExp, \"#\");\n\n        try {\n            // This function evaluation is required for legacy support of the Kendo Template syntax - non CSP compliant.\n            // NOSONAR - It is a valid security concern, however this is required for backward compatibility\n            const fn = new Function(argumentName, functionBody) as CompiledTemplate;\n            fn._slotCount = Math.floor(parts.length / 2);\n            return fn;\n        } catch (e) {\n            if (this.debugTemplates) {\n                console.warn(`Invalid template:'${template}' Generated code:'${functionBody}'`);\n                // Return a no-op function in debug mode\n                return (() => \"\") as CompiledTemplate;\n            } else {\n                throw new Error(this.formatterService.format(\"Invalid template:'{0}' Generated code:'{1}'\", template, functionBody));\n            }\n        }\n    }\n}\n","import type { \n    ISupportService, \n    MobileOS, \n    BrowserInfo, \n    TransformSupport, \n    InputTypeSupport, \n    ClipboardSupport \n} from \"../models/support\";\n\nconst UNDEFINED = \"undefined\";\n\n/**\n * Test a value against a set of regex patterns\n */\nfunction testRx(agent: string, rxs: Record<string, RegExp>, dflt?: string | false): string | false {\n    for (const rx in rxs) {\n        if (rxs.hasOwnProperty(rx) && rxs[rx].test(agent)) {\n            return rx;\n        }\n    }\n    return dflt !== undefined ? dflt : agent;\n}\n\n/**\n * Support detection service for browser, OS, and feature detection\n */\nexport class SupportService implements ISupportService {\n    _scrollbar: number | undefined = undefined;\n    \n    browser!: BrowserInfo;\n    mobileOS!: MobileOS | false;\n    \n    touch!: boolean;\n    tbodyInnerHtml!: boolean;\n    transforms!: TransformSupport;\n    transitions!: TransformSupport;\n    hasHW3D!: boolean;\n    cssFlexbox!: boolean;\n    cssFloat!: boolean;\n    devicePixelRatio!: number;\n    screenWidth!: number;\n    screenHeight!: number;\n    wpDevicePixelRatio!: number;\n    hasNativeScrolling!: MobileOS | false;\n    mouseAndTouchPresent!: boolean;\n    clipboard!: ClipboardSupport;\n    eventCapture!: boolean;\n    placeholder!: boolean;\n    propertyChangeEvent!: boolean;\n    input!: InputTypeSupport;\n    stableSort!: boolean;\n    matchesSelector!: (selector: string) => boolean;\n    matchMedia!: boolean;\n    pushState!: boolean;\n    hashChange!: boolean;\n    customElements!: boolean;\n    msPointers!: boolean;\n    pointers!: boolean;\n    kineticScrollNeeded!: boolean;\n    resize!: string;\n    mousedown!: string;\n    mouseup!: string;\n    mousemove!: string;\n    mousecancel!: string;\n    click!: string;\n\n    private $: JQueryStatic;\n\n    constructor($: JQueryStatic) {\n        this.$ = $;\n        \n        // Bind methods to ensure correct 'this' context when called as standalone functions\n        this.scrollbar = this.scrollbar.bind(this);\n        this.isRtl = this.isRtl.bind(this);\n        this.detectOS = this.detectOS.bind(this);\n        this.detectBrowser = this.detectBrowser.bind(this);\n        this.detectClipboardAccess = this.detectClipboardAccess.bind(this);\n        this.zoomLevel = this.zoomLevel.bind(this);\n        this.delayedClick = this.delayedClick.bind(this);\n        \n        this.initialize();\n    }\n\n    private initialize(): void {\n        const $ = this.$;\n        const win = window as any;\n        const doc = document;\n        const nav = navigator;\n\n        // Table innerHTML support test\n        const table = doc.createElement(\"table\");\n        try {\n            table.innerHTML = \"<tr><td></td></tr>\";\n            this.tbodyInnerHtml = true;\n        } catch (e) {\n            this.tbodyInnerHtml = false;\n        }\n\n        // Touch support\n        this.touch = \"ontouchstart\" in win;\n\n        const docStyle = doc.documentElement.style;\n        const elementProto: any = \"HTMLElement\" in win ? HTMLElement.prototype : [];\n\n        // Transforms and Transitions - legacy properties kept for compatibility\n        this.transforms = this.transitions = { css: \"\", prefix: \"\", event: \"transitionend\" };\n        this.hasHW3D = (\"WebKitCSSMatrix\" in win && \"m11\" in new win.WebKitCSSMatrix()) || \n                       \"MozPerspective\" in docStyle || \n                       \"msPerspective\" in docStyle;\n        this.cssFlexbox = (\"flexWrap\" in docStyle) || \n                          (\"WebkitFlexWrap\" in docStyle) || \n                          (\"msFlexWrap\" in docStyle);\n\n        this.devicePixelRatio = win.devicePixelRatio === undefined ? 1 : win.devicePixelRatio;\n\n        try {\n            this.screenWidth = win.outerWidth || win.screen ? win.screen.availWidth : win.innerWidth;\n            this.screenHeight = win.outerHeight || win.screen ? win.screen.availHeight : win.innerHeight;\n        } catch (e) {\n            // window.outerWidth throws error when in IE showModalDialog\n            this.screenWidth = win.screen.availWidth;\n            this.screenHeight = win.screen.availHeight;\n        }\n\n        // Detect mobile OS\n        let mobileOS = this.detectOS(nav.userAgent);\n        this.mobileOS = mobileOS;\n\n        this.wpDevicePixelRatio = mobileOS && mobileOS.wp ? screen.width / 320 : 0;\n\n        this.hasNativeScrolling = false;\n        if (mobileOS && (mobileOS.ios || (mobileOS.android && parseInt(mobileOS.majorVersion) > 2) || mobileOS.wp)) {\n            this.hasNativeScrolling = mobileOS;\n        }\n\n        this.mouseAndTouchPresent = this.touch && !(mobileOS && (mobileOS.ios || mobileOS.android));\n\n        // Detect browser\n        this.browser = this.detectBrowser(nav.userAgent);\n\n        // Handle iPad detection for Safari on iPadOS 13+\n        if (!mobileOS && this.touch && this.browser.safari) {\n            mobileOS = this.mobileOS = {\n                ios: true,\n                tablet: \"tablet\",\n                device: \"ipad\",\n                majorVersion: \"13\",\n                minorVersion: \"0\",\n                flatVersion: \"1300\",\n                cordova: false,\n                appMode: false,\n                name: \"ios\",\n                browser: \"mobilesafari\"\n            };\n        }\n\n        // Clipboard support\n        this.clipboard = this.detectClipboardAccess();\n\n        // Event capture support\n        this.eventCapture = !!doc.documentElement.addEventListener;\n\n        // Input element feature detection\n        const input = doc.createElement(\"input\");\n        this.placeholder = \"placeholder\" in input;\n        this.propertyChangeEvent = \"onpropertychange\" in input;\n\n        // Input type support\n        this.input = this.detectInputTypes(input);\n\n        // CSS float support\n        input.style.cssText = \"float:left;\";\n        this.cssFloat = !!(input.style as any).cssFloat;\n\n        // Stable sort detection\n        this.stableSort = this.detectStableSort();\n\n        // Matches selector\n        this.matchesSelector = elementProto.webkitMatchesSelector || \n                               elementProto.mozMatchesSelector ||\n                               elementProto.msMatchesSelector || \n                               elementProto.oMatchesSelector ||\n                               elementProto.matchesSelector || \n                               elementProto.matches ||\n                               function(this: Element, selector: string): boolean {\n                                   const nodeList = doc.querySelectorAll ? \n                                       (this.parentNode || doc).querySelectorAll(selector) || [] : \n                                       $(selector);\n                                   let i = nodeList.length;\n                                   while (i--) {\n                                       if (nodeList[i] === this) {\n                                           return true;\n                                       }\n                                   }\n                                   return false;\n                               };\n\n        this.matchMedia = \"matchMedia\" in win;\n        this.pushState = !!(win.history && win.history.pushState);\n        this.hashChange = \"onhashchange\" in win;\n        this.customElements = \"registerElement\" in doc;\n\n        // Pointer event support\n        const chrome = this.browser.chrome;\n        const mobileChrome = this.browser.crios;\n        const mozilla = this.browser.mozilla;\n        const safari = this.browser.safari;\n        this.msPointers = !chrome && win.MSPointerEvent;\n        this.pointers = !chrome && !mobileChrome && !mozilla && !safari && win.PointerEvent;\n        this.kineticScrollNeeded = !!(mobileOS && \n            (mobileOS.device !== \"ipad\" || parseInt(mobileOS.majorVersion) < 13) && \n            (this.touch || this.msPointers || this.pointers));\n\n        // Set resize and mouse event name(s) based on device type\n        if (this.touch) {\n            if (!this.mobileOS) {\n                this.mousedown = \"mousedown touchstart\";\n                this.mouseup = \"mouseup touchend\";\n                this.mousemove = \"mousemove touchmove\";\n                this.mousecancel = \"mouseleave touchcancel\";\n                this.click = \"click\";\n                this.resize = \"resize\";\n            } else {\n                this.mousedown = \"touchstart\";\n                this.mouseup = \"touchend\";\n                this.mousemove = \"touchmove\";\n                this.mousecancel = \"touchcancel\";\n                this.click = \"touchend\";\n                this.resize = \"orientationchange\";\n            }\n        } else if (this.pointers) {\n            this.mousemove = \"pointermove\";\n            this.mousedown = \"pointerdown\";\n            this.mouseup = \"pointerup\";\n            this.mousecancel = \"pointercancel\";\n            this.click = \"pointerup\";\n            this.resize = \"orientationchange resize\";\n        } else if (this.msPointers) {\n            this.mousemove = \"MSPointerMove\";\n            this.mousedown = \"MSPointerDown\";\n            this.mouseup = \"MSPointerUp\";\n            this.mousecancel = \"MSPointerCancel\";\n            this.click = \"MSPointerUp\";\n            this.resize = \"orientationchange resize\";\n        } else {\n            this.mousemove = \"mousemove\";\n            this.mousedown = \"mousedown\";\n            this.mouseup = \"mouseup\";\n            this.mousecancel = \"mouseleave\";\n            this.click = \"click\";\n            this.resize = \"resize\";\n        }\n\n        // Add browser-specific CSS classes\n        this.addBrowserCssClasses($);\n    }\n\n    /**\n     * Get or calculate scrollbar width\n     */\n    scrollbar(refresh?: boolean): number {\n        if (!isNaN(this._scrollbar as number) && !refresh) {\n            return this._scrollbar as number;\n        }\n\n        const div = document.createElement(\"div\");\n        div.style.cssText = \"overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block\";\n        div.innerHTML = \"&nbsp;\";\n        document.body.appendChild(div);\n\n        this._scrollbar = div.offsetWidth - div.scrollWidth;\n        document.body.removeChild(div);\n\n        return this._scrollbar;\n    }\n\n    /**\n     * Check if element is in RTL context\n     */\n    isRtl(element: HTMLElement | JQuery): boolean {\n        return this.$(element).closest(\".k-rtl\").length > 0;\n    }\n\n    /**\n     * Detect mobile operating system from user agent\n     */\n    detectOS(ua: string): MobileOS | false {\n        let os: MobileOS | false = false;\n        let minorVersion: string;\n        let match: RegExpMatchArray | null = null;\n        const notAndroidPhone = !/mobile safari/i.test(ua);\n\n        const agentRxs: Record<string, RegExp> = {\n            wp: /(Windows Phone(?: OS)?)\\s(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            fire: /(Silk)\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            android: /(Android|Android.*(?:Opera|Firefox).*?\\/)\\s*(\\d+)\\.?(\\d+(\\.\\d+)?)?/,\n            iphone: /(iPhone|iPod).*OS\\s+(\\d+)[\\._]([\\d\\._]+)/,\n            ipad: /(iPad).*OS\\s+(\\d+)[\\._]([\\d_]+)/,\n            meego: /(MeeGo).+NokiaBrowser\\/(\\d+)\\.([\\d\\._]+)/,\n            webos: /(webOS)\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            blackberry: /(BlackBerry|BB10).*?Version\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            playbook: /(PlayBook).*?Tablet\\s*OS\\s*(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            windows: /(MSIE)\\s+(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            tizen: /(tizen).*?Version\\/(\\d+)\\.(\\d+(\\.\\d+)?)/i,\n            sailfish: /(sailfish).*rv:(\\d+)\\.(\\d+(\\.\\d+)?).*firefox/i,\n            ffos: /(Mobile).*rv:(\\d+)\\.(\\d+(\\.\\d+)?).*Firefox/\n        };\n\n        const osRxs: Record<string, RegExp> = {\n            ios: /^i(phone|pad|pod)$/i,\n            android: /^android|fire$/i,\n            blackberry: /^blackberry|playbook/i,\n            windows: /windows/,\n            wp: /wp/,\n            flat: /sailfish|ffos|tizen/i,\n            meego: /meego/\n        };\n\n        const formFactorRxs: Record<string, RegExp> = {\n            tablet: /playbook|ipad|fire/i\n        };\n\n        const browserRxs: Record<string, RegExp> = {\n            omini: /Opera\\sMini/i,\n            omobile: /Opera\\sMobi/i,\n            firefox: /Firefox|Fennec/i,\n            mobilesafari: /version\\/.*safari/i,\n            ie: /MSIE|Windows\\sPhone/i,\n            chrome: /chrome|crios/i,\n            webkit: /webkit/i,\n            edge: /edge|edg|edgios|edga/i\n        };\n\n        for (const agent in agentRxs) {\n            if (agentRxs.hasOwnProperty(agent)) {\n                match = ua.match(agentRxs[agent]);\n                if (match) {\n                    // Break if not Metro/Mobile Windows\n                    if (agent === \"windows\" && \"plugins\" in navigator) {\n                        return false;\n                    }\n\n                    os = {} as MobileOS;\n                    os.device = agent;\n                    os.tablet = testRx(agent, formFactorRxs, false) as string | false;\n                    os.browser = testRx(ua, browserRxs, \"default\") as string;\n                    os.name = testRx(agent, osRxs) as string;\n                    (os as any)[os.name] = true;\n                    os.majorVersion = match[2];\n                    os.minorVersion = (match[3] || \"0\").replace(\"_\", \".\");\n                    minorVersion = os.minorVersion.replace(\".\", \"\").substr(0, 2);\n                    os.flatVersion = os.majorVersion + minorVersion + \n                        (new Array(3 - (minorVersion.length < 3 ? minorVersion.length : 2)).join(\"0\"));\n                    os.cordova = typeof (window as any).PhoneGap !== UNDEFINED || \n                                 typeof (window as any).cordova !== UNDEFINED;\n                    os.appMode = !!(navigator as any).standalone || \n                                 (/file|local|wmapp/).test(window.location.protocol) || \n                                 os.cordova;\n\n                    if (os.android && \n                        (this.devicePixelRatio < 1.5 && parseInt(os.flatVersion) < 400 || notAndroidPhone) && \n                        (this.screenWidth > 800 || this.screenHeight > 800)) {\n                        os.tablet = agent;\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        return os;\n    }\n\n    /**\n     * Detect browser from user agent\n     */\n    detectBrowser(ua: string): BrowserInfo {\n        let browser: BrowserInfo | false = false;\n        let match: RegExpMatchArray | null;\n        let chromiumEdgeMatch: RegExpMatchArray | null;\n\n        const browserRxs: Record<string, RegExp> = {\n            edge: /(edge)[ \\/]([\\w.]+)/i,\n            webkit: /(chrome|crios)[ \\/]([\\w.]+)/i,\n            safari: /(webkit)[ \\/]([\\w.]+)/i,\n            opera: /(opera)(?:.*version|)[ \\/]([\\w.]+)/i,\n            msie: /(msie\\s|trident.*? rv:)([\\w.]+)/i,\n            mozilla: /(mozilla)(?:.*? rv:([\\w.]+)|)/i\n        };\n\n        for (const agent in browserRxs) {\n            if (browserRxs.hasOwnProperty(agent)) {\n                match = ua.match(browserRxs[agent]);\n                if (match) {\n                    browser = {} as BrowserInfo;\n                    (browser as any)[agent] = true;\n                    (browser as any)[match[1].toLowerCase().split(\" \")[0].split(\"/\")[0]] = true;\n                    browser.version = parseInt((document as any).documentMode || match[2], 10);\n\n                    if (browser.chrome) {\n                        chromiumEdgeMatch = ua.match(/(edg)[ \\/]([\\w.]+)/i);\n                        if (chromiumEdgeMatch) {\n                            browser.chromiumEdge = true;\n                        }\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        return browser || { version: 0 };\n    }\n\n    /**\n     * Detect clipboard command support\n     */\n    detectClipboardAccess(): ClipboardSupport {\n        const doc = document as any;\n        const commands: ClipboardSupport = {\n            copy: doc.queryCommandSupported ? doc.queryCommandSupported(\"copy\") : false,\n            cut: doc.queryCommandSupported ? doc.queryCommandSupported(\"cut\") : false,\n            paste: doc.queryCommandSupported ? doc.queryCommandSupported(\"paste\") : false\n        };\n\n        if (this.browser.chrome) {\n            // Not using queryCommandSupported due to chromium issues 476508 and 542948\n            commands.paste = false;\n            if (this.browser.version >= 43) {\n                commands.copy = true;\n                commands.cut = true;\n            }\n        }\n\n        return commands;\n    }\n\n    /**\n     * Get current zoom level\n     */\n    zoomLevel(): number {\n        try {\n            const browser = this.browser;\n            let ie11WidthCorrection = 0;\n            const docEl = document.documentElement;\n\n            if (browser.msie && browser.version === 11 && \n                docEl.scrollHeight > docEl.clientHeight && !this.touch) {\n                ie11WidthCorrection = this.scrollbar();\n            }\n\n            return this.touch ? \n                (docEl.clientWidth / window.innerWidth) :\n                (browser.msie && browser.version >= 10 ? \n                    ((((top || window) as any).document.documentElement.offsetWidth + ie11WidthCorrection) / \n                     ((top || window) as any).innerWidth) : \n                    1);\n        } catch (e) {\n            return 1;\n        }\n    }\n\n    /**\n     * Check if device has delayed click behavior\n     */\n    delayedClick(): boolean {\n        // Only mobile devices with touch events do this\n        if (this.touch) {\n            const mobileOS = this.mobileOS;\n            \n            // All iOS devices delay their click events\n            if (mobileOS && mobileOS.ios) {\n                return true;\n            }\n\n            if (mobileOS && mobileOS.android) {\n                // Older webkits and webviews delay the click\n                if (!this.browser.chrome) {\n                    return true;\n                }\n\n                // Chrome 32+ does conditional fast clicks\n                if (this.browser.version < 32) {\n                    return false;\n                }\n\n                // Check if viewport is user-scalable\n                const $ = this.$;\n                return !($(\"meta[name=viewport]\").attr(\"content\") || \"\").match(/user-scalable=no/i);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Detect native input type support\n     */\n    private detectInputTypes(input: HTMLInputElement): InputTypeSupport {\n        const types = [\"number\", \"date\", \"time\", \"month\", \"week\", \"datetime\", \"datetime-local\"];\n        const value = \"test\";\n        const result: any = {};\n\n        for (const type of types) {\n            input.setAttribute(\"type\", type);\n            input.value = value;\n            result[type.replace(\"-\", \"\")] = input.type !== \"text\" && input.value !== value;\n        }\n\n        return result as InputTypeSupport;\n    }\n\n    /**\n     * Detect if sort is stable\n     */\n    private detectStableSort(): boolean {\n        // Chrome sort is not stable for more than 10 items\n        // IE9+ sort is not stable for more than 512 items\n        const threshold = 513;\n\n        const sorted: Array<{ index: number; field: string }> = [{\n            index: 0,\n            field: \"b\"\n        }];\n\n        for (let i = 1; i < threshold; i++) {\n            sorted.push({\n                index: i,\n                field: \"a\"\n            });\n        }\n\n        sorted.sort((a, b) => {\n            return a.field > b.field ? 1 : (a.field < b.field ? -1 : 0);\n        });\n\n        return sorted[0].index === 1;\n    }\n\n    /**\n     * Add browser-specific CSS classes to document element\n     */\n    private addBrowserCssClasses($: JQueryStatic): void {\n        const browser = this.browser;\n        let cssClass = \"\";\n        const docElement = $(document.documentElement);\n        const majorVersion = parseInt(String(browser.version), 10);\n\n        if (browser.msie) {\n            cssClass = \"ie\";\n        } else if (browser.mozilla) {\n            cssClass = \"ff\";\n        } else if (browser.safari) {\n            cssClass = \"safari\";\n        } else if (browser.webkit) {\n            cssClass = \"webkit\";\n        } else if (browser.opera) {\n            cssClass = \"opera\";\n        } else if (browser.edge) {\n            cssClass = \"edge\";\n        }\n\n        if (cssClass) {\n            cssClass = \"k-\" + cssClass + \" k-\" + cssClass + majorVersion;\n        }\n\n        if (this.mobileOS) {\n            cssClass += \" k-mobile\";\n        }\n\n        if (!this.cssFlexbox) {\n            cssClass += \" k-no-flexbox\";\n        }\n\n        docElement.addClass(cssClass);\n    }\n\n    /**\n     * Convert Bootstrap breakpoint name to CSS media query\n     */\n    bootstrapToMedia(bootstrapMedia: string): string | undefined {\n        const bootstrapBreakpoints: Record<string, string> = {\n            \"xs\": \"(max-width: 576px)\",\n            \"sm\": \"(min-width: 576px)\",\n            \"md\": \"(min-width: 768px)\",\n            \"lg\": \"(min-width: 992px)\",\n            \"xl\": \"(min-width: 1200px)\"\n        };\n        return bootstrapBreakpoints[bootstrapMedia];\n    }\n\n    /**\n     * Check if a media query matches\n     * Supports both CSS media queries and Bootstrap breakpoint names\n     */\n    matchesMedia(mediaQuery: string): boolean {\n        const media = this.bootstrapToMedia(mediaQuery) || mediaQuery;\n        return this.matchMedia && window.matchMedia(media).matches;\n    }\n}\n","import { \n    IDateUtilsService, \n    DateFormatPart, \n    DateFormatNamesOptions, \n    DateFieldNameOptions,\n    DATE_FIELD_MAP,\n    NAME_TYPES\n} from \"../models/date-utils\";\nimport { ICultureService } from \"../models/culture\";\nimport { IFormatterService } from \"../models/formatter\";\n\n/**\n * Service providing date utility functions\n * Extracted from kendo.date namespace\n */\nexport class DateUtilsService implements IDateUtilsService {\n    readonly MS_PER_MINUTE = 60000;\n    readonly MS_PER_HOUR = 60 * 60000;\n    readonly MS_PER_DAY = 86400000;\n\n    constructor(\n        private cultureService: ICultureService,\n        private formatterService: IFormatterService\n    ) {}\n\n    /**\n     * Adjust date for DST changes\n     */\n    adjustDST(date: Date, hours: number): boolean {\n        if (hours === 0 && date.getHours() === 23) {\n            date.setHours(date.getHours() + 2);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Set the day of week on a date (mutates the date)\n     */\n    setDayOfWeek(date: Date, day: number, dir: number = 1): void {\n        const hours = date.getHours();\n        day = ((day - date.getDay()) + (7 * dir)) % 7;\n        date.setDate(date.getDate() + day);\n        this.adjustDST(date, hours);\n    }\n\n    /**\n     * Get a new date set to the specified day of week\n     */\n    dayOfWeek(date: Date, day: number, dir?: number): Date {\n        date = new Date(date);\n        this.setDayOfWeek(date, day, dir);\n        return date;\n    }\n\n    /**\n     * Get the first day of the month\n     */\n    firstDayOfMonth(date: Date): Date {\n        return new Date(\n            date.getFullYear(),\n            date.getMonth(),\n            1\n        );\n    }\n\n    /**\n     * Get the last day of the month\n     */\n    lastDayOfMonth(date: Date): Date {\n        const last = new Date(date.getFullYear(), date.getMonth() + 1, 0);\n        const first = this.firstDayOfMonth(date);\n        const timeOffset = Math.abs(last.getTimezoneOffset() - first.getTimezoneOffset());\n\n        if (timeOffset) {\n            last.setHours(first.getHours() + (timeOffset / 60));\n        }\n\n        return last;\n    }\n\n    /**\n     * Get the first day of the year\n     */\n    firstDayOfYear(date: Date): Date {\n        return new Date(date.getFullYear(), 0, 1);\n    }\n\n    /**\n     * Get the last day of the year\n     */\n    lastDayOfYear(date: Date): Date {\n        return new Date(date.getFullYear(), 11, 31);\n    }\n\n    /**\n     * Move date to week start for week calculation\n     */\n    private moveDateToWeekStart(date: Date, weekStartDay: number): Date {\n        if (weekStartDay !== 1) {\n            return this.addDays(this.dayOfWeek(date, weekStartDay, -1), 4);\n        }\n        return this.addDays(date, (4 - (date.getDay() || 7)));\n    }\n\n    /**\n     * Calculate week number in year\n     */\n    private calcWeekInYear(date: Date, weekStartDay: number): number {\n        const firstWeekInYear = new Date(date.getFullYear(), 0, 1, -6);\n        const newDate = this.moveDateToWeekStart(date, weekStartDay);\n        const diffInMS = newDate.getTime() - firstWeekInYear.getTime();\n        const days = Math.floor(diffInMS / this.MS_PER_DAY);\n        return 1 + Math.floor(days / 7);\n    }\n\n    /**\n     * Get the week number in the year\n     */\n    weekInYear(date: Date, weekStartDay?: number): number {\n        if (weekStartDay === undefined) {\n            weekStartDay = this.cultureService.culture().calendar.firstDay;\n        }\n\n        const prevWeekDate = this.addDays(date, -7);\n        const nextWeekDate = this.addDays(date, 7);\n        const weekNumber = this.calcWeekInYear(date, weekStartDay);\n\n        if (weekNumber === 0) {\n            return this.calcWeekInYear(prevWeekDate, weekStartDay) + 1;\n        }\n\n        if (weekNumber === 53 && this.calcWeekInYear(nextWeekDate, weekStartDay) > 1) {\n            return 1;\n        }\n\n        return weekNumber;\n    }\n\n    /**\n     * Get a date with time set to midnight\n     */\n    getDate(date: Date): Date {\n        date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n        this.adjustDST(date, 0);\n        return date;\n    }\n\n    /**\n     * Convert date to UTC time\n     */\n    toUtcTime(date: Date): number {\n        return Date.UTC(\n            date.getFullYear(), \n            date.getMonth(),\n            date.getDate(), \n            date.getHours(), \n            date.getMinutes(),\n            date.getSeconds(), \n            date.getMilliseconds()\n        );\n    }\n\n    /**\n     * Get milliseconds from midnight\n     */\n    getMilliseconds(date: Date): number {\n        return this.toInvariantTime(date).getTime() - this.getDate(this.toInvariantTime(date)).getTime();\n    }\n\n    /**\n     * Check if a time value is within a range\n     */\n    isInTimeRange(value: Date | null, min: Date, max: Date): boolean {\n        let msMin = this.getMilliseconds(min);\n        let msMax = this.getMilliseconds(max);\n\n        if (!value || msMin === msMax) {\n            return true;\n        }\n\n        if (min >= max) {\n            msMax += this.MS_PER_DAY;\n        }\n\n        let msValue = this.getMilliseconds(value);\n\n        if (msMin > msValue) {\n            msValue += this.MS_PER_DAY;\n        }\n\n        if (msMax < msMin) {\n            msMax += this.MS_PER_DAY;\n        }\n\n        return msValue >= msMin && msValue <= msMax;\n    }\n\n    /**\n     * Check if a date value is within a range\n     */\n    isInDateRange(value: Date, min: Date, max: Date): boolean {\n        let msMin = min.getTime();\n        let msMax = max.getTime();\n\n        if (msMin >= msMax) {\n            msMax += this.MS_PER_DAY;\n        }\n\n        const msValue = value.getTime();\n        return msValue >= msMin && msValue <= msMax;\n    }\n\n    /**\n     * Add days to a date\n     */\n    addDays(date: Date, offset: number): Date {\n        const hours = date.getHours();\n        date = new Date(date);\n        this.setTime(date, offset * this.MS_PER_DAY);\n        this.adjustDST(date, hours);\n        return date;\n    }\n\n    /**\n     * Set time on a date (mutates the date)\n     */\n    setTime(date: Date, milliseconds: number, ignoreDST?: boolean): void {\n        const offset = date.getTimezoneOffset();\n        date.setTime(date.getTime() + milliseconds);\n\n        if (!ignoreDST) {\n            const difference = date.getTimezoneOffset() - offset;\n            date.setTime(date.getTime() + difference * this.MS_PER_MINUTE);\n        }\n    }\n\n    /**\n     * Set hours from another date/time\n     */\n    setHours(date: Date, time: Date): Date {\n        date = new Date(\n            date.getFullYear(), \n            date.getMonth(), \n            date.getDate(), \n            time.getHours(), \n            time.getMinutes(), \n            time.getSeconds(), \n            time.getMilliseconds()\n        );\n        this.adjustDST(date, time.getHours());\n        return date;\n    }\n\n    /**\n     * Get today's date (midnight)\n     */\n    today(): Date {\n        return this.getDate(new Date());\n    }\n\n    /**\n     * Check if a date is today\n     */\n    isToday(date: Date): boolean {\n        return this.getDate(date).getTime() === this.today().getTime();\n    }\n\n    /**\n     * Convert date to invariant time (fixed date, preserves time)\n     */\n    toInvariantTime(date?: Date): Date {\n        const staticDate = new Date(1980, 1, 1, 0, 0, 0);\n\n        if (date) {\n            staticDate.setHours(\n                date.getHours(), \n                date.getMinutes(), \n                date.getSeconds(), \n                date.getMilliseconds()\n            );\n        }\n\n        return staticDate;\n    }\n\n    /**\n     * Add years to a date\n     */\n    private addYear(date: Date, offset: number): Date {\n        const currentDate = new Date(date);\n        return new Date(currentDate.setFullYear(currentDate.getFullYear() + offset));\n    }\n\n    /**\n     * Get the next day\n     */\n    nextDay(date: Date): Date {\n        return this.addDays(date, 1);\n    }\n\n    /**\n     * Get the previous day\n     */\n    previousDay(date: Date): Date {\n        return this.addDays(date, -1);\n    }\n\n    /**\n     * Get the next year\n     */\n    nextYear(date: Date): Date {\n        return this.addYear(date, 1);\n    }\n\n    /**\n     * Get the previous year\n     */\n    previousYear(date: Date): Date {\n        return this.addYear(date, -1);\n    }\n\n    /**\n     * Add literal part to date format parts array\n     */\n    private addLiteral(parts: DateFormatPart[], value: string): void {\n        const lastPart = parts[parts.length - 1];\n        if (lastPart && lastPart.type === \"LITERAL\") {\n            lastPart.pattern += value;\n        } else {\n            parts.push({\n                type: \"literal\",\n                pattern: value\n            });\n        }\n    }\n\n    /**\n     * Check if hour pattern is 12-hour format\n     */\n    private isHour12(pattern: string): boolean {\n        return pattern === \"h\" || pattern === \"K\";\n    }\n\n    /**\n     * Get date name type based on format length\n     */\n    private dateNameType(formatLength: number): string | undefined {\n        if (formatLength <= 3) {\n            return \"abbreviated\";\n        } else if (formatLength === 4) {\n            return \"wide\";\n        } else if (formatLength === 5) {\n            return \"narrow\";\n        }\n        return undefined;\n    }\n\n    /**\n     * Check if text starts with search string\n     */\n    private startsWith(text: string, searchString: string, position: number = 0): boolean {\n        return text.indexOf(searchString, position) === position;\n    }\n\n    /**\n     * Get date pattern from format\n     */\n    private datePattern(format: string | undefined, info: any): string {\n        const calendar = info.calendar;\n        let result: string | undefined;\n\n        if (typeof format === \"string\") {\n            if (calendar.patterns[format]) {\n                result = calendar.patterns[format];\n            } else {\n                result = format;\n            }\n        }\n\n        if (!result) {\n            result = calendar.patterns.d;\n        }\n\n        return result;\n    }\n\n    /**\n     * Split a date format string into parts\n     */\n    splitDateFormat(format: string): DateFormatPart[] {\n        const info = this.cultureService.culture();\n        const pattern = this.datePattern(format, info)\n            .replaceAll(\"dddd\", \"EEEE\")\n            .replaceAll(\"ddd\", \"EEE\")\n            .replace(\"tt\", \"aa\");\n        \n        const parts: DateFormatPart[] = [];\n        const dateFormatRegExp = /d{1,2}|E{1,6}|e{1,6}|c{3,6}|c{1}|M{1,5}|L{1,5}|y{1,4}|H{1,2}|h{1,2}|k{1,2}|K{1,2}|m{1,2}|a{1,5}|s{1,2}|S{1,3}|t{1,2}|z{1,4}|Z{1,5}|x{1,5}|X{1,5}|G{1,5}|q{1,5}|Q{1,5}|\"[^\"]*\"|'[^']*'/g;\n\n        let lastIndex = dateFormatRegExp.lastIndex = 0;\n        let match = dateFormatRegExp.exec(pattern);\n\n        while (match) {\n            const value = match[0];\n\n            if (lastIndex < match.index) {\n                this.addLiteral(parts, pattern.substring(lastIndex, match.index));\n            }\n\n            if (this.startsWith(value, '\"') || this.startsWith(value, \"'\")) {\n                this.addLiteral(parts, value);\n            } else {\n                const specifier = value[0];\n                const type = DATE_FIELD_MAP[specifier];\n                const part: DateFormatPart = {\n                    type: type,\n                    pattern: value\n                };\n\n                if (type === \"hour\") {\n                    part.hour12 = this.isHour12(value);\n                }\n\n                const names = NAME_TYPES[type];\n\n                if (names) {\n                    const minLength = typeof names.minLength === \"number\" \n                        ? names.minLength \n                        : names.minLength[specifier];\n                    const patternLength = value.length;\n\n                    if (patternLength >= minLength && value !== \"aa\") {\n                        part.names = {\n                            type: names.type,\n                            nameType: this.dateNameType(patternLength) || \"abbreviated\",\n                            standAlone: names.standAlone === specifier\n                        };\n                    }\n                }\n\n                parts.push(part);\n            }\n\n            lastIndex = dateFormatRegExp.lastIndex;\n            match = dateFormatRegExp.exec(pattern);\n        }\n\n        if (lastIndex < pattern.length) {\n            this.addLiteral(parts, pattern.substring(lastIndex));\n        }\n\n        return parts;\n    }\n\n    /**\n     * Get date format names (month names, day names, etc.)\n     */\n    dateFormatNames(options: DateFormatNamesOptions): string[] {\n        let { type, nameType } = options;\n        const info = this.cultureService.culture();\n\n        if (nameType === \"wide\") {\n            nameType = \"names\";\n        }\n        if (nameType === \"abbreviated\") {\n            nameType = \"namesAbbr\";\n        }\n        if (nameType === \"narrow\") {\n            nameType = \"namesShort\";\n        }\n\n        let result = info.calendar[type]?.[nameType];\n        if (!result) {\n            result = info.calendar[type]?.[\"name\"];\n        }\n        return result || [];\n    }\n\n    /**\n     * Get date field name\n     */\n    dateFieldName(options: DateFieldNameOptions): string | undefined {\n        const info = this.cultureService.culture();\n        const dateFields = info.calendar.dateFields;\n        const fieldNameInfo = dateFields?.[options.type] || {};\n        return fieldNameInfo[options.nameType];\n    }\n\n    /**\n     * Generates a relative date string (Today, Yesterday, Last Wednesday, etc.)\n     * @param date - The date to compare against\n     * @param currentDate - The current date (defaults to new Date())\n     * @returns Relative date string\n     */\n    getRelativeDateString(date: Date | null | undefined, currentDate: Date = new Date()): string {\n        if (!date) {\n            return '';\n        }\n\n        const today = new Date(currentDate);\n        today.setHours(0, 0, 0, 0);\n\n        const dateObj = new Date(date);\n        dateObj.setHours(0, 0, 0, 0);\n\n        const diffTime = today.getTime() - dateObj.getTime();\n        const diffDays = Math.floor(diffTime / this.MS_PER_DAY);\n\n        if (diffDays === 0) {\n            return 'Today';\n        } else if (diffDays === 1) {\n            return 'Yesterday';\n        } else if (diffDays <= 6) {\n            return `Last ${this.formatterService.toString(dateObj, 'dddd')}`;\n        } else {\n            // For older dates, show formatted date\n            return String(this.formatterService.toString(dateObj, 'dddd, MMMM dd, yyyy'));\n        }\n    }\n}\n","import { IUtilsService } from \"../models\";\nimport { \n    IEffectsService, \n    DirectionsMap,\n    IEffects,\n    AnimationOptions,\n    IEffectsElement\n} from \"../models/effects\";\n\n// Constants\nconst STRING = \"string\";\nconst BOOLEAN = \"boolean\";\n\n/**\n * Effects Service - provides animation effects utilities\n \n */\nexport class EffectsService implements IEffectsService {\n    private _directions: DirectionsMap;\n    private _effects: IEffects;\n\n    constructor(\n        private $: JQueryStatic,\n        private utilsService: IUtilsService\n    ) {\n        this._directions = this.createDirections();\n        this._effects = this.createEffects();\n    }\n\n    /**\n     * Create the directions map\n     */\n    private createDirections(): DirectionsMap {\n        return {\n            left: {\n                reverse: \"right\",\n                property: \"left\",\n                transition: \"translatex\",\n                vertical: false,\n                modifier: -1\n            },\n            right: {\n                reverse: \"left\",\n                property: \"left\",\n                transition: \"translatex\",\n                vertical: false,\n                modifier: 1\n            },\n            down: {\n                reverse: \"up\",\n                property: \"top\",\n                transition: \"translatey\",\n                vertical: true,\n                modifier: 1\n            },\n            up: {\n                reverse: \"down\",\n                property: \"top\",\n                transition: \"translatey\",\n                vertical: true,\n                modifier: -1\n            },\n            top: {\n                reverse: \"bottom\"\n            },\n            bottom: {\n                reverse: \"top\"\n            },\n            \"in\": {\n                reverse: \"out\",\n                modifier: -1\n            },\n            out: {\n                reverse: \"in\",\n                modifier: 1\n            },\n            vertical: {\n                reverse: \"vertical\"\n            },\n            horizontal: {\n                reverse: \"horizontal\"\n            }\n        };\n    }\n\n    /**\n     * Create the effects object\n     */\n    private createEffects(): IEffects {\n        const $ = this.$;\n        const effects: IEffects = {\n            enabled: true,\n            Element: function(this: IEffectsElement, element: HTMLElement | JQuery) {\n                this.element = $(element);\n            } as any,\n            promise: function(element: JQuery, options: AnimationOptions) {\n                if (!element.is(\":visible\")) {\n                    element.css({ display: element.data(\"olddisplay\") || \"block\" }).css(\"display\");\n                }\n\n                if (options.hide) {\n                    element.data(\"olddisplay\", element.data(\"olddisplay\") || element.css(\"display\")).hide();\n                }\n\n                if (options.init) {\n                    options.init();\n                }\n\n                if (options.completeCallback) {\n                    options.completeCallback(element); // call the external complete callback with the element\n                }\n\n                element.dequeue();\n            },\n            promiseShim: null as any, // Will be set below\n            disable: function() {\n                this.enabled = false;\n                this.promise = this.promiseShim;\n            },\n            enable: function() {\n                this.enabled = true;\n                this.promise = this.animatedPromise!;\n            }\n        };\n\n        // Set promiseShim to be the same as promise initially\n        effects.promiseShim = effects.promise;\n\n        return effects;\n    }\n\n    /**\n     * Get the directions map for animations\n     */\n    get directions(): DirectionsMap {\n        return this._directions;\n    }\n\n    /**\n     * Get the effects object\n     */\n    get effects(): IEffects {\n        return this._effects;\n    }\n\n    /**\n     * Prepare animation options with defaults\n     */\n    prepareAnimationOptions(\n        options: string | AnimationOptions,\n        duration?: number | boolean | (() => void),\n        reverse?: boolean | (() => void),\n        complete?: () => void\n    ): AnimationOptions {\n        if (typeof options === STRING) {\n            // options is the list of effect names separated by space e.g. animate(element, \"fadeIn slideDown\")\n\n            // only callback is provided e.g. animate(element, options, function() {});\n            if (this.utilsService.isFunction(duration)) {\n                complete = duration as () => void;\n                duration = 400;\n                reverse = false;\n            }\n\n            if (this.utilsService.isFunction(reverse)) {\n                complete = reverse as () => void;\n                reverse = false;\n            }\n\n            if (typeof duration === BOOLEAN) {\n                reverse = duration as boolean;\n                duration = 400;\n            }\n\n            options = {\n                effects: options,\n                duration: duration as number,\n                reverse: reverse as boolean,\n                complete: complete\n            };\n        }\n\n        return this.$.extend({\n            //default options\n            effects: {},\n            duration: 400, //jQuery default duration\n            reverse: false,\n            init: this.$.noop,\n            teardown: this.$.noop,\n            hide: false\n        }, options, { completeCallback: (options as AnimationOptions).complete, complete: this.$.noop }); // Move external complete callback, so deferred.resolve can be always executed.\n    }\n\n    /**\n     * Animate one or more elements\n     */\n    animate(\n        element: JQuery,\n        options: string | AnimationOptions,\n        duration?: number | boolean | (() => void),\n        reverse?: boolean | (() => void),\n        complete?: () => void\n    ): JQuery {\n        const $ = this.$;\n        const effects = this._effects;\n        const preparedOptions = this.prepareAnimationOptions.bind(this);\n        let idx = 0;\n        const length = element.length;\n        let instance: JQuery;\n\n        for (; idx < length; idx++) {\n            instance = $(element[idx]);\n            instance.queue(function(this: HTMLElement) {\n                effects.promise($(this), preparedOptions(options, duration, reverse, complete));\n            });\n        }\n\n        return element;\n    }\n\n    /**\n     * Toggle CSS classes on element\n     */\n    toggleClass(element: JQuery, classes: string, options?: any, add?: boolean): JQuery {\n        if (classes) {\n            const classArray = classes.split(\" \");\n\n            this.$.each(classArray, (idx: number, value: string) => {\n                element.toggleClass(value, add);\n            });\n        }\n\n        return element;\n    }\n\n    /**\n     * Create an effects element wrapper\n     */\n    fx(element: HTMLElement | JQuery): IEffectsElement {\n        return new this._effects.Element(element);\n    }\n}\n","import { IFocusUtilsService } from \"../models/focus-utils\";\nimport { IDomUtilsService } from \"../models/dom-utils\";\nimport { IWidgetUtilsService } from \"../models\";\n\n// TAB key code - will be moved to utils service in future refactoring\nconst TAB_KEY = 9;\n\n/**\n * Focus Utils Service - provides focus-related utilities\n \n */\nexport class FocusUtilsService implements IFocusUtilsService {\n    constructor(\n        private $: JQueryStatic,\n        private domUtils: IDomUtilsService,\n        private widgetUtilsService: IWidgetUtilsService\n    ) {}\n\n    /**\n     * Check if an element is focusable\n     */\n    focusable(element: HTMLElement, isTabIndexNotNaN: boolean): boolean {\n        const nodeName = element.nodeName.toLowerCase();\n\n        return (/input|select|textarea|button|object/.test(nodeName) ?\n                !(element as HTMLInputElement).disabled :\n                nodeName === \"a\" ?\n                (element as HTMLAnchorElement).href || isTabIndexNotNaN :\n                isTabIndexNotNaN\n               ) &&\n            this.visible(element);\n    }\n\n    /**\n     * Check if an element is visible (not hidden or with visibility:hidden)\n     */\n    visible(element: HTMLElement): boolean {\n        const $ = this.$;\n        return ($.expr.pseudos as any).visible(element) &&\n            !$(element).parents().addBack().filter(function(this: HTMLElement) {\n                return $.css(this, \"visibility\") === \"hidden\";\n            }).length;\n    }\n\n    /**\n     * Check if an element is kendo-focusable (focusable with positive tabindex)\n     */\n    kendoFocusable(element: HTMLElement): boolean {\n        const idx = this.$(element).attr(\"tabindex\");\n        const numIdx = idx !== undefined ? parseInt(idx, 10) : NaN;\n        return this.focusable(element, !isNaN(numIdx) && numIdx > -1);\n    }\n\n    /**\n     * Focus an element while preserving scroll positions of parent containers\n     */\n    focusElement(element: JQuery): void {\n        const $ = this.$;\n        const domUtils = this.domUtils;\n        const scrollTopPositions: number[] = [];\n        const scrollableParents = element.parentsUntil(\"body\")\n                .filter(function(this: HTMLElement, index: number, el: HTMLElement) {\n                    const computedStyle = domUtils.getComputedStyles(el, [\"overflow\"]);\n                    return computedStyle.overflow !== \"visible\";\n                })\n                .add(window as any);\n\n        scrollableParents.each(function(this: HTMLElement | Window, index: number, parent: HTMLElement | Window) {\n            scrollTopPositions[index] = $(parent as any).scrollTop() || 0;\n        });\n\n        try {\n            //The setActive method does not cause the document to scroll to the active object in the current page\n            (element[0] as any).setActive();\n        } catch (e) {\n            element.trigger(\"focus\");\n        }\n\n        scrollableParents.each(function(this: HTMLElement | Window, index: number, parent: HTMLElement | Window) {\n            $(parent as any).scrollTop(scrollTopPositions[index]);\n        });\n    }\n\n    /**\n     * Focus the next focusable element in the document\n     */\n    focusNextElement(): void {\n        const $ = this.$;\n        if (document.activeElement) {\n            const focussable = $(\":kendoFocusable\");\n            const index = focussable.index(document.activeElement);\n\n            if (index > -1) {\n               const nextElement = focussable[index + 1] || focussable[0];\n               (nextElement as HTMLElement).focus();\n            }\n        }\n    }\n\n    /**\n     * Set up form cycling - when tabbing from last element, cycle to first\n     */\n    cycleForm(form: JQuery): void {\n        const $ = this.$;\n        const self = this;\n        const firstElement = form.find(\"input, .k-widget, .k-dropdownlist, .k-combobox\").first();\n        const lastElement = form.find(\"button, .k-button\").last();\n\n        function focus(el: JQuery) {\n            const widget = self.widgetUtilsService.widgetInstance(el);\n\n            if (widget && widget.focus) {\n              widget.focus();\n            } else {\n              el.trigger(\"focus\");\n            }\n        }\n\n        lastElement.on(\"keydown\", function(e: JQuery.KeyDownEvent) {\n          if (e.keyCode === TAB_KEY && !e.shiftKey) {\n            e.preventDefault();\n            focus(firstElement);\n          }\n        });\n\n        firstElement.on(\"keydown\", function(e: JQuery.KeyDownEvent) {\n          if (e.keyCode === TAB_KEY && e.shiftKey) {\n            e.preventDefault();\n            focus(lastElement);\n          }\n        });\n    }\n\n    /**\n     * Get the focusable element for a widget\n     */\n    getWidgetFocusableElement(element: JQuery): JQuery {\n        const $ = this.$;\n        const nextFocusable = element.closest(\":kendoFocusable\");\n        const widgetInstance = this.widgetUtilsService.widgetInstance(element);\n        let target: JQuery;\n\n        if (nextFocusable.length) {\n            target = nextFocusable;\n        } else if (widgetInstance) {\n            target = widgetInstance.options.name === 'Editor' ?\n                $(widgetInstance.body) :\n                widgetInstance.wrapper.find(\":kendoFocusable\").first();\n        } else {\n            target = element;\n        }\n\n        return target;\n    }\n\n    /**\n     * Register the :kendoFocusable pseudo-selector with jQuery\n     */\n    registerFocusableSelector(): void {\n        const self = this;\n        const $ = this.$;\n        $.extend($.expr.pseudos, {\n            kendoFocusable: function(element: HTMLElement) {\n                return self.kendoFocusable(element);\n            }\n        });\n    }\n\n    /**\n     * Get the currently focused element in the document.\n     * Handles exceptions that can occur in some browsers.\n     * @returns The active element\n     */\n    activeElement(): Element {\n        try {\n            return document.activeElement!;\n        } catch (e) {\n            return (document.documentElement as any).activeElement;\n        }\n    }\n}\n","import { IUtilsService } from \"../models/utils\";\nimport {\n    IPropertyAccessService,\n    PropertyGetter,\n    PropertySetter,\n    PropertyAccessor\n} from \"../models/property-access\";\n\n/**\n * Property Access Service Implementation\n * Provides utilities for dynamic property access using path expressions.\n \n */\nexport class PropertyAccessService implements IPropertyAccessService {\n    private getterCache: Record<string, PropertyGetter> = {};\n    private setterCache: Record<string, PropertySetter> = {};\n\n    constructor(\n        private utilsService: IUtilsService\n    ) {}\n\n    /**\n     * Wrap an expression for safe access.\n     * Generates nested null-safe property access.\n     */\n    private wrapExpression(members: string[], paramName: string): string {\n        let result = paramName || \"d\";\n        let count = 1;\n\n        for (let idx = 0; idx < members.length; idx++) {\n            let member = members[idx];\n            if (member !== \"\") {\n                const index = member.indexOf(\"[\");\n\n                if (index !== 0) {\n                    if (index === -1) {\n                        member = \".\" + member;\n                    } else {\n                        count++;\n                        member = \".\" + member.substring(0, index) + \" || {})\" + member.substring(index);\n                    }\n                }\n\n                count++;\n                result += member + ((idx < members.length - 1) ? \" || {})\" : \")\");\n            }\n        }\n        return new Array(count).join(\"(\") + result;\n    }\n\n    /**\n     * Generate a JavaScript expression for accessing a property path.\n     */\n    expr(expression: string, safe?: boolean | string, paramName?: string): string {\n        expression = expression || \"\";\n\n        if (typeof safe === \"string\") {\n            paramName = safe;\n            safe = false;\n        }\n\n        paramName = paramName || \"d\";\n\n        if (expression && expression.charAt(0) !== \"[\") {\n            expression = \".\" + expression;\n        }\n\n        if (safe) {\n            expression = expression.replace(/\"([^.]*)\\.([^\"]*)\"/g, '\"$1_$DOT$_$2\"');\n            expression = expression.replace(/'([^.]*)\\.([^']*)'/g, \"'$1_$DOT$_$2'\");\n            expression = this.wrapExpression(expression.split(\".\"), paramName);\n            expression = expression.replace(/_\\$DOT\\$_/g, \".\");\n        } else {\n            expression = paramName + expression;\n        }\n\n        return expression;\n    }\n\n    /**\n     * Convert an expression to an array of field names.\n     */\n    exprToArray(expression: string, safe?: boolean): string[] {\n        expression = expression || \"\";\n\n        return expression.indexOf(\".\") >= 0 || expression.indexOf(\"[\") >= 0 ?\n            expression.split(/[[\\].]/).map(v => v.replace(/[\"']/g, \"\")).filter(v => v) :\n            expression === \"\" ? [] : [expression];\n    }\n\n    /**\n     * Create a getter function for a property path.\n     */\n    getter(expression: string, safe?: boolean): PropertyGetter {\n        const key = expression + safe;\n\n        if (!this.getterCache[key]) {\n            this.getterCache[key] = (obj: any) => {\n                const fields = this.exprToArray(expression, safe);\n\n                let result = obj;\n                for (let idx = 0; idx < fields.length; idx++) {\n                    result = result[fields[idx]];\n                    if (!this.utilsService.isPresent(result) && safe) {\n                        return result;\n                    }\n                }\n\n                return result;\n            };\n        }\n\n        return this.getterCache[key];\n    }\n\n    /**\n     * Create a setter function for a property path.\n     */\n    setter(expression: string): PropertySetter {\n        if (!this.setterCache[expression]) {\n            this.setterCache[expression] = (obj: any, value: any) => {\n                const fields = this.exprToArray(expression);\n\n                const innerSetter = (args: { parent: any; val: any; prop: string; props: string[] }) => {\n                    if (args.props.length) {\n                        args.parent = args.parent[args.props.shift()!];\n                        innerSetter(args);\n                    } else {\n                        args.parent[args.prop] = args.val;\n                    }\n                };\n\n                innerSetter({\n                    parent: obj,\n                    val: value,\n                    prop: fields.pop()!,\n                    props: fields\n                });\n            };\n        }\n\n        return this.setterCache[expression];\n    }\n\n    /**\n     * Create an accessor with both get and set functions.\n     */\n    accessor(expression: string): PropertyAccessor {\n        return {\n            get: this.getter(expression),\n            set: this.setter(expression)\n        };\n    }\n}\n","import { IInputService, CaretPosition } from \"../models/input\";\nimport { ISupportService } from \"../models/support\";\n\n/**\n * Input Service Implementation\n * Provides utilities for input element manipulation.\n \n */\nexport class InputService implements IInputService {\n    constructor(\n        private $: JQueryStatic,\n        private supportService: ISupportService\n    ) {}\n\n    /**\n     * Get or set the caret (text cursor) position in an input element.\n     */\n    caret(element: HTMLInputElement | HTMLTextAreaElement | JQuery, start?: number, end?: number): CaretPosition {\n        let rangeElement: any;\n        const isPosition = start !== undefined;\n\n        if (end === undefined) {\n            end = start;\n        }\n\n        // Unwrap jQuery element\n        if ((element as JQuery)[0]) {\n            element = (element as JQuery)[0] as HTMLInputElement;\n        }\n\n        const inputElement = element as HTMLInputElement | HTMLTextAreaElement;\n\n        if (isPosition && inputElement.disabled) {\n            return [];\n        }\n\n        try {\n            if (inputElement.selectionStart !== undefined) {\n                if (isPosition) {\n                    inputElement.focus();\n                    const mobile = this.supportService.mobileOS;\n                    if (mobile && (mobile.wp || mobile.android)) {\n                        // Without the timeout the caret is at the end of the input\n                        setTimeout(() => {\n                            inputElement.setSelectionRange(start!, end!);\n                        }, 0);\n                    } else {\n                        inputElement.setSelectionRange(start!, end!);\n                    }\n                    return [start!, end!];\n                } else {\n                    return [inputElement.selectionStart, inputElement.selectionEnd];\n                }\n            } else if ((document as any).selection) {\n                // Legacy IE support\n                if (this.$(inputElement).is(\":visible\")) {\n                    inputElement.focus();\n                }\n\n                rangeElement = (inputElement as any).createTextRange();\n\n                if (isPosition) {\n                    rangeElement.collapse(true);\n                    rangeElement.moveStart(\"character\", start);\n                    rangeElement.moveEnd(\"character\", end! - start!);\n                    rangeElement.select();\n                    return [start!, end!];\n                } else {\n                    const rangeDuplicated = rangeElement.duplicate();\n                    let selectionStart: number;\n                    let selectionEnd: number;\n\n                    rangeElement.moveToBookmark((document as any).selection.createRange().getBookmark());\n                    rangeDuplicated.setEndPoint(\"EndToStart\", rangeElement);\n                    selectionStart = rangeDuplicated.text.length;\n                    selectionEnd = selectionStart + rangeElement.text.length;\n\n                    return [selectionStart, selectionEnd];\n                }\n            }\n        } catch (e) {\n            // Element is not focused or it is not in the DOM\n            return [];\n        }\n\n        return [];\n    }\n\n    /**\n     * Get anti-forgery (CSRF) tokens from the page.\n     */\n    antiForgeryTokens(): Record<string, string> {\n        const tokens: Record<string, string> = {};\n        const $ = this.$;\n\n        const csrfToken = $(\"meta[name=csrf-token],meta[name=_csrf]\").attr(\"content\");\n        const csrfParam = $(\"meta[name=csrf-param],meta[name=_csrf_header]\").attr(\"content\");\n\n        $(\"input[name^='__RequestVerificationToken']\").each(function(this: HTMLInputElement) {\n            tokens[this.name] = this.value;\n        });\n\n        if (csrfParam !== undefined && csrfToken !== undefined) {\n            tokens[csrfParam] = csrfToken;\n        }\n\n        return tokens;\n    }\n}\n","import { IColorService } from \"../models/color\";\n\n/**\n * Color Service Implementation\n * Provides utilities for extracting theme colors.\n \n */\nexport class ColorService implements IColorService {\n    constructor(private $: JQueryStatic) {}\n\n    /**\n     * Get series colors from CSS custom properties.\n     */\n    getSeriesColors(): string[] {\n        const seriesColorsTemplate = \n            '<div class=\"k-var--series-a\"></div>' +\n            '<div class=\"k-var--series-b\"></div>' +\n            '<div class=\"k-var--series-c\"></div>' +\n            '<div class=\"k-var--series-d\"></div>' +\n            '<div class=\"k-var--series-e\"></div>' +\n            '<div class=\"k-var--series-f\"></div>';\n\n        const series = this.$(seriesColorsTemplate);\n        const colors: string[] = [];\n\n        series.appendTo(this.$(\"body\"));\n\n        series.each((_i: number, item: HTMLElement) => {\n            colors.push(this.$(item).css(\"background-color\"));\n        });\n\n        series.remove();\n\n        return colors;\n    }\n}\n","import { ISelectorService } from \"../models/selector\";\n\n/**\n * Selector Service Implementation\n * Provides utilities for building CSS selectors.\n \n */\nexport class SelectorService implements ISelectorService {\n    /**\n     * Convert space-separated class names to a CSS selector.\n     */\n    selectorFromClasses(classes: string): string {\n        return \".\" + classes.split(\" \").join(\".\");\n    }\n\n    /**\n     * Build a role selector for data-role attributes.\n     */\n    roleSelector(role: string, ns: string): string {\n        return role.replace(/(\\S+)/g, \"[data-\" + ns + \"role=$1],\").slice(0, -1);\n    }\n\n    /**\n     * Build a directive selector for mobile components.\n     */\n    directiveSelector(directives: string): string {\n        const selectors = directives.split(\" \");\n\n        if (selectors) {\n            for (let i = 0; i < selectors.length; i++) {\n                if (selectors[i] !== \"view\") {\n                    selectors[i] = selectors[i].replace(/(\\w*)(view|bar|strip|over)$/, \"$1-$2\");\n                }\n            }\n        }\n\n        return selectors.join(\" \").replace(/(\\S+)/g, \"kendo-mobile-$1,\").slice(0, -1);\n    }\n}\n","import { INumberParserService } from \"../models/parser\";\nimport { \n    ITimezoneService, \n    MonthMap, \n    DayMap, \n    TimezoneRule, \n    TimezoneZone,\n    ZonesDictionary,\n    RulesDictionary,\n    ZoneAndRuleInfo\n} from \"../models/timezone\";\n\n// Constants\nconst NUMBER = \"number\";\nconst STRING = \"string\";\n\n/**\n * Service for timezone conversions\n * Extracted from kendo.timezone in kendo.core.js\n */\nexport class TimezoneService implements ITimezoneService {\n    /**\n     * Timezone zone definitions - populated externally\n     */\n    zones: ZonesDictionary = {};\n\n    /**\n     * Timezone rule definitions - populated externally\n     */\n    rules: RulesDictionary = {};\n\n    /**\n     * Month name to index mapping\n     */\n    private months: MonthMap = { \n        Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5, \n        Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11 \n    };\n\n    /**\n     * Day name to index mapping\n     */\n    private days: DayMap = { \n        Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 \n    };\n\n    constructor(\n        private numberParserService: INumberParserService\n    ) {}\n\n    /**\n     * Get the UTC offset for a given time in a timezone\n     */\n    offset(utcTime: number | Date, timezone: string): number {\n        if (timezone === \"Etc/UTC\" || timezone === \"Etc/GMT\") {\n            return 0;\n        }\n\n        const info = this.zoneAndRule(utcTime, this.zones, this.rules, timezone);\n        const zone = info.zone;\n        const rule = info.rule;\n\n        return this.numberParserService.parseFloat(rule ? (zone[0] as number) - (rule[6] as number) : zone[0] as number);\n    }\n\n    /**\n     * Get the timezone abbreviation for a given time\n     */\n    abbr(utcTime: number | Date, timezone: string): string {\n        const info = this.zoneAndRule(utcTime, this.zones, this.rules, timezone);\n        const zone = info.zone;\n        const rule = info.rule;\n\n        const base = zone[2] as string;\n\n        if (base.indexOf(\"/\") >= 0) {\n            return base.split(\"/\")[rule && +rule[6] ? 1 : 0];\n        } else if (base.indexOf(\"%s\") >= 0) {\n            return base.replace(\"%s\", (!rule || rule[7] === \"-\") ? '' : rule[7] as string);\n        }\n\n        return base;\n    }\n\n    /**\n     * Convert a date between timezones\n     */\n    convert(date: Date, fromOffset: string | number, toOffset: string | number): Date {\n        let tempToOffset = toOffset;\n        let diff: number;\n\n        if (typeof fromOffset === STRING) {\n            fromOffset = this.offset(date, fromOffset as string);\n        }\n\n        if (typeof toOffset === STRING) {\n            toOffset = this.offset(date, toOffset as string);\n        }\n\n        const fromLocalOffset = date.getTimezoneOffset();\n\n        date = new Date(date.getTime() + ((fromOffset as number) - (toOffset as number)) * 60000);\n\n        const toLocalOffset = date.getTimezoneOffset();\n\n        if (typeof tempToOffset === STRING) {\n            tempToOffset = this.offset(date, tempToOffset as string);\n        }\n\n        diff = (toLocalOffset - fromLocalOffset) + ((toOffset as number) - (tempToOffset as number));\n\n        return new Date(date.getTime() + diff * 60000);\n    }\n\n    /**\n     * Apply a timezone to a local date\n     */\n    apply(date: Date, timezone: string): Date {\n        return this.convert(date, date.getTimezoneOffset(), timezone);\n    }\n\n    /**\n     * Remove timezone adjustment from a date\n     */\n    remove(date: Date, timezone: string): Date {\n        return this.convert(date, timezone, date.getTimezoneOffset());\n    }\n\n    /**\n     * Convert a UTC timestamp to a local date\n     */\n    toLocalDate(time: number): Date {\n        return this.apply(new Date(time), \"Etc/UTC\");\n    }\n\n    /**\n     * Convert a rule to a Date for a specific year\n     */\n    private ruleToDate(year: number, rule: TimezoneRule): Date {\n        let date: Date;\n        let targetDay: number;\n        let ourDay: number;\n        const month = rule[3] as string;\n        const on = rule[4] as string | number;\n        const time = rule[5] as number[];\n        let cache = rule[8] as Record<number, Date>;\n\n        if (!cache) {\n            rule[8] = cache = {};\n        }\n\n        if (cache[year]) {\n            return cache[year];\n        }\n\n        if (!isNaN(on as number)) {\n            date = new Date(Date.UTC(year, this.months[month], on as number, time[0], time[1], time[2], 0));\n        } else if ((on as string).indexOf(\"last\") === 0) {\n            date = new Date(Date.UTC(year, this.months[month] + 1, 1, time[0] - 24, time[1], time[2], 0));\n\n            targetDay = this.days[(on as string).substr(4, 3)];\n            ourDay = date.getUTCDay();\n\n            date.setUTCDate(date.getUTCDate() + targetDay - ourDay - (targetDay > ourDay ? 7 : 0));\n        } else if ((on as string).indexOf(\">=\") >= 0) {\n            date = new Date(Date.UTC(year, this.months[month], parseInt((on as string).substr(5), 10), time[0], time[1], time[2], 0));\n\n            targetDay = this.days[(on as string).substr(0, 3)];\n            ourDay = date.getUTCDay();\n\n            date.setUTCDate(date.getUTCDate() + targetDay - ourDay + (targetDay < ourDay ? 7 : 0));\n        } else if ((on as string).indexOf(\"<=\") >= 0) {\n            date = new Date(Date.UTC(year, this.months[month], parseInt((on as string).substr(5), 10), time[0], time[1], time[2], 0));\n\n            targetDay = this.days[(on as string).substr(0, 3)];\n            ourDay = date.getUTCDay();\n\n            date.setUTCDate(date.getUTCDate() + targetDay - ourDay - (targetDay > ourDay ? 7 : 0));\n        }\n\n        return cache[year] = date!;\n    }\n\n    /**\n     * Find the applicable rule for a given UTC time\n     */\n    private findRule(utcTime: number, rules: RulesDictionary, zone: string): TimezoneRule | null {\n        let zoneRules = rules[zone] as TimezoneRule[];\n\n        if (!zoneRules) {\n            const time = zone.split(\":\");\n            let offset = 0;\n\n            if (time.length > 1) {\n                offset = parseInt(time[0], 10) * 60 + Number(time[1]);\n            }\n\n            return [-1000000, 'max', '-', 'Jan', 1, [0, 0, 0], offset, '-'] as TimezoneRule;\n        }\n\n        const year = new Date(utcTime).getUTCFullYear();\n\n        // Filter rules applicable to this year\n        // Note: Using == for loose equality to match original behavior since rule values may be strings\n        zoneRules = zoneRules.filter((rule: TimezoneRule) => {\n            const from = rule[0];\n            const to = rule[1];\n\n            // eslint-disable-next-line eqeqeq\n            return (from as number) <= year && ((to as number) >= year || (from == year && to === \"only\") || to === \"max\");\n        });\n\n        // Add the utcTime to sort with rules\n        const sortArray: (TimezoneRule | number)[] = [...zoneRules, utcTime];\n\n        sortArray.sort((a, b) => {\n            let aVal = a as number;\n            let bVal = b as number;\n\n            if (typeof a !== \"number\") {\n                aVal = Number(this.ruleToDate(year, a as TimezoneRule));\n            }\n\n            if (typeof b !== \"number\") {\n                bVal = Number(this.ruleToDate(year, b as TimezoneRule));\n            }\n\n            return aVal - bVal;\n        });\n\n        const idx = sortArray.indexOf(utcTime);\n        const rule = sortArray[idx - 1] || sortArray[sortArray.length - 1];\n\n        return isNaN(rule as number) ? rule as TimezoneRule : null;\n    }\n\n    /**\n     * Find the zone definition for a given UTC time\n     */\n    private findZone(utcTime: number, zones: ZonesDictionary, timezone: string): TimezoneZone {\n        let zoneRules = zones[timezone];\n\n        if (typeof zoneRules === \"string\") {\n            zoneRules = zones[zoneRules] as TimezoneZone[];\n        }\n\n        if (!zoneRules) {\n            throw new Error('Timezone \"' + timezone + '\" is either incorrect, or kendo.timezones.min.js is not included.');\n        }\n\n        const zoneArray = zoneRules as TimezoneZone[];\n        let idx: number;\n\n        for (idx = zoneArray.length - 1; idx >= 0; idx--) {\n            const until = zoneArray[idx][3];\n\n            if (until && utcTime > until) {\n                break;\n            }\n        }\n\n        const zone = zoneArray[idx + 1];\n\n        if (!zone) {\n            throw new Error('Timezone \"' + timezone + '\" not found on ' + utcTime + \".\");\n        }\n\n        return zone;\n    }\n\n    /**\n     * Get zone and rule info for a given UTC time\n     */\n    private zoneAndRule(utcTime: number | Date, zones: ZonesDictionary, rules: RulesDictionary, timezone: string): ZoneAndRuleInfo {\n        if (typeof utcTime !== NUMBER) {\n            const date = utcTime as Date;\n            utcTime = Date.UTC(date.getFullYear(), date.getMonth(),\n                date.getDate(), date.getHours(), date.getMinutes(),\n                date.getSeconds(), date.getMilliseconds());\n        }\n\n        const zone = this.findZone(utcTime as number, zones, timezone);\n\n        return {\n            zone: zone,\n            rule: this.findRule(utcTime as number, rules, zone[1] as string)\n        };\n    }\n}\n","/**\n * Type utilities service for runtime type checking.\n * Implements jQuery's deprecated type() function.\n *\n * @module core-v2/services/type-utils.service\n */\n\n/**\n * Mapping of Object.prototype.toString results to type names\n */\nexport type Class2TypeMap = Record<string, string>;\n\n/**\n * Service for runtime type checking utilities.\n * Provides type() function that was deprecated in jQuery.\n */\nexport class TypeUtilsService {\n    /**\n     * Map of toString results to lowercase type names\n     */\n    private class2type: Class2TypeMap = {};\n\n    constructor() {\n        // Build the class2type map for standard JavaScript types\n        \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \")\n            .forEach((name) => {\n                this.class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n            });\n    }\n\n    /**\n     * Get the class2type mapping object\n     */\n    getClass2Type(): Class2TypeMap {\n        return this.class2type;\n    }\n\n    /**\n     * Determine the internal JavaScript [[Class]] of an object.\n     * This is a replacement for jQuery.type() which was deprecated.\n     *\n     * @param obj - The object to get the type of\n     * @returns The type name as a lowercase string (e.g., \"string\", \"number\", \"array\", \"date\", \"regexp\", \"object\", \"null\", \"undefined\")\n     *\n     * @example\n     * ```typescript\n     * type(undefined)     // \"undefined\"\n     * type(null)          // \"null\"\n     * type(true)          // \"boolean\"\n     * type(3)             // \"number\"\n     * type(\"test\")        // \"string\"\n     * type(function(){})  // \"function\"\n     * type([])            // \"array\"\n     * type(new Date())    // \"date\"\n     * type(/test/)        // \"regexp\"\n     * type({})            // \"object\"\n     * ```\n     */\n    type(obj: unknown): string {\n        // eslint-disable-next-line eqeqeq\n        if (obj == null) {\n            return obj + \"\";\n        }\n\n        // Support: Android <=2.3 only (functionish RegExp)\n        return typeof obj === \"object\" || typeof obj === \"function\" ?\n            this.class2type[Object.prototype.toString.call(obj)] || \"object\" :\n            typeof obj;\n    }\n}\n","/**\n * Mouse Event Normalizer Service\n * Handles mouse event capturing and muting for touch/pointer event normalization.\n *\n * @module core-v2/services/mouse-event-normalizer.service\n */\n\nimport type { ISupportService } from \"../models/support\";\n\n/**\n * Mouse event normalizer service for handling touch/mouse event conflicts.\n * Prevents ghost clicks and normalizes touch events to mouse events.\n */\nexport class MouseEventNormalizerService {\n    /**\n     * Whether the mouse trap has been set up\n     */\n    mouseTrap: boolean = false;\n\n    /**\n     * Whether click events should be busted (prevented)\n     */\n    bustClick: boolean = false;\n\n    /**\n     * Whether mouse events are currently being captured/muted\n     */\n    captureMouse: boolean = false;\n\n    /**\n     * Timeout ID for the mouse trap release\n     */\n    mouseTrapTimeoutID: ReturnType<typeof setTimeout> | undefined;\n\n    /**\n     * List of mouse events to capture\n     */\n    private readonly MOUSE_EVENTS = [\"mousedown\", \"mousemove\", \"mouseenter\", \"mouseleave\", \"mouseover\", \"mouseout\", \"mouseup\", \"click\"];\n\n    /**\n     * Selector for elements that should not have click busting\n     */\n    private readonly EXCLUDE_BUST_CLICK_SELECTOR = \"label, input, [data-rel=external]\";\n\n    constructor(\n        private $: JQueryStatic,\n        private support: ISupportService\n    ) {}\n\n    /**\n     * Set up mouse event capturing to prevent ghost clicks from touch events.\n     * This sets up event listeners on document.documentElement to intercept\n     * and optionally stop mouse events when touch events are active.\n     */\n    setupMouseMute(): void {\n        let idx = 0;\n        const length = this.MOUSE_EVENTS.length;\n        const element = document.documentElement;\n\n        if (this.mouseTrap || !this.support.eventCapture) {\n            return;\n        }\n\n        this.mouseTrap = true;\n\n        this.bustClick = false;\n        this.captureMouse = false;\n\n        const self = this;\n        const handler = function(e: Event) {\n            if (self.captureMouse) {\n                if (e.type === \"click\") {\n                    if (self.bustClick && !self.$(e.target as Element).is(self.EXCLUDE_BUST_CLICK_SELECTOR)) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                    }\n                } else {\n                    e.stopPropagation();\n                }\n            }\n        };\n\n        for (; idx < length; idx++) {\n            element.addEventListener(this.MOUSE_EVENTS[idx], handler, true);\n        }\n    }\n\n    /**\n     * Mute mouse events. Called on touchstart to prevent ghost clicks.\n     * @param e - The jQuery event with bustClick data\n     */\n    muteMouse(e: JQuery.Event & { data?: { bustClick?: boolean } }): void {\n        this.captureMouse = true;\n        if (e.data?.bustClick) {\n            this.bustClick = true;\n        }\n        clearTimeout(this.mouseTrapTimeoutID);\n    }\n\n    /**\n     * Unmute mouse events. Called on touchend after a delay to allow\n     * legitimate mouse events through again.\n     */\n    unMuteMouse(): void {\n        clearTimeout(this.mouseTrapTimeoutID);\n        this.mouseTrapTimeoutID = setTimeout(() => {\n            this.captureMouse = false;\n            this.bustClick = false;\n        }, 400);\n    }\n}\n","/**\n * Event Map Service\n * Provides cross-browser event mapping for touch, pointer, and mouse events.\n *\n * @module core-v2/services/event-map.service\n */\n\nimport type { ISupportService } from \"../models/support\";\n\n/**\n * Event map type - maps abstract event names to browser-specific events\n */\nexport interface EventMap {\n    down: string;\n    move: string;\n    up: string;\n    cancel: string;\n}\n\n/**\n * Event map service for cross-browser event handling.\n * Maps abstract event names (down, move, up, cancel) to the appropriate\n * browser-specific events based on touch/pointer/mouse support.\n */\nexport class EventMapService {\n    /**\n     * The current event map based on browser capabilities\n     */\n    private eventMap: EventMap;\n\n    /**\n     * Regex for matching event names in a string\n     */\n    private readonly eventRegEx = /([^ ]+)/g;\n\n    constructor(\n        private $: JQueryStatic,\n        private support: ISupportService\n    ) {\n        this.eventMap = this.buildEventMap();\n        this.setupMSPointerEvents();\n    }\n\n    /**\n     * Build the event map based on browser capabilities\n     */\n    private buildEventMap(): EventMap {\n        // Default: combined touch and mouse events\n        let map: EventMap = {\n            down: \"touchstart mousedown\",\n            move: \"mousemove touchmove\",\n            up: \"mouseup touchend touchcancel\",\n            cancel: \"mouseleave touchcancel\"\n        };\n\n        if (this.support.touch && (this.support.mobileOS && (this.support.mobileOS.ios || this.support.mobileOS.android))) {\n            // Touch-only devices\n            map = {\n                down: \"touchstart\",\n                move: \"touchmove\",\n                up: \"touchend touchcancel\",\n                cancel: \"touchcancel\"\n            };\n        } else if (this.support.pointers) {\n            // W3C Pointer Events\n            map = {\n                down: \"pointerdown\",\n                move: \"pointermove\",\n                up: \"pointerup\",\n                cancel: \"pointercancel pointerleave\"\n            };\n        } else if (this.support.msPointers) {\n            // IE10 MS Pointer Events\n            map = {\n                down: \"MSPointerDown\",\n                move: \"MSPointerMove\",\n                up: \"MSPointerUp\",\n                cancel: \"MSPointerCancel MSPointerLeave\"\n            };\n        }\n\n        return map;\n    }\n\n    /**\n     * Setup MSPointerEnter/MSPointerLeave events for IE10\n     * Creates these events using mouseover/out and event-time checks\n     */\n    private setupMSPointerEvents(): void {\n        if (this.support.msPointers && !(\"onmspointerenter\" in window)) {\n            // IE10 - Create MSPointerEnter/MSPointerLeave events\n            this.$.each({\n                MSPointerEnter: \"MSPointerOver\",\n                MSPointerLeave: \"MSPointerOut\"\n            }, (orig: string, fix: string) => {\n                (this.$.event as any).special[orig] = {\n                    delegateType: fix,\n                    bindType: fix,\n\n                    handle: function(event: JQuery.Event & { handleObj?: any; relatedTarget?: EventTarget | null }) {\n                        let ret;\n                        const target = this;\n                        const related = event.relatedTarget;\n                        const handleObj = event.handleObj;\n\n                        // For mousenter/leave call the handler if related is outside the target.\n                        // NB: No relatedTarget if the mouse left/entered the browser window\n                        if (!related || (related !== target && !this.$.contains(target, related as Element))) {\n                            event.type = handleObj.origType;\n                            ret = handleObj.handler.apply(this, arguments);\n                            event.type = fix;\n                        }\n                        return ret;\n                    }\n                };\n            });\n        }\n    }\n\n    /**\n     * Get the mapped event for an abstract event name\n     * @param eventName - The abstract event name (down, move, up, cancel) or specific event\n     * @returns The browser-specific event(s) or the original event if no mapping exists\n     */\n    getEventMap(eventName: string): string {\n        return (this.eventMap as any)[eventName] || eventName;\n    }\n\n    /**\n     * Get the full event map object\n     */\n    getFullEventMap(): EventMap {\n        return { ...this.eventMap };\n    }\n\n    /**\n     * Apply event mapping to a space-separated list of events\n     * @param events - Space-separated event names to map\n     * @param ns - Optional namespace to append to each event\n     * @returns The mapped and namespaced events\n     */\n    applyEventMap(events: string, ns?: string): string {\n        events = events.replace(this.eventRegEx, (e: string) => this.getEventMap(e));\n\n        if (ns) {\n            events = events.replace(this.eventRegEx, \"$1.\" + ns);\n        }\n\n        return events;\n    }\n}\n","/**\n * Defaults Service\n * Manages global Kendo defaults configuration with deep path support.\n *\n * @module core-v2/services/defaults.service\n */\n\nimport type { IUtilsService } from \"../models/utils\";\n\n/**\n * Generic object type for defaults storage\n */\ntype DefaultsObject = Record<string, unknown>;\n\n/**\n * Service for managing global Kendo defaults configuration.\n * Supports deep path-based setting with automatic object creation.\n */\nexport class DefaultsService {\n    /**\n     * The defaults storage object\n     */\n    private defaults: DefaultsObject = {};\n\n    constructor(private utils: IUtilsService) {}\n\n    /**\n     * Get the current defaults object\n     */\n    getDefaults(): DefaultsObject {\n        return this.defaults;\n    }\n\n    /**\n     * Set a default value at a given path.\n     * Supports dot-separated paths for nested values.\n     * Objects are deep extended, primitives are replaced.\n     *\n     * @param key - Dot-separated path (e.g., \"breakpoints\", \"grid.pager.pageSize\")\n     * @param value - The value to set at the path\n     *\n     * @example\n     * ```typescript\n     * // Set a simple value\n     * setDefaults('pageSize', 10);\n     *\n     * // Set a nested value\n     * setDefaults('grid.pager.pageSize', 20);\n     *\n     * // Deep extend an object\n     * setDefaults('breakpoints', { sm: 576, md: 768 });\n     * ```\n     */\n    setDefaults(key: string, value: unknown): void {\n        const path = key.split(\".\");\n        let curr: DefaultsObject = this.defaults;\n\n        key = path.pop() as string;\n\n        path.forEach((part) => {\n            if (curr[part] === undefined) {\n                curr[part] = {};\n            }\n\n            curr = curr[part] as DefaultsObject;\n        });\n\n        if (value !== null && typeof value === \"object\" && value.constructor === Object) {\n            curr[key] = this.utils.deepExtend({}, curr[key] as object || {}, value as object);\n        } else {\n            curr[key] = value;\n        }\n    }\n\n    /**\n     * Get a default value at a given path.\n     *\n     * @param key - Dot-separated path (e.g., \"breakpoints\", \"grid.pager.pageSize\")\n     * @returns The value at the path, or undefined if not found\n     */\n    getDefault(key: string): unknown {\n        const path = key.split(\".\");\n        let curr: DefaultsObject = this.defaults;\n\n        for (const part of path) {\n            if (curr[part] === undefined) {\n                return undefined;\n            }\n            curr = curr[part] as DefaultsObject;\n        }\n\n        return curr;\n    }\n}\n","/**\n * Widget Registry Service\n * \n * Manages widget registration across different namespaces (ui, mobile.ui, dataviz.ui).\n * Provides both modern service-based access and maintains backward compatibility\n * with legacy kendo.ui.plugin() pattern.\n *\n \n */\n\nimport type {\n    IWidgetRegistryService,\n    IWidgetEntry,\n    IWidgetNamespace,\n    IWidgetRegistrationOptions\n} from \"../models/widget-registry\";\nimport type { WidgetConstructor } from \"../models/widget\";\nimport type { IFormatterService } from \"../models/formatter\";\n\n// Constants\nconst STRING = \"string\";\nconst FUNCTION = \"function\";\n\n/**\n * Widget Registry Service implementation\n */\nexport class WidgetRegistryService implements IWidgetRegistryService<any> {\n    /**\n     * All registered widgets\n     */\n    private widgets: IWidgetEntry<any>[] = [];\n\n    /**\n     * Namespace registers (e.g., { \"ui\": kendo.ui, \"mobile.ui\": kendo.mobile.ui })\n     */\n    private namespaces: Map<string, IWidgetNamespace<any>> = new Map();\n\n    constructor(\n        private $: JQueryStatic,\n        private formatterService: IFormatterService\n    ) {}\n\n    /**\n     * Create a new namespace with roles:{} and register it\n     * This is the primary way to create namespaces - the service owns them.\n     * @param name - Namespace name (e.g., \"ui\", \"mobile.ui\", \"dataviz.ui\")\n     * @param properties - Additional properties to add to the namespace\n     * @returns The created namespace object\n     */\n    createNamespace(name: string, properties?: Record<string, any>): IWidgetNamespace<any> {\n        const namespace: IWidgetNamespace<any> = {\n            roles: {},\n            ...properties\n        };\n        this.namespaces.set(name, namespace);\n        return namespace;\n    }\n\n    /**\n     * Get a namespace register\n     * @param name - Namespace name\n     * @returns The namespace object or undefined\n     */\n    getNamespace(name: string): IWidgetNamespace<any> | undefined {\n        return this.namespaces.get(name);\n    }\n\n    /**\n     * Register a widget using options\n     */\n    register(widget: WidgetConstructor<any>, options: IWidgetRegistrationOptions = {}): void {\n        const namespace = options.namespace || \"ui\";\n        const register = this.namespaces.get(namespace);\n\n        if (!register) {\n            throw new Error(`Unknown widget namespace: ${namespace}`);\n        }\n\n        this.registerToNamespace(widget, register, options.prefix);\n    }\n\n    /**\n     * Register a widget to a specific namespace register\n     * This is the core implementation matching the original kendo.ui.plugin\n     */\n    registerToNamespace(widget: WidgetConstructor<any>, register: IWidgetNamespace<any>, prefix?: string): void {\n        const name = widget.fn.options.name || (widget as any).options?.name;\n\n        if (!name) {\n            throw new Error(\"Widget must have a name in options\");\n        }\n\n        prefix = prefix || \"\";\n\n        // Register to namespace\n        register[name] = widget;\n        register.roles[name.toLowerCase()] = widget;\n\n        // Create jQuery plugin\n        const getter = \"getKendo\" + prefix + name;\n        const pluginName = \"kendo\" + prefix + name;\n\n        this.createJQueryPlugin(pluginName, widget, getter);\n\n        // Track widget entry\n        const widgetEntry: IWidgetEntry<any> = {\n            name: pluginName,\n            widget: widget,\n            prefix: prefix\n        };\n\n        this.widgets.push(widgetEntry);\n    }\n\n    /**\n     * Get a widget by name\n     */\n    getWidget(name: string, namespace?: string): WidgetConstructor<any> | undefined {\n        if (namespace) {\n            const register = this.namespaces.get(namespace);\n            return register?.[name];\n        }\n\n        // Search all namespaces\n        for (const register of this.namespaces.values()) {\n            if (register[name]) {\n                return register[name];\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Get a widget by role name\n     */\n    getWidgetByRole(role: string, namespace?: string): WidgetConstructor<any> | undefined {\n        const lowerRole = role.toLowerCase();\n\n        if (namespace) {\n            const register = this.namespaces.get(namespace);\n            return register?.roles[lowerRole];\n        }\n\n        // Search all namespaces\n        for (const register of this.namespaces.values()) {\n            if (register.roles[lowerRole]) {\n                return register.roles[lowerRole];\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Get all registered widgets\n     */\n    getAllWidgets(): IWidgetEntry<any>[] {\n        return this.widgets.slice(); // Return a copy\n    }\n\n    /**\n     * Get widget instance from an element\n     */\n    getWidgetInstance(element: HTMLElement | JQuery, namespace?: IWidgetNamespace<any>): any {\n        const el = this.$(element);\n        let result: any;\n\n        const searchNamespaces = namespace ? [namespace] : Array.from(this.namespaces.values());\n\n        for (const ns of searchNamespaces) {\n            for (const role in ns.roles) {\n                const widget = ns.roles[role];\n                const prefix = widget.fn?.options?.prefix || \"\";\n                const dataKey = \"kendo\" + prefix + (widget.fn?.options?.name || \"\");\n                result = el.data(dataKey);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Create jQuery plugin for a widget\n     */\n    createJQueryPlugin(name: string, widget: WidgetConstructor<any>, getter: string): void {\n        const $ = this.$;\n        const formatterService = this.formatterService;\n        const slice = Array.prototype.slice;\n\n        ($.fn as any)[name] = function(this: JQuery, options?: any) {\n            let value: any = this;\n            let args: any[];\n\n            if (typeof options === STRING) {\n                args = slice.call(arguments, 1);\n\n                this.each(function(this: HTMLElement) {\n                    const widgetInstance = $.data(this, name);\n                    let method: any;\n                    let result: any;\n\n                    if (!widgetInstance) {\n                        throw new Error(formatterService.format(\"Cannot call method '{0}' of {1} before it is initialized\", options, name));\n                    }\n\n                    method = widgetInstance[options];\n\n                    if (typeof method !== FUNCTION) {\n                        throw new Error(formatterService.format(\"Cannot find method '{0}' of {1}\", options, name));\n                    }\n\n                    result = method.apply(widgetInstance, args);\n\n                    if (result !== undefined) {\n                        value = result;\n                        return false;\n                    }\n                });\n            } else {\n                this.each(function(this: HTMLElement) {\n                    return new (widget as any)(this, options);\n                });\n            }\n\n            return value;\n        };\n\n        ($.fn as any)[name].widget = widget;\n\n        ($.fn as any)[getter] = function(this: JQuery) {\n            return this.data(name);\n        };\n    }\n\n    /**\n     * Merge roles from multiple namespaces into a single object\n     * Uses jQuery extend to match original behavior exactly\n     */\n    rolesFromNamespaces(namespaces: IWidgetNamespace<any>[], defaultNamespaces?: IWidgetNamespace<any>[]): Record<string, WidgetConstructor<any>> {\n        const roles: Record<string, WidgetConstructor<any>>[] = [];\n        let idx: number;\n        let length: number;\n\n        // Use default namespaces if none provided or first element is falsy\n        if (!namespaces[0] && defaultNamespaces) {\n            namespaces = defaultNamespaces;\n        }\n\n        for (idx = 0, length = namespaces.length; idx < length; idx++) {\n            roles[idx] = namespaces[idx].roles;\n        }\n\n        // Use $.extend.apply to match original: extend.apply(null, [{}].concat(roles.reverse()))\n        return this.$.extend.apply(null, ([{}] as any[]).concat(roles.reverse()));\n    }\n}\n","/**\n * Widget Utils Service\n *\n * Provides utilities for widget initialization, lifecycle management, and instance retrieval.\n * All methods preserve exact original functionality from kendo.core.js.\n *\n */\n\nimport type { IWidgetUtilsService, IParsedOptions } from \"../models/widget-utils\";\nimport type { IWidgetRegistryService, IWidgetNamespace } from \"../models/widget-registry\";\nimport type { IPropertyAccessService } from \"../models/property-access\";\nimport type { ITemplateService } from \"../models/template\";\nimport type { IUtilsService } from \"../models/utils\";\nimport type { INamespaceService } from \"../models/namespace\";\nimport type { WidgetConstructor } from \"../models/widget\";\n\n// Constants - match original kendo.core.js\nconst STRING = \"string\";\nconst FUNCTION = \"function\";\n\n// RegExps - match original kendo.core.js exactly\nconst templateRegExp = /template$/i;\nconst jsonRegExp = /^\\s*(?:\\{(?:.|\\r\\n|\\n)*\\}|\\[(?:.|\\r\\n|\\n)*\\])\\s*$/;\nconst jsonFormatRegExp = /^\\{(\\d+)(:[^\\}]+)?\\}|^\\[[A-Za-z_]+\\]$/;\nconst dashRegExp = /([A-Z])/g;\nconst numberRegExp = /^(\\+|-?)\\d+(\\.?)\\d*$/;\n\nconst cssPropertiesNames = [\"themeColor\", \"fillMode\", \"shape\", \"size\", \"rounded\", \"positionMode\"];\n\n/**\n * Widget Utils Service Implementation\n */\nexport class WidgetUtilsService implements IWidgetUtilsService {\n    constructor(\n        private $: JQueryStatic,\n        private widgetRegistryService: IWidgetRegistryService<any>,\n        private propertyAccessService: IPropertyAccessService,\n        private templateService: ITemplateService,\n        private utilsService: IUtilsService,\n        private Observable: any,\n        private namespaceService: INamespaceService\n    ) {}\n\n    /**\n     * Get default namespaces from the registry service\n     * Returns [kendo.ui, kendo.dataviz.ui, kendo.mobile.ui]\n     */\n    private getDefaultNamespaces(): IWidgetNamespace<any>[] {\n        return [\n            this.widgetRegistryService.getNamespace(\"ui\"),\n            this.widgetRegistryService.getNamespace(\"dataviz.ui\"),\n            this.widgetRegistryService.getNamespace(\"mobile.ui\")\n        ].filter(Boolean) as IWidgetNamespace<any>[];\n    }\n\n    /**\n     * Parse a single option from element's data attribute\n     */\n    parseOption(element: HTMLElement, option: string, source?: any): any {\n        const ns = this.namespaceService.ns;\n        let value: any;\n        let modelBinded = false;\n\n        if (option.indexOf(\"data\") === 0) {\n            option = option.substring(4);\n            option = option.charAt(0).toLowerCase() + option.substring(1);\n        }\n\n        option = option.replace(dashRegExp, \"-$1\");\n        value = element.getAttribute(\"data-\" + ns + option);\n\n        if (value === null) {\n            value = element.getAttribute(\"bind:data-\" + ns + option);\n            modelBinded = true;\n        }\n\n        if (value === null) {\n            value = undefined;\n        } else if (value === \"null\") {\n            value = null;\n        } else if (value === \"true\") {\n            value = true;\n        } else if (value === \"false\") {\n            value = false;\n        } else if (numberRegExp.test(value) && option != \"mask\" && option != \"format\") {\n            value = parseFloat(value);\n        } else if (jsonRegExp.test(value) && !jsonFormatRegExp.test(value)) {\n            try {\n                value = JSON.parse(value);\n            } catch (error) {\n                // Fallback to function eval for legacy reason - non CSP compliant\n                value = new Function(\"return (\" + value + \")\")();\n            }\n        } else if (modelBinded) {\n            // This way you can set a config like so bind:data-checkboxes=\"checkboxesOptions\" where checkboxesOptions is an object inside your viewmodel.\n            // This is a CSP-safe approach similar to data-checkboxes=\"{ checkboxes: true }\" but you don't need to eval javascript.\n            value = source[value];\n\n            if (value instanceof this.Observable) {\n                // Pass true as a parameter to allow function serialization. Otherwise, if you have a function in the configuration, it will be ignored.\n                value = value.toJSON(true);\n            }\n        }\n\n        return value;\n    }\n\n    /**\n     * Parse all options from element's data attributes\n     */\n    parseOptions(element: HTMLElement, options: Record<string, any>, source?: any): IParsedOptions {\n        const $ = this.$;\n        const ns = this.namespaceService.ns;\n        const result: IParsedOptions = {};\n        let option: string;\n        let value: any;\n        const role = element.getAttribute(\"data-\" + ns + \"role\");\n\n        // Combine options keys with CSS appearance properties to ensure they're always parsed\n        // even when their default value is undefined (which gets stripped by $.extend)\n        const allOptions = Object.keys(options);\n\n        for (let i = 0; i < cssPropertiesNames.length; i++) {\n            if (allOptions.indexOf(cssPropertiesNames[i]) === -1) {\n                allOptions.push(cssPropertiesNames[i]);\n            }\n        }\n\n        for (let i = 0; i < allOptions.length; i++) {\n            option = allOptions[i];\n            // Pass the source option for MVVM scenarios.\n            value = this.parseOption(element, option, source);\n\n            if (value !== undefined) {\n\n                if (templateRegExp.test(option) && role != \"drawer\") {\n                    if (typeof value === \"string\") {\n                        if (this.validateQuerySelectorTemplate(value)) {\n                            value = this.templateService.compile($(\"#\" + value).html());\n                        } else if (source && source[value]) {\n                            value = this.templateService.compile(source[value]);\n                        } else {\n                            value = this.templateService.compile(value);\n                        }\n                    } else if (!this.utilsService.isFunction(value)) {\n                        value = element.getAttribute(option);\n                    }\n                }\n\n                result[option] = value;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Validate if a value is a valid query selector for a template element\n     */\n    validateQuerySelectorTemplate(value: string): boolean {\n        try {\n            return !!(this.$(\"#\" + value).length);\n        } catch (e) {\n        }\n\n        return false;\n    }\n\n    /**\n     * Initialize a widget on an element\n     */\n    initWidget(element: HTMLElement | JQuery, options?: Record<string, any>, roles?: Record<string, WidgetConstructor<any>> | IWidgetNamespace<any>, source?: any): any {\n        const $ = this.$;\n        const ns = this.namespaceService.ns;\n        let result: any;\n        let option: string;\n        let widget: WidgetConstructor<any> | undefined;\n        let idx: number;\n        let length: number;\n        let role: string | null;\n        let value: any;\n        let dataSource: any;\n        let fullPath: boolean;\n        let widgetKeyRegExp: RegExp;\n\n        // Preserve backwards compatibility with (element, options, namespace) signature, where namespace was kendo.ui\n        if (!roles) {\n            roles = this.getDefaultNamespaces()[0].roles;\n        } else if ((roles as IWidgetNamespace<any>).roles) {\n            roles = (roles as IWidgetNamespace<any>).roles;\n        }\n\n        element = (element as any).nodeType ? element as HTMLElement : (element as JQuery)[0];\n\n        role = (element as HTMLElement).getAttribute(\"data-\" + ns + \"role\");\n\n        if (!role) {\n            return;\n        }\n\n        fullPath = role.indexOf(\".\") === -1;\n\n        // look for any widget that may be already instantiated based on this role.\n        // The prefix used is unknown, hence the regexp\n        //\n\n        if (fullPath) {\n            widget = (roles as Record<string, WidgetConstructor<any>>)[role];\n        } else { // full namespace path - like kendo.ui.Widget\n            widget = this.propertyAccessService.getter(role)(window);\n        }\n\n        const data = $(element).data();\n        const widgetKey = widget ? \"kendo\" + (widget as any).fn.options.prefix + (widget as any).fn.options.name : \"\";\n\n        if (fullPath) {\n            widgetKeyRegExp = new RegExp(\"^kendo.*\" + role + \"$\", \"i\");\n        } else { // full namespace path - like kendo.ui.Widget\n            widgetKeyRegExp = new RegExp(\"^\" + widgetKey + \"$\", \"i\");\n        }\n\n        for (var key in data) {\n            if (key.match(widgetKeyRegExp)) {\n                // we have detected a widget of the same kind - save its reference, we will set its options\n                if (key === widgetKey) {\n                    result = data[key];\n                } else {\n                    return data[key];\n                }\n            }\n        }\n\n        if (!widget) {\n            return;\n        }\n\n        dataSource = this.parseOption(element as HTMLElement, \"dataSource\");\n\n        options = $.extend({}, this.parseOptions(element as HTMLElement, $.extend({}, (widget as any).fn.options, (widget as any).fn.defaults), source), options);\n\n        if (dataSource) {\n            if (typeof dataSource === STRING) {\n                options.dataSource = this.propertyAccessService.getter(dataSource)(window);\n            } else {\n                options.dataSource = dataSource;\n            }\n        }\n\n        for (idx = 0, length = (widget as any).fn.events.length; idx < length; idx++) {\n            option = (widget as any).fn.events[idx];\n\n            value = this.parseOption(element as HTMLElement, option);\n\n            if (value !== undefined) {\n                options[option] = this.propertyAccessService.getter(value)(window);\n            }\n        }\n\n        if (!result) {\n            result = new (widget as any)(element, options);\n        } else if (!$.isEmptyObject(options)) {\n            result.setOptions(options);\n        }\n\n        return result;\n    }\n\n    /**\n     * Initialize all widgets in an element tree\n     */\n    init(element: HTMLElement | JQuery, ...namespaces: IWidgetNamespace<any>[]): void {\n        const $ = this.$;\n        const ns = this.namespaceService.ns;\n        const roles = this.widgetRegistryService.rolesFromNamespaces(namespaces, this.getDefaultNamespaces());\n        const self = this;\n\n        $(element).find(\"[data-\" + ns + \"role]\").addBack().each(function(this: HTMLElement) {\n            self.initWidget(this, {}, roles);\n        });\n    }\n\n    /**\n     * Destroy all widgets in an element tree\n     */\n    destroy(element: HTMLElement | JQuery): void {\n        const $ = this.$;\n        const ns = this.namespaceService.ns;\n\n        $(element).find(\"[data-\" + ns + \"role]\").addBack().each(function(this: HTMLElement) {\n            const data = $(this).data();\n\n            for (var key in data) {\n                if (key.indexOf(\"kendo\") === 0 && typeof data[key].destroy === FUNCTION) {\n                    data[key].destroy();\n                }\n            }\n        });\n    }\n\n    /**\n     * Containment comparer for sorting widgets by DOM hierarchy\n     */\n    private containmentComparer(a: HTMLElement, b: HTMLElement): number {\n        return this.$.contains(a, b) ? -1 : 1;\n    }\n\n    /**\n     * Resize all widgets in an element tree\n     */\n    resize(element: HTMLElement | JQuery, force?: boolean): void {\n        const $ = this.$;\n        const ns = this.namespaceService.ns;\n        const self = this;\n\n        // Create resizableWidget filter with proper context\n        const resizableWidgetFilter = function(this: HTMLElement): boolean {\n            const widget = $(this);\n            return ($.inArray(widget.attr(\"data-\" + ns + \"role\"), [\"slider\", \"rangeslider\", \"breadcrumb\"]) > -1) || widget.is(\":visible\");\n        };\n\n        const widgets = $(element).find(\"[data-\" + ns + \"role]\").addBack().filter(resizableWidgetFilter);\n\n        if (!widgets.length) {\n            return;\n        }\n\n        // sort widgets based on their parent-child relation\n        const widgetsArray = $.makeArray(widgets);\n        widgetsArray.sort((a: HTMLElement, b: HTMLElement) => self.containmentComparer(a, b));\n\n        // resize widgets\n        $.each(widgetsArray, function(this: HTMLElement) {\n            const widget = self.widgetInstance($(this));\n            if (widget) {\n                widget.resize(force);\n            }\n        });\n    }\n\n    /**\n     * Get widget instance from a DOM element\n     */\n    widgetInstance(element: JQuery, suites?: IWidgetNamespace<any> | IWidgetNamespace<any>[]): any {\n        const ns = this.namespaceService.ns;\n        const defaultNamespaces = this.getDefaultNamespaces();\n        let role = element.data(ns + \"role\");\n        let widgets: (WidgetConstructor<any> | undefined)[] = [];\n        let i: number;\n        let length: number;\n        const elementData = element.data(\"kendoView\");\n\n        if (role) {\n            // HACK!!! mobile view scroller widgets are instantiated on data-role=\"content\" elements. We need to discover them when resizing.\n            if (role === \"content\") {\n                role = \"scroller\";\n            }\n\n            // kendo.View is not a ui plugin\n\n            if (role === \"view\" && elementData) {\n                return elementData;\n            }\n\n            if (suites) {\n                if ((suites as IWidgetNamespace<any>[])[0]) {\n                    for (i = 0, length = (suites as IWidgetNamespace<any>[]).length; i < length; i++) {\n                        widgets.push((suites as IWidgetNamespace<any>[])[i].roles[role]);\n                    }\n                } else {\n                    widgets.push((suites as IWidgetNamespace<any>).roles[role]);\n                }\n            }\n            else {\n                // Use default namespaces: [kendo.ui, kendo.dataviz.ui, kendo.mobile.ui]\n                widgets = defaultNamespaces.map(ns => ns.roles[role]);\n            }\n\n            if (role.indexOf(\".\") >= 0) {\n                widgets = [this.propertyAccessService.getter(role)(window)];\n            }\n\n            for (i = 0, length = widgets.length; i < length; i++) {\n                const widget = widgets[i];\n                if (widget) {\n                    const instance = element.data(\"kendo\" + (widget as any).fn.options.prefix + (widget as any).fn.options.name);\n                    if (instance) {\n                        return instance;\n                    }\n                }\n            }\n        }\n    }\n}\n","/**\n * Namespace Service\n *\n * Manages the data attribute namespace prefix used throughout Kendo UI.\n * This allows customization of data-role attributes (e.g., data-kendo-role instead of data-role).\n */\n\nimport type { INamespaceService } from \"../models/namespace\";\n\nexport class NamespaceService implements INamespaceService {\n    private _ns: string = \"\";\n\n    /**\n     * Get the current namespace prefix\n     */\n    get ns(): string {\n        return this._ns;\n    }\n\n    /**\n     * Set the namespace prefix\n     * @param value - The namespace prefix (e.g., \"kendo-\")\n     */\n    setNs(value: string): void {\n        this._ns = value;\n    }\n}\n","/**\n * Kendo UI PromptBox Widget\n *\n * This file serves as the entry point for the PromptBox widget.\n */\nimport \"./kendo.core.js\";\nimport \"./kendo.textarea.js\";\nimport \"./kendo.textbox.js\";\nimport \"./kendo.html.button.js\";\nimport { PromptBox } from \"./promptbox\";\nimport { inject, WidgetRegistryService } from \"./core\";\n\nexport const __meta__ = {\n    id: \"promptbox\",\n    name: \"PromptBox\",\n    category: \"web\",\n    description: \"The PromptBox component - a composite input for chat interfaces.\",\n    depends: [\"core\", \"textarea\", \"textbox\", \"html.button\"]\n};\n\n// Register the widget\ninject(WidgetRegistryService).register(PromptBox);\n\n// Re-export for consumers\nexport { PromptBox };\n\nexport default kendo;\n"],"mappings":"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"}