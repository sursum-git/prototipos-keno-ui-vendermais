{"version":3,"file":"kendo.pivot.configurator.min.js","names":["serializeFilters","serializeFilters","count","identity","formatDate","join","serialize","serializeFilter","serializeSort","concat","rules","serializeFilter","take","skip","identity","identity","selectors","keyboardEvents","mouseEvents"],"sources":["../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/requests/serializers/filters.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/requests/serializers/members.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/requests/requestBuilder.js","../../node_modules/tslib/tslib.es6.mjs","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/responses/responseParser.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/requests/discover.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/responses/discoverParser.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/requests/fetch.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/utils/index.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/dataState/dataState.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/dataState/expand.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/dataState/sort.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/dataState/filter.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/reducers/headers-reducer.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/reducers/configurator-reducer.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/local-data-binding/aggregates.js","../../node_modules/@progress/kendo-data-query/dist/es2015/utils.js","../../node_modules/@progress/kendo-data-query/dist/es2015/filtering/filter-descriptor.interface.js","../../node_modules/@progress/kendo-data-query/dist/es2015/funcs.js","../../node_modules/@progress/kendo-data-query/dist/es2015/filter-serialization.common.js","../../node_modules/@progress/kendo-data-query/dist/es2015/filtering/filter.operators.js","../../node_modules/@progress/kendo-data-query/dist/es2015/odata-filtering.operators.js","../../node_modules/@progress/kendo-data-query/dist/es2015/odata.operators.js","../../node_modules/@progress/kendo-data-query/dist/es2015/accessor.js","../../node_modules/@progress/kendo-data-query/dist/es2015/mvc/operators.js","../../node_modules/@progress/kendo-data-query/dist/es2015/mvc/deserialization.js","../../node_modules/@progress/kendo-data-query/dist/es2015/sorting/sort-array.operator.js","../../node_modules/@progress/kendo-data-query/dist/es2015/transducers.js","../../node_modules/@progress/kendo-data-query/dist/es2015/grouping/aggregate.operators.js","../../node_modules/@progress/kendo-data-query/dist/es2015/filtering/filter-no-eval.js","../../node_modules/@progress/kendo-data-query/dist/es2015/filtering/filter-expression.factory.js","../../node_modules/@progress/kendo-data-query/dist/es2015/grouping/group.operators.js","../../node_modules/@progress/kendo-data-query/dist/es2015/array.operators.js","../../node_modules/@progress/kendo-data-query/dist/es2015/filtering/operators.enum.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/local-data-binding/filtering.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/local-data-binding/utils.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/local-data-binding/dataTree.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/local-data-binding/dataReader.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/local-data-binding/tuples.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/local-data-binding/schemaDimensions.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/navigation/navigation.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/navigation/pivotgrid.js","../../node_modules/@progress/kendo-pivotgrid-common/dist/es2015/navigation/configurator.js","../../src/kendo.pivot.configurator.js"],"sourcesContent":["const filterFunctionFormats = {\n    contains: \", InStr({0}.CurrentMember.MEMBER_CAPTION,\\\"{1}\\\") > 0\",\n    doesnotcontain: \", InStr({0}.CurrentMember.MEMBER_CAPTION,\\\"{1}\\\")\",\n    endswith: \", Right({0}.CurrentMember.MEMBER_CAPTION,Len(\\\"{1}\\\"))=\\\"{1}\\\"\",\n    eq: \", {0}.CurrentMember.MEMBER_CAPTION = \\\"{1}\\\"\",\n    neq: \", {0}.CurrentMember.MEMBER_CAPTION = \\\"{1}\\\"\",\n    startswith: \", Left({0}.CurrentMember.MEMBER_CAPTION,Len(\\\"{1}\\\"))=\\\"{1}\\\"\"\n};\nconst operators = {\n    doesnotcontain: 'doesnotcontain',\n    in: 'in',\n    neq: \"neq\"\n};\n/**\n * @hidden\n */\nexport function serializeFilters(filters, cube) {\n    let command = \"\";\n    let current = \"\";\n    for (let idx = filters.length - 1; idx >= 0; idx--) {\n        current = \"SELECT (\";\n        current += serializeExpression(filters[idx]);\n        current += \") ON 0\";\n        if (idx === filters.length - 1) {\n            current += \" FROM [\" + cube + \"]\";\n            command = current;\n        }\n        else {\n            command = current + \" FROM ( \" + command + \" )\";\n        }\n    }\n    return command;\n}\nfunction serializeExpression(expression) {\n    let command = '';\n    const value = String(expression.value);\n    const field = expression.field;\n    const operator = expression.operator;\n    if (operator === operators.in) {\n        command += \"{\";\n        command += value;\n        command += \"}\";\n    }\n    else {\n        command += operator === operators.neq || operator === operators.doesnotcontain ? '-' : '';\n        command += \"Filter(\";\n        command += field + \".MEMBERS\";\n        command += formatString(filterFunctionFormats[operator], field, value);\n        command += \")\";\n    }\n    return command;\n}\nfunction formatString(str, ...values) {\n    values.forEach((value, index) => {\n        str = str.replace(new RegExp(`\\\\{${index}\\\\}`, 'g'), value);\n    });\n    return str;\n}\n","/**\n * @hidden\n */\nexport function serializeMembers(members, measures, sort) {\n    let command = \"\";\n    members = members || [];\n    const parsed = parseDescriptors(members);\n    const expanded = parsed.expanded;\n    const rootNames = getRootNames(parsed.root);\n    const crossJoinCommands = [];\n    const length = expanded.length;\n    let idx = 0;\n    let memberName;\n    let names = [];\n    if (rootNames.length > 1 || measures.length > 0) {\n        crossJoinCommands.push(crossJoinCommand(rootNames, measures));\n        for (; idx < length; idx++) {\n            memberName = expandMemberDescriptor(expanded[idx].name, sort);\n            names = mapNames(memberName, rootNames);\n            crossJoinCommands.push(crossJoinCommand(names, measures));\n        }\n        command += crossJoinCommands.join(\",\");\n    }\n    else {\n        for (; idx < length; idx++) {\n            memberName = expandMemberDescriptor(expanded[idx].name, sort);\n            names.push(memberName[0]);\n        }\n        command += rootNames.concat(names).join(\",\");\n    }\n    return command;\n}\n/**\n * @hidden\n */\nexport function measureNames(measures) {\n    const length = measures.length;\n    const result = [];\n    let measure;\n    for (let idx = 0; idx < length; idx++) {\n        measure = measures[idx];\n        result.push(measure.name !== undefined ? measure.name : measure);\n    }\n    return result;\n}\nfunction getRootNames(members) {\n    const root = [];\n    members.forEach(member => {\n        const name = member.name[0];\n        const hierarchyName = baseHierarchyPath(name);\n        if (!root.some(n => n.indexOf(hierarchyName) === 0)) {\n            root.push(name);\n        }\n    });\n    return root;\n}\nfunction parseDescriptors(members) {\n    let expanded = [];\n    const child = [];\n    const root = [];\n    let idx = 0;\n    let found;\n    for (; idx < members.length; idx++) {\n        const member = members[idx];\n        const name = member.name;\n        found = false;\n        if (name.length > 1) {\n            child.push(member);\n        }\n        else {\n            const hierarchyName = baseHierarchyPath(name[0]);\n            for (let j = 0, l = root.length; j < l; j++) {\n                if (root[j].name[0].indexOf(hierarchyName) === 0) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                root.push(member);\n            }\n            if (member.expand) {\n                expanded.push(member);\n            }\n        }\n    }\n    expanded = expanded.concat(child);\n    return {\n        expanded: expanded,\n        root: root\n    };\n}\nfunction mapNames(names, rootNames) {\n    const rootLength = rootNames.length;\n    rootNames = rootNames.slice(0);\n    for (let idx = 0; idx < names.length; idx++) {\n        const name = names[idx];\n        for (let j = 0; j < rootLength; j++) {\n            const rootName = baseHierarchyPath(rootNames[j]);\n            if (name.indexOf(rootName) !== -1) {\n                rootNames[j] = name;\n                break;\n            }\n        }\n    }\n    return rootNames;\n}\nfunction crossJoinCommand(members, measures) {\n    const tmp = members.slice(0);\n    if (measures.length > 0) {\n        tmp.push(\"{\" + measureNames(measures).join(\",\") + \"}\");\n    }\n    return crossJoin(tmp);\n}\nfunction expandMemberDescriptor(names, sort) {\n    const idx = names.length - 1;\n    let name = names[idx];\n    const sortDescriptor = sortDescriptorForMember(sort, name);\n    if (sortDescriptor && sortDescriptor.dir) {\n        name = \"ORDER(\" + name + \".Children,\" + sortDescriptor.field + \".CurrentMember.MEMBER_CAPTION,\" + sortDescriptor.dir + \")\";\n    }\n    else {\n        name += \".Children\";\n    }\n    names[idx] = name;\n    return names;\n}\nfunction sortDescriptorForMember(sort, member) {\n    for (let idx = 0, length = sort.length; idx < length; idx++) {\n        if (member.indexOf(sort[idx].field) === 0) {\n            return sort[idx];\n        }\n    }\n    return null;\n}\nfunction baseHierarchyPath(memberName) {\n    const parts = memberName.split(\".\");\n    if (parts.length > 2) {\n        return parts[0] + \".\" + parts[1];\n    }\n    return memberName;\n}\nfunction crossJoin(names) {\n    let result = \"CROSSJOIN({\";\n    let name;\n    if (names.length > 2) {\n        name = names.pop();\n        result += crossJoin(names);\n    }\n    else {\n        result += names.shift();\n        name = names.pop();\n    }\n    result += \"},{\";\n    result += name;\n    result += \"})\";\n    return result;\n}\n","import { serializeFilters } from './serializers/filters';\nimport { measureNames, serializeMembers } from './serializers/members';\n/**\n * @hidden\n */\nexport function createRequestBody(options) {\n    let command = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Header/><Body><Execute xmlns=\"urn:schemas-microsoft-com:xml-analysis\"><Command><Statement>';\n    let { columnAxes = [], rowAxes = [] } = options;\n    const { measureAxes = [], sort = [], filter = [] } = options;\n    let measuresRowAxis = options.measuresAxis === \"rows\";\n    command += \"SELECT NON EMPTY {\";\n    if (!columnAxes.length && rowAxes.length && (!measureAxes.length || (measureAxes.length && measuresRowAxis))) {\n        columnAxes = rowAxes;\n        rowAxes = [];\n        measuresRowAxis = false;\n    }\n    if (!columnAxes.length && !rowAxes.length) {\n        measuresRowAxis = false;\n    }\n    if (columnAxes.length) {\n        command += serializeMembers(columnAxes, !measuresRowAxis ? measureAxes : [], sort);\n    }\n    else if (measureAxes.length && !measuresRowAxis) {\n        command += measureNames(measureAxes).join(\",\");\n    }\n    command += \"} DIMENSION PROPERTIES CHILDREN_CARDINALITY, PARENT_UNIQUE_NAME ON COLUMNS\";\n    if (rowAxes.length || (measuresRowAxis && measureAxes.length > 1)) {\n        command += \", NON EMPTY {\";\n        if (rowAxes.length) {\n            command += serializeMembers(rowAxes, measuresRowAxis ? measureAxes : [], sort);\n        }\n        else {\n            command += measureNames(measureAxes).join(\",\");\n        }\n        command += \"} DIMENSION PROPERTIES CHILDREN_CARDINALITY, PARENT_UNIQUE_NAME ON ROWS\";\n    }\n    if (filter.length) {\n        command += \" FROM \";\n        command += \"(\";\n        command += serializeFilters(filter, options.connection.cube);\n        command += \")\";\n    }\n    else {\n        command += \" FROM [\" + options.connection.cube + \"]\";\n    }\n    command += '</Statement></Command><Properties><PropertyList><Catalog>' + options.connection.catalog + '</Catalog><Format>Multidimensional</Format></PropertyList></Properties></Execute></Body></Envelope>';\n    return command.replace(/&/g, \"&amp;\");\n}\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","/**\n * @hidden\n */\nexport function parseResponse(response) {\n    const xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n    const axes = Array.from(xmlDoc.querySelectorAll(\"Axis\"));\n    const cells = Array.from(xmlDoc.querySelectorAll(\"CellData > Cell\"))\n        .map(cell => ({\n        fmtValue: getPropertyValue(cell, \"FmtValue\"),\n        ordinal: parseInt(cell.getAttribute(\"CellOrdinal\"), 10),\n        value: getPropertyValue(cell, \"Value\")\n    }));\n    const columns = { tuples: [] };\n    const rows = { tuples: [] };\n    const data = [];\n    axes.forEach((axis) => {\n        if (axis.getAttribute('name') !== \"SlicerAxis\") {\n            const tuples = columns.tuples.length === 0 ? columns.tuples : rows.tuples;\n            Array.prototype.push.apply(tuples, translateAxis(axis));\n        }\n    });\n    const indexedData = new Array(rows.tuples.length * columns.tuples.length).fill(null);\n    cells.forEach(c => { indexedData[c.ordinal] = c; });\n    let counter = 0;\n    rows.tuples.forEach((rowTuple) => {\n        columns.tuples.forEach((colTuple) => {\n            data.push({\n                columnTuple: colTuple,\n                data: indexedData[counter],\n                rowTuple: rowTuple\n            });\n            counter++;\n        });\n    });\n    return { columns, data, rows };\n}\n/**\n * @hidden\n */\nexport function getPropertyValue(member, name) {\n    const node = member.querySelector(name);\n    return node ? node.textContent : \"\";\n}\nfunction translateAxis(axis) {\n    const tuples = Array.from(axis.querySelectorAll(\"Tuple\"));\n    return tuples.map(tuple => {\n        const memberElements = Array.from(tuple.querySelectorAll(\"Member\"));\n        const members = memberElements.map(member => {\n            const lNum = parseInt(getPropertyValue(member, \"LNum\") || \"0\", 10);\n            const hasChildren = parseInt(getPropertyValue(member, \"CHILDREN_CARDINALITY\") || \"0\", 10) > 0;\n            return {\n                caption: getPropertyValue(member, \"Caption\"),\n                children: [],\n                hasChildren: hasChildren,\n                hierarchy: member.getAttribute('Hierarchy'),\n                levelName: getPropertyValue(member, \"LName\"),\n                levelNum: lNum,\n                name: getPropertyValue(member, \"UName\"),\n                parentName: getPropertyValue(member, \"PARENT_UNIQUE_NAME\")\n            };\n        });\n        return { members };\n    });\n}\n","/**\n * @hidden\n */\nexport const discoverCommands = {\n    schemaCatalogs: \"DBSCHEMA_CATALOGS\",\n    schemaCubes: \"MDSCHEMA_CUBES\",\n    schemaDimensions: \"MDSCHEMA_DIMENSIONS\",\n    schemaHierarchies: \"MDSCHEMA_HIERARCHIES\",\n    schemaKPIs: \"MDSCHEMA_KPIS\",\n    schemaLevels: \"MDSCHEMA_LEVELS\",\n    schemaMeasures: \"MDSCHEMA_MEASURES\",\n    schemaMembers: \"MDSCHEMA_MEMBERS\"\n};\n/**\n * @hidden\n */\nexport function createDiscoverBody(options) {\n    const properties = {};\n    let command = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Header/><Body><Discover xmlns=\"urn:schemas-microsoft-com:xml-analysis\">';\n    command += \"<RequestType>\" + (discoverCommands[options.command] || options.command) + \"</RequestType>\";\n    command += \"<Restrictions>\" + serializeOptions(\"RestrictionList\", options.restrictions, true) + \"</Restrictions>\";\n    if (options.connection && options.connection.catalog) {\n        properties.Catalog = options.connection.catalog;\n    }\n    command += \"<Properties>\" + serializeOptions(\"PropertyList\", properties, false) + \"</Properties>\";\n    command += '</Discover></Body></Envelope>';\n    return command;\n}\nfunction serializeOptions(parentTagName, options, capitalize) {\n    let result = \"\";\n    if (options) {\n        result += \"<\" + parentTagName + \">\";\n        let value;\n        for (let key in options) {\n            if (options[key]) {\n                value = options[key];\n                if (capitalize) {\n                    key = key.replace(/([A-Z]+(?=$|[A-Z][a-z])|[A-Z]?[a-z]+)/g, \"$1_\").toUpperCase().replace(/_$/, \"\");\n                }\n                result += \"<\" + key + \">\" + value + \"</\" + key + \">\";\n            }\n        }\n        result += \"</\" + parentTagName + \">\";\n    }\n    else {\n        result += \"<\" + parentTagName + \"/>\";\n    }\n    return result;\n}\n","import { getPropertyValue } from './responseParser';\n/**\n * @hidden\n */\nexport function parseCubes(response) {\n    const xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n    const rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\"))\n        .map(row => ({\n        name: getPropertyValue(row, \"CUBE_NAME\"),\n        caption: getPropertyValue(row, \"CUBE_CAPTION\"),\n        description: getPropertyValue(row, \"DESCRIPTION\"),\n        type: getPropertyValue(row, \"CUBE_TYPE\")\n    }));\n    return rows;\n}\n/**\n * @hidden\n */\nexport function parseCatalogs(response) {\n    const xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n    const rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\"))\n        .map(row => ({\n        name: getPropertyValue(row, \"CATALOG_NAME\"),\n        description: getPropertyValue(row, \"DESCRIPTION\")\n    }));\n    return rows;\n}\n/**\n * @hidden\n */\nexport function parseMeasures(response) {\n    const xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n    const rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\"))\n        .map(row => ({\n        name: getPropertyValue(row, \"MEASURE_NAME\"),\n        caption: getPropertyValue(row, \"MEASURE_CAPTION\"),\n        uniqueName: getPropertyValue(row, \"MEASURE_UNIQUE_NAME\"),\n        description: getPropertyValue(row, \"DESCRIPTION\"),\n        aggregator: getPropertyValue(row, \"MEASURE_AGGREGATOR\"),\n        groupName: getPropertyValue(row, \"MEASUREGROUP_NAME\"),\n        displayFolder: getPropertyValue(row, \"MEASURE_DISPLAY_FOLDER\"),\n        defaultFormat: getPropertyValue(row, \"DEFAULT_FORMAT_STRING\")\n    }));\n    return rows;\n}\n/**\n * @hidden\n */\nexport function parseKPIs(response) {\n    const xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n    const rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\"))\n        .map(row => ({\n        name: getPropertyValue(row, \"KPI_NAME\"),\n        uniqueName: getPropertyValue(row, \"KPI_NAME\"),\n        caption: getPropertyValue(row, \"KPI_CAPTION\"),\n        value: getPropertyValue(row, \"KPI_VALUE\"),\n        goal: getPropertyValue(row, \"KPI_GOAL\"),\n        status: getPropertyValue(row, \"KPI_STATUS\"),\n        trend: getPropertyValue(row, \"KPI_TREND\"),\n        statusGraphic: getPropertyValue(row, \"KPI_STATUS_GRAPHIC\"),\n        trendGraphic: getPropertyValue(row, \"KPI_TREND_GRAPHIC\"),\n        description: getPropertyValue(row, \"KPI_DESCRIPTION\"),\n        groupName: getPropertyValue(row, \"MEASUREGROUP_NAME\"),\n        type: \"kpi\"\n    }));\n    return rows;\n}\n/**\n * @hidden\n */\nexport function parseDimensions(response) {\n    const xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n    const rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\"))\n        .map(row => ({\n        caption: getPropertyValue(row, \"DIMENSION_CAPTION\"),\n        defaultHierarchy: getPropertyValue(row, \"DEFAULT_HIERARCHY\"),\n        description: getPropertyValue(row, \"DESCRIPTION\"),\n        name: getPropertyValue(row, \"DIMENSION_NAME\"),\n        type: parseInt(getPropertyValue(row, \"DIMENSION_TYPE\"), 10),\n        uniqueName: getPropertyValue(row, \"DIMENSION_UNIQUE_NAME\")\n    }));\n    return rows;\n}\n/**\n * @hidden\n */\nexport function parseHierarchies(response) {\n    const xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n    const rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\"))\n        .map(row => ({\n        name: getPropertyValue(row, \"HIERARCHY_NAME\"),\n        caption: getPropertyValue(row, \"HIERARCHY_CAPTION\"),\n        description: getPropertyValue(row, \"DESCRIPTION\"),\n        uniqueName: getPropertyValue(row, \"HIERARCHY_UNIQUE_NAME\"),\n        dimensionUniqueName: getPropertyValue(row, \"DIMENSION_UNIQUE_NAME\"),\n        displayFolder: getPropertyValue(row, \"HIERARCHY_DISPLAY_FOLDER\"),\n        origin: getPropertyValue(row, \"HIERARCHY_ORIGIN\"),\n        defaultMember: getPropertyValue(row, \"DEFAULT_MEMBER\")\n    }));\n    return rows;\n}\n/**\n * @hidden\n */\nexport function parseLevels(response) {\n    const xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n    const rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\"))\n        .map(row => ({\n        name: getPropertyValue(row, \"LEVEL_NAME\"),\n        caption: getPropertyValue(row, \"LEVEL_CAPTION\"),\n        description: getPropertyValue(row, \"DESCRIPTION\"),\n        uniqueName: getPropertyValue(row, \"LEVEL_UNIQUE_NAME\"),\n        dimensionUniqueName: getPropertyValue(row, \"DIMENSION_UNIQUE_NAME\"),\n        displayFolder: getPropertyValue(row, \"LEVEL_DISPLAY_FOLDER\"),\n        orderingProperty: getPropertyValue(row, \"LEVEL_ORDERING_PROPERTY\"),\n        origin: getPropertyValue(row, \"LEVEL_ORIGIN\"),\n        hierarchyUniqueName: getPropertyValue(row, \"HIERARCHY_UNIQUE_NAME\")\n    }));\n    return rows;\n}\n/**\n * @hidden\n */\nexport function parseMembers(response) {\n    const xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n    const rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\"))\n        .map(row => ({\n        name: getPropertyValue(row, \"MEMBER_NAME\"),\n        caption: getPropertyValue(row, \"MEMBER_CAPTION\"),\n        uniqueName: getPropertyValue(row, \"MEMBER_UNIQUE_NAME\"),\n        dimensionUniqueName: getPropertyValue(row, \"DIMENSION_UNIQUE_NAME\"),\n        hierarchyUniqueName: getPropertyValue(row, \"HIERARCHY_UNIQUE_NAME\"),\n        levelUniqueName: getPropertyValue(row, \"LEVEL_UNIQUE_NAME\"),\n        childrenCardinality: getPropertyValue(row, \"CHILDREN_CARDINALITY\")\n    }));\n    return rows;\n}\n","import { __awaiter } from \"tslib\";\nimport { createRequestBody } from \"./requestBuilder\";\nimport { parseResponse } from \"../responses/responseParser\";\nimport { createDiscoverBody } from './discover';\nimport { parseMeasures, parseMembers, parseLevels, parseKPIs, parseHierarchies, parseDimensions, parseCubes, parseCatalogs } from '../responses/discoverParser';\nconst discoverParser = {\n    schemaCatalogs: parseCatalogs,\n    schemaCubes: parseCubes,\n    schemaDimensions: parseDimensions,\n    schemaHierarchies: parseHierarchies,\n    schemaKPIs: parseKPIs,\n    schemaLevels: parseLevels,\n    schemaMeasures: parseMeasures,\n    schemaMembers: parseMembers\n};\n/**\n * Fetches the data.\n *\n * @param options RequestOptions\n * @returns Promise<ResponseData>\n *\n * @example\n * const options: RequestOptions = { ... };\n *\n * fetchData(options).then(createDataState).then((dataState: DataState) => {\n *  // Update the UI\n * });\n */\n/**\n * @hidden\n */\nexport const fetchData = (fetchOptions, options) => __awaiter(void 0, void 0, void 0, function* () {\n    const init = Object.assign({ body: createRequestBody(options), headers: { 'Content-Type': 'text/xml' }, method: 'POST' }, fetchOptions.init);\n    const response = yield fetch(fetchOptions.url, init);\n    const stringResponse = yield response.text();\n    return parseResponse(stringResponse);\n});\n/**\n * @hidden\n */\nexport const fetchDiscover = (fetchOptions, options) => __awaiter(void 0, void 0, void 0, function* () {\n    const init = Object.assign({ body: createDiscoverBody(options), headers: { 'Content-Type': 'text/xml' }, method: 'POST' }, fetchOptions.init);\n    const response = yield fetch(fetchOptions.url, init);\n    const stringResponse = yield response.text();\n    return discoverParser[options.command](stringResponse);\n});\n","const isMeasure = (member) => member.hierarchy === '[Measures]';\n// A typical tree depth count won't work for the Pivot,\n// as each branch can have lower number of nodes than the total number of levels\n/**\n * @hidden\n */\nexport const getMaxNesting = (node, set = new Set()) => {\n    (node.children || []).forEach((child) => {\n        set.add(child.levelName);\n        getMaxNesting(child, set);\n    });\n    return set.size;\n};\n/**\n * @hidden\n */\nexport const getMaxExpansion = (node) => {\n    let expanded = 0;\n    (node.children || []).forEach((child) => {\n        expanded += (getMaxExpansion(child) || 1);\n    });\n    return expanded;\n};\n/**\n * @hidden\n */\nexport const generateNormalizedPath = (node, parent) => {\n    return (parent && (parent.hierarchy === node.hierarchy)\n        ? [...(parent.normalizedPath || []).slice(0, -1), node.name || null]\n        : [...((parent && parent.normalizedPath) ? parent.normalizedPath : []), node.name]).filter(Boolean);\n};\n/**\n * @hidden\n */\nexport const generatePath = (node, parent) => {\n    return (parent && (parent.hierarchy === node.hierarchy)\n        ? [...(parent.path || []).slice(0, -1), ((node.levelNum === 0 ? node.hierarchy : node.name) || null)]\n        : [...((parent && parent.path) ? parent.path : []), node.levelNum === 0 ? node.hierarchy : node.name]).filter(Boolean);\n};\n/**\n * @hidden\n */\nexport const toMatrix = (node, rowIndex = -1, colIndex = 0, maxDepth = undefined, maxBreadth = undefined, matrix = undefined, leafs = undefined, parent = undefined) => {\n    const branchDepth = getMaxNesting(node);\n    const branchBreadth = getMaxExpansion(node);\n    const depth = maxDepth || branchDepth;\n    const breadth = maxBreadth || branchBreadth;\n    let matrixResult = matrix ? matrix.slice() : [];\n    let leafsResult = leafs ? leafs.slice() : new Array(breadth);\n    const index = matrixResult.findIndex((l) => l && l.name === node.levelName && l.level === node.levelNum);\n    const level = matrixResult[index];\n    const row = {\n        name: node.levelName,\n        level: node.levelNum,\n        index: rowIndex,\n        cells: new Array(breadth).fill(null)\n    };\n    const inject = rowIndex !== -1 && colIndex !== -1;\n    const cell = {\n        caption: node.caption,\n        name: node.name,\n        levelName: node.levelName,\n        levelNum: node.levelNum,\n        hasChildren: node.hasChildren,\n        parentName: node.parentName,\n        hierarchy: node.hierarchy,\n        total: (node.total !== undefined ? node.total : false) || (parent && parent.children.length <= 1 && parent.total),\n        parent,\n        rowIndex,\n        colIndex,\n        depth: 1,\n        breadth: 1,\n        path: node.path || [],\n        normalizedPath: node.normalizedPath || [],\n        children: node.children.filter(c => c.hierarchy === node.hierarchy)\n    };\n    if (inject) {\n        if (level) {\n            level.cells[colIndex] = cell;\n            if (level.index >= rowIndex) {\n                rowIndex = level.index;\n            }\n        }\n        else {\n            if (matrixResult[rowIndex] && matrixResult[rowIndex].cells.length) {\n                for (let idx = rowIndex; idx < matrixResult.length; idx++) {\n                    const shiftedRow = matrixResult[idx];\n                    shiftedRow.index++;\n                }\n                matrixResult.splice(rowIndex, 0, row);\n                matrixResult[rowIndex].cells[colIndex] = cell;\n            }\n            else {\n                matrixResult[rowIndex] = row;\n                matrixResult[rowIndex].cells[colIndex] = cell;\n            }\n        }\n    }\n    let collOffset = 0;\n    if (node.children && node.children.length) {\n        node.children.forEach((child) => {\n            const [newMatrix, newLeafs, , childBreadth] = toMatrix(child, rowIndex + 1, colIndex + collOffset, depth, breadth, matrixResult, leafsResult, cell);\n            collOffset += (childBreadth || 1);\n            matrixResult = newMatrix.slice();\n            leafsResult = newLeafs.slice();\n        });\n    }\n    else if (node.normalizedPath) {\n        leafsResult[colIndex] = { total: cell.total, path: node.normalizedPath };\n    }\n    cell.depth = branchDepth;\n    cell.breadth = branchBreadth;\n    return [\n        matrixResult,\n        leafsResult,\n        branchDepth,\n        branchBreadth\n    ];\n};\nconst withTotal = (root, parent = null, index = 0) => {\n    let hierarchy;\n    const alt = Object.assign(Object.assign({}, root), { total: true, hasChildren: false, children: [] });\n    for (let childIndex = 0; childIndex < root.children.length; childIndex++) {\n        const child = withTotal(root.children[childIndex], root, childIndex);\n        hierarchy = hierarchy || child.hierarchy;\n        if (child.hierarchy !== hierarchy\n            && parent\n            && !parent.children.some(c => c.total && c.name === alt.name)\n            && !root.total) {\n            alt.children.push(child);\n            root.children.splice(childIndex, 1);\n            childIndex--;\n        }\n    }\n    if (root.children.filter(c => !c.total).length >= 1\n        && parent\n        && !parent.children.some(c => c.total && c.name === alt.name)\n        && !root.total) {\n        const childHierarchy = root.children[0].hierarchy;\n        if (root.hierarchy === childHierarchy) {\n            parent.children.splice(index + 1, 0, alt);\n        }\n    }\n    return root;\n};\n/**\n * @hidden\n */\nexport const toTree = (tuples) => {\n    const root = { children: [] };\n    const map = {};\n    if (tuples.every(t => t.members.length === 1 && isMeasure(t.members[0]))) {\n        // toTree(columnsTuples) - The case where there are only measure(s) and no columns.\n        return {\n            children: tuples.map(t => {\n                const member = t.members[0];\n                return Object.assign(Object.assign({}, member), { normalizedPath: [member.name], parentName: member.name, path: [member.hierarchy] });\n            })\n        };\n    }\n    for (let tupleIndex = 0; tupleIndex < tuples.length; tupleIndex++) {\n        const tuple = copy(tuples[tupleIndex]);\n        let key = \"\";\n        for (let memberIndex = 0; memberIndex < tuple.members.length; memberIndex++) {\n            const member = tuple.members[memberIndex];\n            let parent;\n            if (root.children && root.children.length === 0) {\n                parent = root;\n            }\n            else if (map[key] && !map[key + member.name] && member.levelNum === 0) {\n                parent = map[key];\n            }\n            else if (map[key + member.parentName] && member.levelNum > 0 && !map[key + member.parentName + member.name]) {\n                parent = map[key + member.parentName];\n            }\n            else if (!map[key + member.parentName] && member.levelNum > 0 && !map[key + member.parentName + member.name]) {\n                const parentKey = Object.keys(map).find(e => member.parentName === map[e].name);\n                if (parentKey) {\n                    parent = map[parentKey];\n                }\n            }\n            if (parent) {\n                member.path = generatePath(member, parent);\n                member.normalizedPath = generateNormalizedPath(member, parent);\n                const intruderIndex = parent.children.findIndex(c => c.hierarchy !== parent.hierarchy);\n                if (intruderIndex !== -1) {\n                    parent.children.splice(intruderIndex, 0, member);\n                }\n                else {\n                    parent.children.push(member);\n                }\n            }\n            member.parentName += member.name;\n            key += member.parentName;\n            if (!map[key]) {\n                map[key] = member;\n            }\n        }\n    }\n    return copy(withTotal(root));\n};\n/**\n * @hidden\n */\nexport const toData = (data, columns, rows, breadth, depth) => {\n    const result = Array.from(new Array(depth), () => ({ cells: Array.from(new Array(breadth), () => null) }));\n    const hash = (names) => names.join('|');\n    const membersNames = (tuple) => tuple.members.map(m => m.name);\n    const columnsIndexes = new Map();\n    const rowsIndexes = new Map();\n    columns.forEach((colMembers, idx) => { columnsIndexes.set(hash(colMembers.path), idx); });\n    rows.forEach((rowMembers, idx) => { rowsIndexes.set(hash(rowMembers.path), idx); });\n    data.forEach((item) => {\n        const colIndex = columnsIndexes.get(hash(membersNames(item.columnTuple)));\n        const rowIndex = rowsIndexes.get(hash(membersNames(item.rowTuple)));\n        if (colIndex !== undefined && rowIndex !== undefined) {\n            if (!result[rowIndex].cells[colIndex]) {\n                result[rowIndex].row = rows[rowIndex].path;\n                result[rowIndex].cells[colIndex] = item;\n            }\n        }\n    });\n    return result;\n};\nconst rotateMatrix = (matrix, leafs, depth, breadth) => {\n    const result = new Array(breadth);\n    for (let colIndex = 0; colIndex < breadth; colIndex++) {\n        for (let rowIndex = 0; rowIndex < depth; rowIndex++) {\n            if (matrix[rowIndex] && matrix[rowIndex].cells[colIndex]) {\n                const cell = matrix[rowIndex].cells[colIndex];\n                if (!result[colIndex]) {\n                    result[colIndex] = {\n                        cells: new Array(depth).fill(null)\n                    };\n                }\n                result[colIndex].cells[rowIndex] = Object.assign(Object.assign({}, cell), { rowSpan: cell.colSpan, colSpan: cell.rowSpan });\n            }\n        }\n    }\n    return [result, leafs, breadth, depth];\n};\n/**\n * @hidden\n */\nexport const toColumns = (root) => {\n    const [matrix, leafs, depth, breadth] = toMatrix(root);\n    for (let colIndex = 0; colIndex < breadth; colIndex++) {\n        let cell = null;\n        for (let rowIndex = 0; rowIndex < depth; rowIndex++) {\n            if (matrix[rowIndex]) {\n                const next = matrix[rowIndex].cells[colIndex];\n                if (!next && cell) {\n                    cell.rowSpan = (cell.rowSpan || 1) + 1;\n                }\n                if (cell) {\n                    cell.colSpan = cell.breadth || 1;\n                }\n                if (next) {\n                    cell = next;\n                }\n            }\n        }\n    }\n    return [matrix, leafs, depth, breadth];\n};\n/**\n * @hidden\n */\nexport const toRows = (root) => {\n    const [matrix, leafs, depth, breadth] = toMatrix(root);\n    for (let colIndex = 0; colIndex < breadth; colIndex++) {\n        let cell = null;\n        for (let rowIndex = 0; rowIndex < depth; rowIndex++) {\n            if (matrix[rowIndex]) {\n                const next = matrix[rowIndex].cells[colIndex];\n                if (!next && cell) {\n                    cell.rowSpan = (cell.rowSpan || 1) + 1;\n                }\n                if (cell) {\n                    cell.colSpan = cell.breadth;\n                }\n                if (next) {\n                    cell = next;\n                }\n            }\n        }\n    }\n    return rotateMatrix(matrix, leafs, depth, breadth);\n};\n/**\n * @hidden\n */\nexport const cloneDate = (date) => date ? new Date(date.getTime()) : null;\n/**\n * @hidden\n */\nexport function clone(obj) {\n    const result = {};\n    cloneObject(obj, result);\n    return result;\n}\n/**\n * @hidden\n */\nexport function cloneObject(obj, result) {\n    for (const field in obj) {\n        if (obj.hasOwnProperty(field)) {\n            const value = obj[field];\n            result[field] = cloneValue(value, result[field]);\n        }\n    }\n}\n/**\n * @hidden\n */\nexport function cloneValue(value, nextValue) {\n    if (Array.isArray(value)) {\n        return cloneArray(value);\n    }\n    else if (value instanceof Date) {\n        return cloneDate(value);\n    }\n    else if (value && typeof value === 'object') {\n        const newNextValue = nextValue || {};\n        cloneObject(value, newNextValue);\n        return newNextValue;\n    }\n    else {\n        return value;\n    }\n}\n/**\n * @hidden\n */\nexport function copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n * @hidden\n */\nexport function cloneArray(array) {\n    return array.map(value => cloneValue(value, undefined));\n}\nconst kpiMeasure = (name, measure, type) => {\n    return {\n        hierarchyUniqueName: name,\n        uniqueName: measure,\n        caption: measure,\n        measure: measure,\n        name: measure,\n        type: type,\n        kpi: true\n    };\n};\n/**\n * @hidden\n */\nexport function buildKPIMeasures(node) {\n    const name = node.name;\n    return [\n        kpiMeasure(name, node.value, \"value\"),\n        kpiMeasure(name, node.goal, \"goal\"),\n        kpiMeasure(name, node.status, \"status\"),\n        kpiMeasure(name, node.trend, \"trend\")\n    ];\n}\n/**\n * @hidden\n */\nexport const addKPI = (data) => {\n    let found;\n    let idx = 0;\n    for (; idx < data.length; idx++) {\n        if (data[idx].type === 2) {\n            found = true;\n            break;\n        }\n    }\n    if (found) {\n        data.splice(idx + 1, 0, {\n            caption: \"KPIs\",\n            defaultHierarchy: \"[KPIs]\",\n            name: \"KPIs\",\n            uniqueName: \"[KPIs]\"\n        });\n    }\n};\n/**\n * @hidden\n */\nexport const compareAxisWithField = (a, b) => String(a.name) === String([(b.defaultHierarchy\n        ? b.defaultHierarchy\n        : b.uniqueName)]);\n/**\n * @hidden\n */\nexport const compareAxes = (a, b) => String(a.name) === String(b.name);\n/**\n * @hidden\n */\nexport const filterField = (axes, out) => {\n    for (let i = axes.length - 1; i >= 0; i--) {\n        const axis = axes[i];\n        const index = axis.name.findIndex(name => compareAxisWithField({ name: [name] }, out) || String(name).startsWith(out.uniqueName));\n        if (index !== -1) {\n            if (index === axis.name.length - 1 || axis.name.length === 1) {\n                axes.splice(i, 1);\n            }\n            else {\n                axis.name.splice(index, 1);\n                const duplicatedAxisIndex = axes.findIndex(ax => ax !== axis && String(ax.name) === String(axis.name));\n                if (duplicatedAxisIndex !== -1) {\n                    axes[duplicatedAxisIndex] = Object.assign(Object.assign(Object.assign({}, axes[duplicatedAxisIndex]), axis), ((axes[duplicatedAxisIndex].expand || axis.expand) ? { expand: true } : {}));\n                    axes.splice(i, 1);\n                }\n            }\n        }\n    }\n};\n/**\n * @hidden\n */\nexport const insertAxis = (axes, toInsert, state) => {\n    let index = -1;\n    if (state.dropTarget && state.dropDirection) {\n        const offset = state.dropDirection\n            ? (state.dropDirection === 'before'\n                ? 0\n                : 1)\n            : 0;\n        index = axes.findIndex((c) => compareAxes(c, state.dropTarget)) + offset;\n    }\n    if (index !== -1) {\n        axes.forEach(axis => {\n            if (axis.expand && axis.name.length > 1 && axis.name.length > index) {\n                axis.name.splice(index, 0, ...toInsert.name);\n            }\n        });\n        axes.splice(index, 0, toInsert);\n    }\n    else {\n        axes.push(toInsert);\n    }\n};\n/**\n * @hidden\n */\nexport const reverseColumnsByMeasures = (columns) => {\n    const firstColumn = columns.length && columns[0];\n    const lastMember = firstColumn && firstColumn.members[firstColumn.members.length - 1];\n    if (lastMember && isMeasure(lastMember)) {\n        const columnsArr = [];\n        const measuresCount = new Set(columns.map(col => col.members[col.members.length - 1].caption)).size;\n        for (let i = 0; i < columns.length; i += measuresCount) {\n            columnsArr.push(columns.slice(i, i + measuresCount));\n        }\n        const result = [];\n        columnsArr.forEach(arr => {\n            result.push(...arr.reverse());\n        });\n        return result;\n    }\n    return columns;\n};\n","import { reverseColumnsByMeasures } from \"../utils\";\n/**\n * Creates the state object. See `fetchData`.\n *\n * @param response - ResponseData\n * @returns DataState\n */\n/**\n * @hidden\n */\nexport const createDataState = (response) => {\n    const state = {\n        columns: reverseColumnsByMeasures(response.columns.tuples),\n        data: response.data,\n        rows: response.rows.tuples\n    };\n    return state;\n};\n","/**\n * Creates a collection of AxisDescriptor base on the expandTree.\n * @param expandTree - { [key: string]: boolean }\n * @returns AxisDescriptor[]\n *\n * @example\n * See `setRowExpand` or `setColumnExpand` functions.\n */\n/**\n * @hidden\n */\nexport function createAxisDescriptors(expandTree) {\n    const descriptors = [];\n    for (const key of Object.keys(expandTree)) {\n        descriptors.push({ name: JSON.parse(key), expand: expandTree[key] });\n    }\n    return descriptors;\n}\n","/**\n * Sets sort descriptors to request options.\n *\n * @param options - RequestOptions\n * @param sort - SortDescriptor[]\n *\n * @example\n * const options: RequestOptions = { ... };\n * const sort: SortDescriptor[] = [{ ... }, { ... }];\n * setSort(options, sort);\n * // skip the sort parameter to clear current filter - setSort(options);\n *\n * fetchData(options).then(createDataState).then((dataState: DataState) => {\n *  // Update the UI\n * });\n */\n/**\n * @hidden\n */\nexport const setSort = (options, sort = []) => {\n    options.sort = sort;\n};\n","/**\n * Sets filter descriptors to request options.\n *\n * @param options - RequestOptions\n * @param filter - FilterDescriptor[]\n *\n * @example\n * const options: RequestOptions = { ... };\n * const filter: FilterDescriptor[] = [{ ... }, { ... }];\n * setFilter(options, filter);\n * // skip the filter parameter to clear current filter - setFilter(options);\n *\n * fetchData(options).then(createDataState).then((dataState: DataState) => {\n *  // Update the UI\n * });\n */\n/**\n * @hidden\n */\nexport const setFilter = (options, filter = []) => {\n    options.filter = filter;\n};\n","/**\n * @hidden\n */\nexport var HEADERS_ACTION;\n(function (HEADERS_ACTION) {\n    HEADERS_ACTION[\"toggle\"] = \"HEADERS_ACTION_TOGGLE\";\n    HEADERS_ACTION[\"expand\"] = \"HEADERS_ACTION_EXPAND\";\n    HEADERS_ACTION[\"collapse\"] = \"HEADERS_ACTION_COLLAPSE\";\n})(HEADERS_ACTION || (HEADERS_ACTION = {}));\nconst findPath = (node, matchFn, matched) => {\n    const result = new Set();\n    node.children.forEach((child) => {\n        const match = matchFn(child);\n        if (matched) {\n            result.add(String(child.path));\n        }\n        findPath(child, matchFn, (matched || match)).map((h) => {\n            result.add(h);\n        });\n    });\n    return Array.from(result.values());\n};\n/**\n * @hidden\n */\nexport const headersReducer = (state, action) => {\n    switch (action.type) {\n        case HEADERS_ACTION.toggle: {\n            const existing = state.find((s => String(s.name) === String(action.payload)));\n            return headersReducer(state, Object.assign(Object.assign({}, action), { type: existing && (existing.expand)\n                    ? HEADERS_ACTION.collapse\n                    : HEADERS_ACTION.expand }));\n        }\n        case HEADERS_ACTION.expand: {\n            const existing = state.find((s => String(s.name) === String(action.payload)));\n            if (existing && existing.expand === true) {\n                return state;\n            }\n            else if (existing && (existing.expand === false || existing.expand === undefined)) {\n                return state.map((s) => s === existing ? (Object.assign(Object.assign({}, existing), { expand: true })) : s);\n            }\n            else {\n                const nextState = state.slice();\n                nextState.push({ name: action.payload, expand: true });\n                return nextState;\n            }\n        }\n        case HEADERS_ACTION.collapse: {\n            const filtered = findPath(action.tree, (node) => !node.total && String(node.path) === String(action.payload));\n            const newState = state.slice()\n                .filter(h => !filtered.some((f) => f === String(h.name)))\n                .map(h => (Object.assign(Object.assign({}, h), { expand: Boolean(h.expand) })))\n                .map(h => (String(h.name) === String(action.payload))\n                ? action.payload.length > 1 ? undefined : { name: action.payload, expand: false }\n                : h)\n                .filter(Boolean);\n            return newState;\n        }\n        default: {\n            return state;\n        }\n    }\n};\n","import { compareAxisWithField, compareAxes, buildKPIMeasures, filterField, insertAxis } from '../utils';\n/**\n * @hidden\n */\nexport var PIVOT_CONFIGURATOR_ACTION;\n(function (PIVOT_CONFIGURATOR_ACTION) {\n    // Selection\n    PIVOT_CONFIGURATOR_ACTION[\"toggleSelection\"] = \"PIVOT_CONFIGURATOR_ACTION_TOGGLE_SELECTION\";\n    PIVOT_CONFIGURATOR_ACTION[\"addColumnAxis\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_COLUMN_AXIS\";\n    PIVOT_CONFIGURATOR_ACTION[\"addColumnAxes\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_COLUMN_AXES\";\n    PIVOT_CONFIGURATOR_ACTION[\"removeColumnAxis\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_COLUMN_AXIS\";\n    PIVOT_CONFIGURATOR_ACTION[\"removeColumnAxes\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_COLUMN_AXES\";\n    PIVOT_CONFIGURATOR_ACTION[\"addRowAxis\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_ROW_AXIS\";\n    PIVOT_CONFIGURATOR_ACTION[\"addRowAxes\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_ROW_AXES\";\n    PIVOT_CONFIGURATOR_ACTION[\"removeRowAxis\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_ROW_AXIS\";\n    PIVOT_CONFIGURATOR_ACTION[\"removeRowAxes\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_ROW_AXES\";\n    PIVOT_CONFIGURATOR_ACTION[\"addMeasureAxis\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_MEASURE_AXIS\";\n    PIVOT_CONFIGURATOR_ACTION[\"addMeasureAxes\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_MEASURE_AXES\";\n    PIVOT_CONFIGURATOR_ACTION[\"removeMeasureAxis\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_MEASURE_AXIS\";\n    PIVOT_CONFIGURATOR_ACTION[\"removeMeasureAxes\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_MEASURE_AXES\";\n    // Removal\n    PIVOT_CONFIGURATOR_ACTION[\"remove\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE\";\n    // Sort\n    PIVOT_CONFIGURATOR_ACTION[\"setSort\"] = \"PIVOT_CONFIGURATOR_ACTION_SET_SORT\";\n    // Filter\n    PIVOT_CONFIGURATOR_ACTION[\"setFilter\"] = \"PIVOT_CONFIGURATOR_ACTION_SET_FILTER\";\n    PIVOT_CONFIGURATOR_ACTION[\"addFilter\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_FILTER\";\n    PIVOT_CONFIGURATOR_ACTION[\"changeFilter\"] = \"PIVOT_CONFIGURATOR_ACTION_CHANGE_FILTER\";\n    PIVOT_CONFIGURATOR_ACTION[\"removeFilter\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_FILTER\";\n    // Drag\n    PIVOT_CONFIGURATOR_ACTION[\"setDragItem\"] = \"PIVOT_CONFIGURATOR_ACTION_SET_DRAGITEM\";\n    PIVOT_CONFIGURATOR_ACTION[\"drop\"] = \"PIVOT_CONFIGURATOR_ACTION_DROP\";\n    PIVOT_CONFIGURATOR_ACTION[\"setDropZone\"] = \"PIVOT_CONFIGURATOR_ACTION_SET_DROP_ZONE\";\n    PIVOT_CONFIGURATOR_ACTION[\"setDropTarget\"] = \"PIVOT_CONFIGURATOR_ACTION_SET_DROP_TARGET\";\n    PIVOT_CONFIGURATOR_ACTION[\"setDropDirection\"] = \"PIVOT_CONFIGURATOR_ACTION_SET_DROP_DIRECTION\";\n})(PIVOT_CONFIGURATOR_ACTION || (PIVOT_CONFIGURATOR_ACTION = {}));\n/**\n * @hidden\n */\nexport const configuratorReducer = (state, action) => {\n    let newRows;\n    let newColumns;\n    let newMeasures;\n    let newSort;\n    let newFilter;\n    let newDragitem;\n    let newDropZone;\n    let newDropDirection;\n    let newDropTarget;\n    switch (action.type) {\n        case PIVOT_CONFIGURATOR_ACTION.toggleSelection: {\n            if (Array.isArray(action.payload)) {\n                // TODO;\n            }\n            else {\n                const payload = action.payload;\n                if (payload.type === 2 || 'aggregator' in payload) {\n                    if (state.measureAxes.some((s) => compareAxisWithField(s, payload))) {\n                        return configuratorReducer(state, Object.assign(Object.assign({}, action), { type: PIVOT_CONFIGURATOR_ACTION.removeMeasureAxis }));\n                    }\n                    else {\n                        return configuratorReducer(state, Object.assign(Object.assign({}, action), { type: PIVOT_CONFIGURATOR_ACTION.addMeasureAxis }));\n                    }\n                }\n                else if (payload.type === 'kpi') {\n                    const measures = buildKPIMeasures(payload);\n                    if (measures.every((m) => state.measureAxes.some((s) => compareAxisWithField(s, m)))) {\n                        return configuratorReducer(state, Object.assign(Object.assign({}, action), { type: PIVOT_CONFIGURATOR_ACTION.removeMeasureAxes, payload: measures }));\n                    }\n                    else {\n                        return configuratorReducer(state, Object.assign(Object.assign({}, action), { type: PIVOT_CONFIGURATOR_ACTION.addMeasureAxes, payload: measures.filter((m) => !state.measureAxes.some((s) => compareAxisWithField(s, m))) }));\n                    }\n                }\n                else if (action.payload.kpi) {\n                    if (state.measureAxes.some((s) => compareAxisWithField(s, payload))) {\n                        return configuratorReducer(state, Object.assign(Object.assign({}, action), { type: PIVOT_CONFIGURATOR_ACTION.removeMeasureAxis }));\n                    }\n                    else {\n                        return configuratorReducer(state, Object.assign(Object.assign({}, action), { type: PIVOT_CONFIGURATOR_ACTION.addMeasureAxis }));\n                    }\n                }\n                else {\n                    if (state.columnAxes.some((s) => compareAxisWithField(s, payload))) {\n                        return configuratorReducer(state, Object.assign(Object.assign({}, action), { type: PIVOT_CONFIGURATOR_ACTION.removeColumnAxis }));\n                    }\n                    else if (state.rowAxes.some((s) => compareAxisWithField(s, payload))) {\n                        return configuratorReducer(state, Object.assign(Object.assign({}, action), { type: PIVOT_CONFIGURATOR_ACTION.removeRowAxis }));\n                    }\n                    else if ((state.columnAxes && state.columnAxes.length) && (!state.rowAxes || !state.rowAxes.length)) {\n                        return configuratorReducer(state, Object.assign(Object.assign({}, action), { type: PIVOT_CONFIGURATOR_ACTION.addRowAxis }));\n                    }\n                    else {\n                        return configuratorReducer(state, Object.assign(Object.assign({}, action), { type: PIVOT_CONFIGURATOR_ACTION.addColumnAxis }));\n                    }\n                }\n            }\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.addColumnAxis: {\n            newColumns = [\n                ...(state.columnAxes || []),\n                { name: [action.payload.defaultHierarchy || action.payload.uniqueName] }\n            ];\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.addColumnAxes: {\n            // TODO;\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.removeColumnAxis: {\n            newColumns = [...(state.columnAxes || []).filter((s) => !compareAxisWithField(s, action.payload))];\n            filterField(newColumns, action.payload);\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.removeColumnAxes: {\n            // TODO;\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.addRowAxis: {\n            newRows = [\n                ...(state.rowAxes || []),\n                { name: [action.payload.defaultHierarchy || action.payload.uniqueName] }\n            ];\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.addRowAxes: {\n            // TODO;\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.removeRowAxis: {\n            newRows = [...(state.rowAxes || []).filter((s) => !compareAxisWithField(s, action.payload))];\n            filterField(newRows, action.payload);\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.removeRowAxes: {\n            // TODO;\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.addMeasureAxis: {\n            newMeasures = [\n                ...(state.measureAxes || []),\n                { name: [action.payload.defaultHierarchy || action.payload.uniqueName] }\n            ];\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.removeMeasureAxis: {\n            newMeasures = [...(state.measureAxes || []).filter((s) => !compareAxisWithField(s, action.payload))];\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.addMeasureAxes: {\n            newMeasures = [\n                ...(state.measureAxes || []),\n                ...(action.payload || []).map((p) => ({ name: [p.defaultHierarchy || p.uniqueName] }))\n            ];\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.removeMeasureAxes: {\n            newMeasures = [...(state.measureAxes || []).filter((s) => !action.payload.some((p) => compareAxisWithField(s, p)))];\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.remove: {\n            if (state.columnAxes.some((s) => compareAxes(s, action.payload))) {\n                newColumns = [...state.columnAxes.filter((s) => !compareAxes(s, action.payload))];\n                filterField(newColumns, { uniqueName: action.payload.name });\n            }\n            if (state.rowAxes.some((s) => compareAxes(s, action.payload))) {\n                newRows = [...state.rowAxes.filter((s) => !compareAxes(s, action.payload))];\n                filterField(newRows, { uniqueName: action.payload.name });\n            }\n            if (state.measureAxes.some((s) => compareAxes(s, action.payload))) {\n                newMeasures = [...state.measureAxes.filter((s) => !compareAxes(s, action.payload))];\n            }\n            break;\n        }\n        case PIVOT_CONFIGURATOR_ACTION.setDragItem:\n            newDragitem = action.payload;\n            break;\n        case PIVOT_CONFIGURATOR_ACTION.setDropZone:\n            newDropZone = action.payload;\n            break;\n        case PIVOT_CONFIGURATOR_ACTION.setDropTarget:\n            newDropTarget = action.payload;\n            break;\n        case PIVOT_CONFIGURATOR_ACTION.setDropDirection:\n            newDropDirection = action.payload;\n            break;\n        case PIVOT_CONFIGURATOR_ACTION.drop:\n            if (state.dragItem && state.dropZone) {\n                const currentColumn = state.columnAxes.find((s) => compareAxes(s, action.payload));\n                const currentRow = state.rowAxes.find((s) => compareAxes(s, action.payload));\n                const currentMeasure = state.measureAxes.find((s) => compareAxes(s, action.payload));\n                let current;\n                if (currentColumn) {\n                    current = currentColumn;\n                    newColumns = [...state.columnAxes.filter((s) => !compareAxes(s, action.payload))];\n                    filterField(newColumns, { uniqueName: action.payload.name });\n                }\n                if (currentRow) {\n                    current = currentRow;\n                    newRows = [...state.rowAxes.filter((s) => !compareAxes(s, action.payload))];\n                    filterField(newRows, { uniqueName: action.payload.name });\n                }\n                if (currentMeasure) {\n                    current = currentMeasure;\n                    newMeasures = [...state.measureAxes.filter((s) => !compareAxes(s, action.payload))];\n                }\n                switch (state.dropZone) {\n                    case 'columnAxes': {\n                        newColumns = newColumns || state.columnAxes.slice();\n                        insertAxis(newColumns, current, state);\n                        break;\n                    }\n                    case 'rowAxes': {\n                        newRows = newRows || state.rowAxes.slice();\n                        insertAxis(newRows, current, state);\n                        break;\n                    }\n                    case 'measureAxes': {\n                        newMeasures = newMeasures || state.measureAxes.slice();\n                        insertAxis(newMeasures, current, state);\n                        break;\n                    }\n                    default:\n                        break;\n                }\n            }\n            newDragitem = null;\n            newDropZone = null;\n            newDropTarget = null;\n            break;\n        case PIVOT_CONFIGURATOR_ACTION.setSort:\n            newSort = action.payload;\n            break;\n        case PIVOT_CONFIGURATOR_ACTION.setFilter:\n            if (Array.isArray(action.payload)) {\n                newFilter = action.payload;\n            }\n            else {\n                newFilter = [action.payload];\n            }\n            break;\n        case PIVOT_CONFIGURATOR_ACTION.addFilter:\n            newFilter = (state.filter || []).slice();\n            if (Array.isArray(action.payload)) {\n                newFilter.push(...action.payload);\n            }\n            else {\n                newFilter.push(action.payload);\n            }\n            break;\n        case PIVOT_CONFIGURATOR_ACTION.changeFilter:\n            newFilter = (Array.isArray(action.payload)\n                ? (state.filter || []).map(f => action.payload.some((a) => a.field === f.field)\n                    ? action.payload.find((a) => a.field === f.field)\n                    : f)\n                : (state.filter || []).map(f => f.field === action.payload.field\n                    ? action.payload\n                    : f));\n            break;\n        case PIVOT_CONFIGURATOR_ACTION.removeFilter:\n            newFilter = (state.filter || []).slice();\n            if (Array.isArray(action.payload)) {\n                newFilter = newFilter.filter((f) => !action.payload.some((p) => p.field === f.field &&\n                    p.operator === f.operator));\n            }\n            else {\n                newFilter = newFilter.filter((f) => !(f.field === action.payload.field\n                    && f.operator === action.payload.operator));\n            }\n            break;\n        default:\n            break;\n    }\n    return {\n        dragItem: newDragitem,\n        dropTarget: newDropTarget,\n        dropDirection: newDropDirection,\n        dropZone: newDropZone,\n        columnAxes: newColumns,\n        rowAxes: newRows,\n        measureAxes: newMeasures,\n        filter: newFilter,\n        sort: newSort\n    };\n};\n","// tslint:disable:object-literal-sort-keys\n/**\n * The available built-in types of local-data aggregates.\n */\nexport var AggregateType;\n(function (AggregateType) {\n    AggregateType[AggregateType[\"Sum\"] = 0] = \"Sum\";\n    AggregateType[AggregateType[\"Count\"] = 1] = \"Count\";\n    AggregateType[AggregateType[\"Min\"] = 2] = \"Min\";\n    AggregateType[AggregateType[\"Max\"] = 3] = \"Max\";\n    AggregateType[AggregateType[\"Average\"] = 4] = \"Average\";\n})(AggregateType || (AggregateType = {}));\nlet count = 0;\n/**\n * Creates a new `Aggregate` object of the specified type.\n * This is typically used for generating aggregate objects required for each measure column in the pivot grid.\n *\n * @param type - The type of aggregate to create (e.g., Sum, Count, Min, Max, Average).\n * @returns The generated aggregate object.\n */\nexport const createAggregate = (type) => {\n    const key = `${AggregateType[type]}_${count++}`;\n    switch (type) {\n        case AggregateType.Sum:\n            return {\n                init: (data) => {\n                    if ((key in data) === false) {\n                        data[key] = 0;\n                    }\n                },\n                merge: (src, dest) => {\n                    dest[key] += src[key];\n                },\n                accumulate: (acc, value) => {\n                    acc[key] += value;\n                },\n                result: data => data[key],\n                format: (value) => value.toFixed(2)\n            };\n        case AggregateType.Count:\n            return {\n                init: (data) => {\n                    if ((key in data) === false) {\n                        data[key] = 0;\n                    }\n                },\n                merge: (src, dest) => {\n                    dest[key] += src[key];\n                },\n                accumulate: (acc, _value) => {\n                    acc[key] += 1;\n                },\n                result: data => data[key],\n                format: (value) => value.toFixed()\n            };\n        case AggregateType.Min:\n            return {\n                init: (data) => {\n                    if (key in data === false) {\n                        data[key] = Number.POSITIVE_INFINITY;\n                    }\n                },\n                merge: (src, dest) => {\n                    dest[key] = Math.min(src[key], dest[key]);\n                },\n                accumulate: (acc, value) => {\n                    acc[key] = Math.min(value, acc[key]);\n                },\n                result: (data) => (Number.isFinite(data[key]) ? data[key] : NaN),\n                format: (value) => value.toFixed(2)\n            };\n        case AggregateType.Max:\n            return {\n                init: (data) => {\n                    if ((key in data) === false) {\n                        data[key] = Number.NEGATIVE_INFINITY;\n                    }\n                },\n                merge: (src, dest) => {\n                    dest[key] = Math.max(src[key], dest[key]);\n                },\n                accumulate: (acc, value) => {\n                    acc[key] = Math.max(value, acc[key]);\n                },\n                result: data => Number.isFinite(data[key]) ? data[key] : NaN,\n                format: (value) => value.toFixed(2)\n            };\n        case AggregateType.Average:\n            const sumProp = `${key}_sum`;\n            const countProp = `${key}_count`;\n            return {\n                init: (data) => {\n                    if ((countProp in data) === false) {\n                        data[sumProp] = 0;\n                        data[countProp] = 0;\n                    }\n                },\n                merge: (src, dest) => {\n                    dest[sumProp] += src[sumProp];\n                    dest[countProp] += src[countProp];\n                },\n                accumulate: (acc, value) => {\n                    acc[sumProp] += value;\n                    acc[countProp] += 1;\n                },\n                result: data => data[sumProp] / data[countProp],\n                format: (value) => value.toFixed(2)\n            };\n        default:\n            throw new Error('Invalid aggregate type provided');\n    }\n};\n/**\n * Represents the aggregate object which calculates the total value. Applicable for local data binding.\n */\nexport const sumAggregate = createAggregate(AggregateType.Sum);\n/**\n * Represents the aggregate object which calculates the count value. Applicable for local data binding.\n */\nexport const countAggregate = createAggregate(AggregateType.Count);\n/**\n * Represents the aggregate object which calculates the minimum value. Applicable for local data binding.\n */\nexport const minAggregate = createAggregate(AggregateType.Min);\n/**\n * Represents the aggregate object which calculates the maximum value. Applicable for local data binding.\n */\nexport const maxAggregate = createAggregate(AggregateType.Max);\n/**\n * Represents the aggregate object which calculates the average value. Applicable for local data binding.\n */\nexport const averageAggregate = createAggregate(AggregateType.Average);\n","/**\n * @hidden\n */\nexport const isPresent = (value) => value !== null && value !== undefined;\n/**\n * @hidden\n */\nexport const isBlank = (value) => value === null || value === undefined;\n/**\n * @hidden\n */\nexport const isArray = (value) => Array.isArray(value);\n/**\n * @hidden\n */\nexport const isFunction = (value) => typeof value === 'function';\n/**\n * @hidden\n */\nexport const isString = (value) => typeof value === 'string';\n/**\n * @hidden\n */\nexport const isTruthy = (value) => !!value;\n/**\n * @hidden\n */\nexport const isNullOrEmptyString = (value) => isBlank(value) || value.trim().length === 0;\n/**\n * @hidden\n */\nexport const isNotNullOrEmptyString = (value) => !isNullOrEmptyString(value);\n/**\n * @hidden\n */\nexport const isNumeric = (value) => !isNaN(value - parseFloat(value));\n/**\n * @hidden\n */\nexport const isDate = (value) => value && value.getTime;\n","import { isPresent } from '../utils';\n// tslint:enable:max-line-length\n/**\n * @hidden\n * Type guard for `CompositeFilterDescriptor`.\n */\nexport const isCompositeFilterDescriptor = (source) => {\n    return isPresent(source.filters);\n};\n","/**\n * @hidden\n */\nexport const ifElse = (predicate, right, left) => value => predicate(value) ? right(value) : left(value);\n/**\n * @hidden\n * Performs the right-to-left function composition. Functions should have a unary.\n */\nexport const compose = (...args) => (data) => args.reduceRight((acc, curr) => curr(acc), data);\n/**\n * @hidden\n */\nexport const constant = x => () => x;\n/**\n * @hidden\n */\nexport const identity = x => x;\n","import { isString, isDate } from './utils';\n/**\n * @hidden\n * Creates a single arity function which wraps the value based on the provided predicate.\n * @example\n * ```\n * wrapIf(() => ignoreCase) `tolower(${field})`\n * //ignoreCase=true -> tolower(${field})`\n * //ignoreCase=false -> ${field}`\n * ```\n */\nexport const wrapIf = predicate => (str, ...args) => predicate() ? `${str[0]}${args[0]}${str[1]}` : args[0];\n/**\n * @hidden\n */\nexport const toUTC = (date) => new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));\n/**\n * @hidden\n */\nexport const quote = ({ field, value, ignoreCase, operator }) => ({\n    value: `'${value.replace(/'/g, \"''\")}'`,\n    field,\n    ignoreCase,\n    operator\n});\n/**\n * @hidden\n */\nexport const encodeValue = ({ field, value, ignoreCase, operator }) => ({\n    value: `${encodeURIComponent(value)}`,\n    field,\n    ignoreCase,\n    operator\n});\n/**\n * @hidden\n */\nexport const toLower = ({ field, value, ignoreCase, operator }) => ({\n    field: wrapIf(() => ignoreCase) `tolower(${field})`,\n    value,\n    ignoreCase,\n    operator\n});\n/**\n * @hidden\n */\nexport const normalizeField = ({ field, value, ignoreCase, operator }) => ({\n    value,\n    field: field.replace(/\\./g, \"/\"),\n    ignoreCase,\n    operator\n});\n/**\n * @hidden\n */\nexport const isStringValue = x => isString(x.value);\n/**\n * @hidden\n */\nexport const isDateValue = x => isDate(x.value);\n/**\n * @hidden\n */\nexport const serializeFilters = (map, join) => (filter) => {\n    const brackets = wrapIf(() => filter.filters.length > 1);\n    return brackets `(${filter.filters\n        .map(map)\n        .join(join(filter))})`;\n};\n","import { isPresent, isString, isArray } from '../utils';\nimport { isCompositeFilterDescriptor } from './filter-descriptor.interface';\nconst operatorMap = (key) => ({\n    \"!=\": \"neq\",\n    \"<\": \"lt\",\n    \"<=\": \"lte\",\n    \"==\": \"eq\",\n    \">\": \"gt\",\n    \">=\": \"gte\",\n    equal: \"eq\",\n    equals: \"eq\",\n    equalto: \"eq\",\n    ge: \"gte\",\n    greater: \"gt\",\n    greaterthan: \"gt\",\n    greaterthanequal: \"gte\",\n    isempty: \"isempty\",\n    isequalto: \"eq\",\n    isgreaterthan: \"gt\",\n    isgreaterthanorequalto: \"gte\",\n    islessthan: \"lt\",\n    islessthanorequalto: \"lte\",\n    isnotempty: \"isnotempty\",\n    isnotequalto: \"neq\",\n    isnull: \"isnull\",\n    le: \"lte\",\n    less: \"lt\",\n    lessthan: \"lt\",\n    lessthanequal: \"lte\",\n    ne: \"neq\",\n    notequal: \"neq\",\n    notequals: \"neq\",\n    notequalto: \"neq\",\n    notsubstringof: \"doesnotcontain\"\n}[key.toLowerCase()] || key);\nconst normalizeOperator = (descriptor) => {\n    if (descriptor.filters) {\n        descriptor.filters = descriptor.filters.map(filter => {\n            const result = Object.assign({}, filter);\n            if (!isCompositeFilterDescriptor(filter) && isString(filter.operator)) {\n                result.operator = operatorMap(filter.operator);\n            }\n            if (isCompositeFilterDescriptor(filter)) {\n                normalizeOperator(result);\n            }\n            return result;\n        });\n    }\n};\nconst normalizeDescriptor = (descriptor) => {\n    if (!isCompositeFilterDescriptor(descriptor)) {\n        return {\n            filters: isArray(descriptor) ? descriptor : [descriptor],\n            logic: \"and\"\n        };\n    }\n    return Object.assign({}, descriptor);\n};\n// tslint:disable:max-line-length\n/**\n * Converts a [`FilterDescriptor`]({% slug api_kendo-data-query_filterdescriptor %}) into a [`CompositeFilterDescriptor`]({% slug api_kendo-data-query_compositefilterdescriptor %}). If a `CompositeFilterDescriptor` is passed, no modifications will be made.\n *\n * @param {CompositeFilterDescriptor | FilterDescriptor} descriptor - The descriptor that will be normalized.\n * @returns {CompositeFilterDescriptor} - The normalized descriptor.\n */\n// tslint:enable:max-line-length\nexport const normalizeFilters = (descriptor) => {\n    if (isPresent(descriptor)) {\n        descriptor = normalizeDescriptor(descriptor);\n        normalizeOperator(descriptor);\n    }\n    return descriptor;\n};\n","import { isCompositeFilterDescriptor } from './filtering/filter-descriptor.interface';\nimport { compose, ifElse } from './funcs';\nimport { normalizeField, quote, toLower, isDateValue, isStringValue, serializeFilters, encodeValue, toUTC } from './filter-serialization.common';\nimport { normalizeFilters } from './filtering/filter.operators';\nconst formatDate = ({ utcDates }) => ({ field, value, ignoreCase, operator }) => ({\n    value: (!utcDates ? toUTC(value) : value).toISOString(),\n    field,\n    ignoreCase,\n    operator\n});\nconst fnFormatter = ({ operator }) => ({ field, value }) => `${operator}(${field},${value})`;\nconst singleOperatorFormatter = ({ operator }) => ({ field, value }) => `${field} ${operator} ${value}`;\nconst stringFormat = formatter => compose(formatter, encodeValue, quote, toLower, normalizeField);\nconst stringFnOperator = settings => stringFormat(fnFormatter(settings));\nconst stringOperator = settings => stringFormat(singleOperatorFormatter(settings));\nconst numericOperator = settings => compose(singleOperatorFormatter(settings), normalizeField);\nconst dateOperator = settings => compose(singleOperatorFormatter(settings), normalizeField, formatDate(settings));\nconst ifDate = settings => ifElse(isDateValue, dateOperator(settings), numericOperator(settings));\nconst typedOperator = settings => ifElse(isStringValue, stringOperator(settings), ifDate(settings));\nconst appendEqual = str => `${str} eq -1`;\nconst nonValueExpression = formatter => compose(formatter, normalizeField);\nconst filterOperators = (operator, settings) => ({\n    contains: stringFnOperator(Object.assign(Object.assign({}, settings), { operator: \"contains\" })),\n    doesnotcontain: compose(appendEqual, stringFnOperator(Object.assign(Object.assign({}, settings), { operator: \"indexof\" }))),\n    endswith: stringFnOperator(Object.assign(Object.assign({}, settings), { operator: \"endswith\" })),\n    eq: typedOperator(Object.assign(Object.assign({}, settings), { operator: \"eq\" })),\n    gt: typedOperator(Object.assign(Object.assign({}, settings), { operator: \"gt\" })),\n    gte: typedOperator(Object.assign(Object.assign({}, settings), { operator: \"ge\" })),\n    isempty: nonValueExpression(({ field }) => `${field} eq ''`),\n    isnotempty: nonValueExpression(({ field }) => `${field} ne ''`),\n    isnotnull: nonValueExpression(({ field }) => `${field} ne null`),\n    isnull: nonValueExpression(({ field }) => `${field} eq null`),\n    lt: typedOperator(Object.assign(Object.assign({}, settings), { operator: \"lt\" })),\n    lte: typedOperator(Object.assign(Object.assign({}, settings), { operator: \"le\" })),\n    neq: typedOperator(Object.assign(Object.assign({}, settings), { operator: \"ne\" })),\n    startswith: stringFnOperator(Object.assign(Object.assign({}, settings), { operator: \"startswith\" }))\n}[operator]);\nconst join = x => ` ${x.logic} `;\nconst serialize = settings => x => filterOperators(x.operator, settings)(x);\nconst serializeAll = settings => serializeFilters(filter => ifElse(isCompositeFilterDescriptor, serializeAll(settings), serialize(settings))(filter), join);\n/**\n * @hidden\n */\nexport const serializeFilter = (filter, settings = {}) => {\n    if (filter.filters && filter.filters.length) {\n        return \"$filter=\" + serializeAll(settings)(normalizeFilters(filter));\n    }\n    return \"\";\n};\n","import { isPresent, isNotNullOrEmptyString } from './utils';\nimport { serializeFilter } from './odata-filtering.operators';\nimport { ifElse, constant } from './funcs';\nconst serializeSort = (orderby) => {\n    const str = orderby\n        .filter(sort => isPresent(sort.dir))\n        .map(sort => {\n        const order = sort.field.replace(/\\./g, \"/\");\n        return sort.dir === \"desc\" ? order + \" desc\" : order;\n    }).join(\",\");\n    return str ? `$orderby=${str}` : str;\n};\nconst emptyString = constant('');\nconst concat = a => b => a + b;\nconst serializeKey = (strings, val) => ifElse(isPresent, concat(strings[0]), emptyString)(val);\nconst rules = (settings, state) => (key) => ({\n    \"filter\": serializeFilter(state.filter || {}, settings),\n    \"skip\": serializeKey `$skip=${state.skip}`,\n    \"sort\": serializeSort(state.sort || []),\n    \"take\": serializeKey `$top=${state.take}`\n}[key]);\n// tslint:enable:max-line-length\n/**\n * Converts a [State]({% slug api_kendo-data-query_state %}) into an OData v4 compatible string.\n *\n * @param {State} state - The state that will be serialized.\n * @param {ODataSettings} settings - The settings that are used during the serialization.\n * @returns {string} - The serialized state.\n */\nexport const toODataString = (state, settings = {}) => (Object.keys(state)\n    .map(rules(settings, state))\n    .filter(isNotNullOrEmptyString)\n    .join('&'));\n","import { isPresent } from './utils';\nconst getterCache = {};\nconst FIELD_REGEX = /\\[(?:(\\d+)|['\"](.*?)['\"])\\]|((?:(?!\\[.*?\\]|\\.).)+)/g;\n// tslint:disable-next-line:no-string-literal\ngetterCache['undefined'] = obj => obj;\n/**\n * @hidden\n */\nexport const getter = (field, safe) => {\n    const key = field + safe;\n    if (getterCache[key]) {\n        return getterCache[key];\n    }\n    const fields = [];\n    field.replace(FIELD_REGEX, (_, index, indexAccessor, field) => {\n        fields.push(isPresent(index) ? index : (indexAccessor || field));\n        return undefined;\n    });\n    getterCache[key] = obj => {\n        let result = obj;\n        for (let idx = 0; idx < fields.length; idx++) {\n            result = result[fields[idx]];\n            if (!isPresent(result) && safe) {\n                return result;\n            }\n        }\n        return result;\n    };\n    return getterCache[key];\n};\n","import { isCompositeFilterDescriptor } from '../filtering/filter-descriptor.interface';\nimport { isPresent, isNotNullOrEmptyString, isArray } from '../utils';\nimport { getter } from '../accessor';\nimport { compose, ifElse, identity } from '../funcs';\nimport { isStringValue, isDateValue, quote, serializeFilters, toUTC, encodeValue } from '../filter-serialization.common';\nconst toQueryString = values => values.reduce((acc, [key, value]) => [...acc, `${key}=${value}`], []);\nconst toObject = values => values.reduce((acc, [key, value]) => (Object.assign(Object.assign({}, acc), { [key]: value })), {});\nconst pairwise = key => value => [key, value];\nconst empty = () => null;\nconst isNotEmptyArray = value => isPresent(value) && isArray(value) && value.length > 0;\nconst has = accessor => value => isPresent(accessor(value));\nconst isNotEmpty = accessor => value => isNotEmptyArray(accessor(value));\nconst runOrEmpty = (predicate, fn) => ifElse(predicate, fn, empty);\nconst calcPage = ({ skip, take }) => Math.floor((skip || 0) / take) + 1;\nconst formatDescriptors = (accessor, formatter) => state => (accessor(state).map(formatter).join(\"~\"));\nconst removeAfter = (what) => (str) => str.slice(0, str.indexOf(what));\nconst replace = (patterns) => compose(...patterns.map(([left, right]) => (s) => s.replace(new RegExp(left, \"g\"), right)));\nconst sanitizeDateLiterals = replace([[\"\\\"\", \"\"], [\":\", \"-\"]]);\nconst removeAfterDot = removeAfter(\".\");\nconst directionFormatter = ({ field, dir = \"asc\" }) => `${field}-${dir}`;\nconst aggregateFormatter = ({ field, aggregate }) => `${field}-${aggregate}`;\nconst take = getter(\"take\");\nconst aggregates = getter(\"aggregates\");\nconst skip = getter(\"skip\");\nconst group = getter(\"group\");\nconst sort = getter(\"sort\", true);\nconst formatSort = formatDescriptors(sort, directionFormatter);\nconst formatGroup = formatDescriptors(group, directionFormatter);\nconst formatAggregates = formatDescriptors(aggregates, aggregateFormatter);\nconst prefixDateValue = value => `datetime'${value}'`;\nconst formatDateValue = compose(prefixDateValue, removeAfterDot, sanitizeDateLiterals, JSON.stringify, toUTC);\nconst formatDate = ({ field, value, ignoreCase, operator }) => ({\n    value: formatDateValue(value),\n    field,\n    ignoreCase,\n    operator\n});\nconst normalizeSort = (state) => Object.assign({}, state, {\n    sort: (sort(state) || []).filter(({ dir }) => isNotNullOrEmptyString(dir))\n});\nconst transformSkip = compose(pairwise('page'), calcPage);\nconst transformTake = compose(pairwise('pageSize'), take);\nconst transformGroup = compose(pairwise('group'), formatGroup);\nconst transformSort = compose(pairwise('sort'), formatSort);\nconst transformAggregates = compose(pairwise('aggregate'), formatAggregates);\nconst serializePage = runOrEmpty(has(skip), transformSkip);\nconst serializePageSize = runOrEmpty(has(take), transformTake);\nconst serializeGroup = runOrEmpty(isNotEmpty(group), transformGroup);\nconst serializeAggregates = runOrEmpty(has(aggregates), transformAggregates);\nconst serializeSort = compose(runOrEmpty(isNotEmpty(sort), transformSort), normalizeSort);\nconst hasField = ({ field }) => isNotNullOrEmptyString(field);\nconst filterFormatter = ({ field, operator, value }) => `${field}~${operator}~${value}`;\nconst dateFormatter = ifElse(isDateValue, compose(filterFormatter, formatDate), filterFormatter);\nconst typedFormatter = encode => runOrEmpty(hasField, ifElse(isStringValue, compose(filterFormatter, quote, encode ? encodeValue : identity), dateFormatter));\nconst join = ({ logic }) => `~${logic}~`;\nconst serialize = encode => serializeFilters(filter => ifElse(isCompositeFilterDescriptor, serialize(encode), typedFormatter(encode))(filter), join);\nconst serializeFilter = ({ filter }, encode) => {\n    if (filter && filter.filters) {\n        const filters = serialize(encode)(filter);\n        if (filters.length) {\n            return ['filter', filters];\n        }\n    }\n    return null;\n};\nconst rules = (state, encode = true) => key => ({\n    \"aggregates\": serializeAggregates(state),\n    \"filter\": serializeFilter(state, encode),\n    \"group\": serializeGroup(state),\n    \"skip\": serializePage(state),\n    \"sort\": serializeSort(state),\n    \"take\": serializePageSize(state)\n}[key]);\n/**\n * Converts a [`DataSourceRequestState`]({% slug api_kendo-data-query_datasourcerequeststate %}) into a string\n * that is comparable with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataSourceRequestState} state The state that will be serialized.\n * @returns {string} The serialized state.\n *\n * The following code snippet demonstrates how to use the `toDataSourceRequestString` method.\n *\n * {% platform_content angular %}\n * ```ts\n * import { HttpClient } from '@angular/common/http';\n * import { Observable } from 'rxjs';\n * import { map } from 'rxjs/operators';\n * import {\n *     DataSourceRequestState,\n *     toDataSourceRequestString,\n *     translateDataSourceResultGroups,\n *     translateAggregateResults\n * } from '@progress/kendo-data-query';\n *\n * export class ProductService {\n *     private BASE_URL = 'https://api.example.com/products';\n *\n *     constructor(private http: HttpClient) { }\n *\n *     public fetch(state: DataSourceRequestState): Observable<GridDataResult> {\n *\n *         // DataSourceRequestState includes:\n *         // - State properties: skip, take, sort, filter, group\n *         // - Additional property: aggregates\n *         const queryString = toDataSourceRequestString(state);\n *\n *         const hasGroups = state.group && state.group.length;\n *\n *         return this.http\n *             .get<ServerResponse>(`${this.BASE_URL}?${queryString}`)\n *             .pipe(\n *                 map(({ Data, Total, AggregateResults }) => ({\n *                     data: hasGroups ? translateDataSourceResultGroups(Data) : Data,\n *                     total: Total,\n *                     aggregateResult: translateAggregateResults(AggregateResults)\n *                 }))\n *             );\n *     }\n * }\n * ```\n * {% endplatform_content %}\n *\n * {% platform_content react %}\n * ```jsx\n * import React from 'react';\n * import { toDataSourceRequestString, translateDataSourceResultGroups } from '@progress/kendo-data-query';\n *\n * export function withState(WrappedGrid) {\n *     return class StatefullGrid extends React.Component {\n *         constructor(props) {\n *             super(props);\n *             // DataSourceRequestState includes:\n *             // - State properties: skip, take, sort, filter, group\n *             // - Additional property: aggregates\n *             this.state = { dataState: { skip: 0, take: 20 } };\n *         }\n *\n *         render() {\n *             return (\n *                 <WrappedGrid\n *                     filterable={true}\n *                     sortable={true}\n *                     pageable={{ pageSizes: true }}\n *                     {...this.props}\n *                     total={this.state.total}\n *                     data={this.state.data}\n *                     skip={this.state.dataState.skip}\n *                     pageSize={this.state.dataState.take}\n *                     filter={this.state.dataState.filter}\n *                     sort={this.state.dataState.sort}\n *                     dataStateChange={this.dataStateChange}\n *                 />\n *             );\n *         }\n *\n *         componentDidMount() {\n *             this.fetchData(this.state.dataState);\n *         }\n *\n *         dataStateChange = (changeEvent) => {\n *             this.setState({ dataState: changeEvent.data });\n *             this.fetchData(changeEvent.data);\n *         }\n *\n *         fetchData(dataState) {\n *             // DataSourceRequestState includes:\n *             // - State properties: skip, take, sort, filter, group\n *             // - Additional property: aggregates\n *             const queryStr = `${toDataSourceRequestString(dataState)}`; // Serialize the state\n *             const hasGroups = dataState.group && dataState.group.length;\n *\n *             const base_url = 'api/Products';\n *             const init = { method: 'GET', accept: 'application/json', headers: {} };\n *\n *             fetch(`${base_url}?${queryStr}`, init)\n *                 .then(response => response.json())\n *                 .then(({ data, total }) => {\n *                     this.setState({\n *                         data: hasGroups ? translateDataSourceResultGroups(data) : data,\n *                         total,\n *                         dataState\n *                     });\n *                 });\n *         }\n *     }\n * }\n * ```\n * {% endplatform_content %}\n */\nexport const toDataSourceRequestString = (state) => (toQueryString(Object.keys(state)\n    .map(rules(state))\n    .filter(isPresent)).join('&'));\n/**\n * Converts a [`DataSourceRequestState`]({% slug api_kendo-data-query_datasourcerequeststate %}) into an object\n * that is compatible with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataSourceRequestState} state The state that will be serialized.\n * @returns {any} The serialized state.\n *\n * The following code snippet demonstrates how to use the `toDataSourceRequest` method.\n *\n * {% platform_content angular %}\n * ```ts\n * import { HttpClient } from '@angular/common/http';\n * import { Observable } from 'rxjs';\n * import { map } from 'rxjs/operators';\n * import {\n *     DataSourceRequestState,\n *     toDataSourceRequest,\n *     translateDataSourceResultGroups,\n *     translateAggregateResults\n * } from '@progress/kendo-data-query';\n *\n * export class ProductService {\n *     private BASE_URL = 'https://api.example.com/products';\n *\n *     constructor(private http: HttpClient) { }\n *\n *     public fetch(state: DataSourceRequestState): Observable<GridDataResult> {\n *\n *         // DataSourceRequestState includes:\n *         // - State properties: skip, take, sort, filter, group\n *         // - Additional property: aggregates\n *         const dataSourceRequest = toDataSourceRequest(state);\n *\n *         const hasGroups = state.group && state.group.length;\n *\n *         return this.http\n *             .post<ServerResponse>(this.BASE_URL, dataSourceRequest)\n *             .pipe(\n *                 map(({ Data, Total, AggregateResults }) => ({\n *                     data: hasGroups ? translateDataSourceResultGroups(Data) : Data,\n *                     total: Total,\n *                     aggregateResult: translateAggregateResults(AggregateResults)\n *                 }))\n *             );\n *     }\n * }\n * ```\n * {% endplatform_content %}\n */\nexport const toDataSourceRequest = (state) => (toObject(Object.keys(state)\n    .map(rules(state, false))\n    .filter(isPresent)));\n","import { isPresent } from '../utils';\nimport { compose } from '../funcs';\n// tslint:enable:max-line-length\nconst set = (field, target, value) => {\n    target[field] = value;\n    return target;\n};\nconst toCamelCase = str => str.replace(/(^[A-Z])/g, (_, g1) => g1.toLowerCase());\nconst prop = (fieldName) => (obj) => {\n    const value = obj[fieldName];\n    if (isPresent(value)) {\n        return value;\n    }\n    return obj[toCamelCase(fieldName)];\n};\nconst member = prop(\"Member\");\nconst aggregateMethodName = prop(\"AggregateMethodName\");\nconst value = prop(\"Value\");\nconst convert = mapper => values => Object.keys(values).reduce(mapper.bind(null, values), {});\nconst translateAggregate = convert((source, acc, field) => set(field.toLowerCase(), acc, source[field]));\nconst translateAggregates = convert((source, acc, field) => set(field, acc, translateAggregate(source[field])));\nconst valueOrDefault = (value, defaultValue) => isPresent(value) ? value : defaultValue;\nconst normalizeGroup = group => ({\n    aggregates: group.Aggregates || group.aggregates,\n    field: group.Member || group.member || group.field,\n    hasSubgroups: group.HasSubgroups || group.hasSubgroups || false,\n    items: group.Items || group.items,\n    value: valueOrDefault(group.Key, valueOrDefault(group.key, group.value))\n});\nconst translateGroup = compose(({ field, hasSubgroups, value, aggregates, items }) => ({\n    aggregates: translateAggregates(aggregates),\n    field,\n    items: hasSubgroups ? items.map(translateGroup) : items,\n    value\n}), normalizeGroup);\n// tslint:disable:max-line-length\n/**\n * Converts the grouped result, which is returned into the `Data` field of the UI for ASP.NET MVC `ToDataSourceResult` method, to a comparable format.\n * @param data The value of the `Data` field of the response.\n * @returns {GroupResult[]} The converted result.\n */\nexport const translateDataSourceResultGroups = (data) => data.map(translateGroup);\n/**\n * Converts the `AggregateResults` field content, which is returned by the UI for ASP.NET MVC `ToDataSourceResult` method, to a comparable format.\n * @param data The value of the `AggregateResults` field of the response.\n * @returns {AggregateResult} The converted result.\n */\n// tslint:enable:max-line-length\nexport const translateAggregateResults = (data) => ((data || []).reduce((acc, x) => set(member(x), acc, set(aggregateMethodName(x).toLowerCase(), acc[member(x)] || {}, value(x))), {}));\n","import { isPresent, isBlank } from '../utils';\nimport { getter } from '../accessor';\nconst compare = (a, b) => {\n    if (isBlank(a)) {\n        return a === b ? 0 : -1;\n    }\n    if (isBlank(b)) {\n        return 1;\n    }\n    if (a.localeCompare) {\n        return a.localeCompare(b);\n    }\n    return a > b ? 1 : (a < b ? -1 : 0);\n};\nconst compareDesc = (a, b) => compare(b, a);\nconst descriptorAsFunc = (descriptor) => {\n    if (typeof descriptor.compare === 'function') {\n        return descriptor.compare;\n    }\n    const prop = getter(descriptor.field, true);\n    return (a, b) => (descriptor.dir === 'asc' ? compare : compareDesc)(prop(a), prop(b));\n};\nconst initial = (_a, _b) => 0;\n// tslint:disable:max-line-length\n/**\n * Converts the `SortDescriptors` into a [Comparer]({% slug api_kendo-data-query_comparer %}) function that can be used through `Array.sort`. If multiple descriptors are provided, sorting is applied in a right-to-left order.\n * @param {SortDescriptor[]} descriptors - The descriptors which will be converted.\n * @returns {Comparer} - The produced function.\n *\n * @example\n * ```ts\n * import { composeSortDescriptors } from '@progress/kendo-data-query';\n *\n * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n * const comparer = composeSortDescriptors([{ field: \"name\", dir: \"asc\" }]);\n * const result = data.sort(comparer);\n * // output: [{ name: \"Beef\" }, { name: \"Pepper\" }, { name: \"Pork\" }];\n * ```\n */\n// tslint:enable:max-line-length\nexport const composeSortDescriptors = (descriptors) => (descriptors\n    .filter(x => isPresent(x.dir) || isPresent(x.compare))\n    .map((descriptor) => descriptorAsFunc(descriptor))\n    .reduce((acc, curr) => (a, b) => acc(a, b) || curr(a, b), initial));\n","import { isPresent, isNumeric, isDate } from './utils';\nimport { getter } from './accessor';\nconst valueToString = (value) => {\n    value = isPresent(value) && value.getTime ? value.getTime() : value;\n    return value + \"\";\n};\n/**\n * @hidden\n */\nexport const groupCombinator = (field) => {\n    const prop = getter(field, true);\n    let position = 0;\n    return (agg, value) => {\n        agg[field] = agg[field] || {};\n        const groupValue = prop(value);\n        const key = valueToString(groupValue);\n        const values = agg[field][key] || { __position: position++, aggregates: {}, items: [], value: groupValue };\n        values.items.push(value);\n        agg[field][key] = values;\n        return agg;\n    };\n};\n/**\n * @hidden\n */\nexport const expandAggregates = (result = {}) => {\n    Object.keys(result).forEach(field => {\n        const aggregates = result[field];\n        Object.keys(aggregates).forEach(aggregate => {\n            aggregates[aggregate] = aggregates[aggregate].result();\n        });\n    });\n    return result;\n};\nconst aggregatesFuncs = (name) => ({\n    average: () => {\n        let value = 0;\n        let count = 0;\n        let hasValue = false;\n        let firstNonNumeric = null;\n        return {\n            calc: (curr) => {\n                if (isNumeric(curr)) {\n                    value += curr;\n                    count++;\n                    hasValue = true;\n                }\n                else if (!hasValue && firstNonNumeric === null) {\n                    firstNonNumeric = curr;\n                }\n            },\n            result: () => hasValue ? value / count : firstNonNumeric\n        };\n    },\n    count: () => {\n        let state = 0;\n        return {\n            calc: () => state++,\n            result: () => state\n        };\n    },\n    max: () => {\n        let state = Number.NEGATIVE_INFINITY;\n        return {\n            calc: (value) => {\n                state = isNumeric(state) || isDate(state) ? state : value;\n                if (state < value && (isNumeric(value) || isDate(value))) {\n                    state = value;\n                }\n            },\n            result: () => state\n        };\n    },\n    min: () => {\n        let state = Number.POSITIVE_INFINITY;\n        return {\n            calc: (value) => {\n                state = isNumeric(state) || isDate(state) ? state : value;\n                if (state > value && (isNumeric(value) || isDate(value))) {\n                    state = value;\n                }\n            },\n            result: () => state\n        };\n    },\n    sum: () => {\n        let state = 0;\n        return {\n            calc: (value) => {\n                value = isPresent(value) ? value : 0;\n                state += value;\n            },\n            result: () => state\n        };\n    }\n}[name]());\n/**\n * @hidden\n */\nexport const aggregatesCombinator = (descriptors) => {\n    const functions = descriptors.map(descriptor => {\n        const fieldAccessor = getter(descriptor.field, true);\n        const aggregateName = (descriptor.aggregate || \"\").toLowerCase();\n        const aggregateAccessor = getter(aggregateName, true);\n        return (state, value) => {\n            const fieldAggregates = state[descriptor.field] || {};\n            const aggregateFunction = aggregateAccessor(fieldAggregates)\n                || aggregatesFuncs(aggregateName);\n            aggregateFunction.calc(fieldAccessor(value));\n            fieldAggregates[descriptor.aggregate] = aggregateFunction;\n            state[descriptor.field] = fieldAggregates;\n            return state;\n        };\n    });\n    return (state, value) => functions.reduce((agg, calc) => calc(agg, value), state);\n};\n/**\n * @hidden\n * Adds the value to the `arr` and produces a new array.\n *\n * > The original array will be modified.\n */\nexport const concat = (arr, value) => {\n    arr.push(value);\n    return arr;\n};\n/**\n * @hidden\n * Returns a reducer that will apply the specified transformation to the value.\n */\nexport const map = (transform) => ((reduce) => ((acc, curr, index) => reduce(acc, transform(curr, index))));\n/**\n * @hidden\n * Returns a reducer that will filter out items which do not match the `Predicate`.\n */\nexport const filter = (predicate) => ((reduce) => ((acc, curr) => predicate(curr) ? reduce(acc, curr) : acc));\n/**\n * @hidden\n */\nexport const isTransformerResult = (source) => {\n    return isPresent(source.__value);\n};\nconst reduced = (x) => {\n    if (isTransformerResult(x)) {\n        return x;\n    }\n    return {\n        __value: x,\n        reduced: true\n    };\n};\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport const take = (count) => ((reduce) => ((acc, curr) => count-- > 0 ? reduce(acc, curr) : reduced(acc)));\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport const takeWhile = (predicate) => ((reduce) => ((acc, curr) => predicate(curr) ? reduce(acc, curr) : reduced(acc)));\n/**\n * @hidden\n * Returns a reducer that will skip the specified number of items.\n */\nexport const skip = (count) => ((reduce) => ((acc, curr) => count-- <= 0 ? reduce(acc, curr) : acc));\n/**\n * @hidden\n * Transforms the data by applying the supplied transformer.\n */\nexport const exec = (transform, initialValue, data) => {\n    let result = initialValue;\n    for (let idx = 0, length = data.length; idx < length; idx++) {\n        result = transform(result, data[idx], idx);\n        if (isTransformerResult(result)) {\n            result = result.__value;\n            break;\n        }\n    }\n    return result;\n};\n","import { exec, map, aggregatesCombinator, expandAggregates } from '../transducers';\nconst identity = map(x => x);\n// tslint:disable:max-line-length\n/**\n * Applies the specified [`AggregateDescriptors`]({% slug api_kendo-data-query_aggregatedescriptor %}) to the data. Returns an [`AggregateResult`]({% slug api_kendo-data-query_aggregateresult %}) instance.\n *\n * @example\n * ```ts\n * const data = [\n *    { unitPrice: 23, unitsInStock: 21 },\n *    { unitPrice: 10, unitsInStock: 12 },\n *    { unitPrice: 20, unitsInStock: 33 }\n * ];\n *\n * const result = aggregateBy(data, [\n *   { aggregate: \"sum\", field: \"unitPrice\" },\n *   { aggregate: \"sum\", field: \"unitsInStock\" }\n * ]);\n *\n * //output:\n * // {\n * //     \"unitPrice\": { \"sum\": 53 },\n * //     \"unitsInStock\": { \"sum\": 66 }\n * // }\n * ```\n * @param {T[]} data - The data on which the calculation will be executed.\n * @param {AggregateDescriptor[]} descriptors - The aggregate operations that will be executed.\n * @param {any} transformers - For internal use.\n * @returns {AggregateResult} - The aggregated result.\n *\n */\n// tslint:enable:max-line-length\nexport const aggregateBy = (data, descriptors = [], transformers = identity) => {\n    const initialValue = {};\n    if (!descriptors.length) {\n        return initialValue;\n    }\n    const result = exec(transformers(aggregatesCombinator(descriptors)), initialValue, data);\n    return expandAggregates(result);\n};\n","import { isCompositeFilterDescriptor } from \"./filter-descriptor.interface\";\nimport { getter } from \"../accessor\";\nimport { isFunction, isPresent, isDate, isString, isBlank, isArray } from \"../utils\";\nconst logic = {\n    \"or\": {\n        concat: (acc, fn) => a => acc(a) || fn(a),\n        identity: () => false\n    },\n    \"and\": {\n        concat: (acc, fn) => a => acc(a) && fn(a),\n        identity: () => true\n    }\n};\nconst operatorsMap = {\n    contains: (a, b) => (a || \"\").indexOf(b) >= 0,\n    doesnotcontain: (a, b) => (a || \"\").indexOf(b) === -1,\n    doesnotendwith: (a, b) => (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) < 0,\n    doesnotstartwith: (a, b) => (a || \"\").lastIndexOf(b, 0) === -1,\n    endswith: (a, b) => (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) >= 0,\n    eq: (a, b) => a === b,\n    gt: (a, b) => a > b,\n    gte: (a, b) => a >= b,\n    isempty: (a) => a === '',\n    isnotempty: (a) => a !== '',\n    isnotnull: (a) => isPresent(a),\n    isnull: (a) => isBlank(a),\n    lt: (a, b) => a < b,\n    lte: (a, b) => a <= b,\n    neq: (a, b) => a != b,\n    startswith: (a, b) => (a || \"\").lastIndexOf(b, 0) === 0\n};\nconst dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\nconst convertValue = (value, ignoreCase) => {\n    if (value != null && isString(value)) {\n        const date = dateRegExp.exec(value);\n        if (date) {\n            return new Date(+date[1]).getTime();\n        }\n        else if (ignoreCase) {\n            return value.toLowerCase();\n        }\n    }\n    else if (value != null && isDate(value)) {\n        return value.getTime();\n    }\n    return value;\n};\nconst typedGetter = (prop, value, ignoreCase, operator) => {\n    if (!isPresent(value)) {\n        return prop;\n    }\n    let acc = prop;\n    if (isString(value)) {\n        const date = dateRegExp.exec(value);\n        if (date) {\n            value = new Date(+date[1]);\n        }\n        else {\n            // For custom operators (functions), we should not transform the field value\n            // This allows custom operators to receive the original data type (e.g., arrays)\n            const isCustomOperator = isFunction(operator);\n            acc = a => {\n                const x = prop(a);\n                if (x === null) {\n                    return x;\n                }\n                // Don't convert arrays to strings when using custom operators\n                if (isCustomOperator && isArray(x)) {\n                    return x;\n                }\n                const stringValue = typeof x === 'string' ? x : x + \"\";\n                return ignoreCase ? stringValue.toLowerCase() : stringValue;\n            };\n        }\n    }\n    if (isDate(value)) {\n        return a => {\n            const x = acc(a);\n            return isDate(x) ? x.getTime() : x;\n        };\n    }\n    return acc;\n};\nconst transformFilter = ({ field, ignoreCase, value, operator }) => {\n    field = !isPresent(field) ? a => a : field;\n    ignoreCase = isPresent(ignoreCase) ? ignoreCase : true;\n    const itemProp = typedGetter(isFunction(field) ? field : getter(field, true), value, ignoreCase, operator);\n    value = convertValue(value, ignoreCase);\n    const op = isFunction(operator) ? operator : operatorsMap[operator];\n    return a => op(itemProp(a), value, ignoreCase);\n};\n/**\n * @hidden\n */\nexport const transformCompositeFilter = (filter) => {\n    const combiner = logic[filter.logic];\n    return filter.filters\n        .filter(isPresent)\n        .map(x => isCompositeFilterDescriptor(x) ? transformCompositeFilter(x) : transformFilter(x))\n        .reduce(combiner.concat, combiner.identity);\n};\n","import { isPresent } from '../utils';\nimport { isCompositeFilterDescriptor } from './filter-descriptor.interface';\nimport { normalizeFilters } from './filter.operators';\nimport { transformCompositeFilter } from \"./filter-no-eval\";\n// tslint:disable:max-line-length\n/**\n * Creates a [Predicate]({% slug api_kendo-data-query_predicate %}) function for the specified [CompositeFilterDescriptor]({% slug api_kendo-data-query_compositefilterdescriptor %}).\n *\n * @param {CompositeFilterDescriptor} descriptor - The descriptor for which the predicate is created.\n * @returns {Predicate} - The created function instance.\n *\n * @example\n * ```ts\n * import { compileFilter } from '@progress/kendo-data-query';\n *\n * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n * const predicate = compileFilter({ logic: \"and\", filters: [{ field: \"name\", operator: \"startswith\", value: \"P\" }] });\n * const result = data.filter(predicate);\n *\n * ```\n */\n// tslint:enable:max-line-length\nexport const compileFilter = (descriptor) => {\n    if (!descriptor || descriptor.filters.length === 0) {\n        return () => true;\n    }\n    return transformCompositeFilter(descriptor);\n};\n// tslint:disable:max-line-length\n/**\n * Filters the provided array according to the specified [CompositeFilterDescriptor]({% slug api_kendo-data-query_compositefilterdescriptor %}).\n *\n * @param {T[]} data - The data that will be filtered.\n * @param {(CompositeFilterDescriptor | FilterDescriptor)} descriptor - The filter criteria that will be applied.\n * @returns {T[]} - The filtered data.\n *\n * @example\n * ```ts\n * import { filterBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *  { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *  { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *  { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = filterBy(data, {\n *     logic: 'and',\n *     filters: [\n *           { field: \"name\", operator: \"startswith\", value: \"p\", ignoreCase: true },\n *           { field: \"subcategory\", operator: \"eq\", value: \"Meat\" },\n *     ]\n * });\n *\n * // output:\n * // [{ \"name\": \"Pork\", \"category\": \"Food\", \"subcategory\": \"Meat\" }]\n * ```\n */\n// tslint:enable:max-line-length\nexport const filterBy = (data, descriptor) => {\n    if (!isPresent(descriptor) || (isCompositeFilterDescriptor(descriptor) && descriptor.filters.length === 0)) {\n        return data;\n    }\n    return data.filter(compileFilter(normalizeFilters(descriptor)));\n};\n","import { exec, map, groupCombinator } from '../transducers';\nimport { isArray, isPresent } from '../utils';\nimport { aggregateBy } from './aggregate.operators';\nimport { filterBy } from '../filtering/filter-expression.factory';\nimport { composeSortDescriptors } from '../sorting/sort-array.operator';\n/**\n * @hidden\n */\nexport const normalizeGroups = (descriptors) => {\n    descriptors = isArray(descriptors) ? descriptors : [descriptors];\n    return descriptors.map(x => Object.assign({ dir: \"asc\" }, x));\n};\nconst identity = map(x => x);\n/**\n * Groups the provided data according to the specified descriptors.\n *\n * @param {Array} data - The data that will be grouped.\n * @param {GroupDescriptor[]} descriptors - The descriptors.\n * @param {any} transformers - For internal use.\n * @param {Array} originalData - For internal use.\n * @returns {(Array<GroupResult<T>> | T[])} - The grouped data.\n *\n * @example\n * ```ts\n *\n * import { groupBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = groupBy(data, [{ field: \"subcategory\" }]);\n * ```\n */\nexport const groupBy = (data, descriptors = [], transformers = identity, originalData = data) => {\n    descriptors = normalizeGroups(descriptors);\n    if (!descriptors.length) {\n        return data;\n    }\n    const descriptor = descriptors[0];\n    const initialValue = {};\n    const view = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);\n    const result = [];\n    Object.keys(view).forEach(field => {\n        Object.keys(view[field]).forEach(value => {\n            const group = view[field][value];\n            let aggregateResult = {};\n            let filteredData = originalData;\n            if (isPresent(descriptor.aggregates)) {\n                filteredData = filterBy(originalData, {\n                    field: descriptor.field,\n                    ignoreCase: false,\n                    operator: 'eq',\n                    value: group.value\n                });\n                aggregateResult = aggregateBy(filteredData, descriptor.aggregates);\n            }\n            result[group.__position] = {\n                aggregates: aggregateResult,\n                field: field,\n                items: descriptors.length > 1 ?\n                    groupBy(group.items, descriptors.slice(1), identity, filteredData)\n                    : group.items,\n                value: group.value\n            };\n        });\n    });\n    // Sort the result according to the descriptor's dir and compare options\n    if (isPresent(descriptor.dir) || isPresent(descriptor.compare)) {\n        const comparer = composeSortDescriptors([{\n                field: 'value',\n                dir: descriptor.dir,\n                compare: descriptor.compare\n            }]);\n        result.sort(comparer);\n    }\n    return result;\n};\n","import { isPresent, isString } from './utils';\nimport { composeSortDescriptors } from './sorting/sort-array.operator';\nimport { groupBy, normalizeGroups } from './grouping/group.operators';\nimport { normalizeFilters } from './filtering/filter.operators';\nimport { compileFilter } from './filtering/filter-expression.factory';\nimport { exec, skip, take, filter, concat } from './transducers';\nimport { getter } from './accessor';\nimport { compose } from './funcs';\n/**\n * Orders the specified array according to the provided sort descriptors.\n *\n * @param {T[]} data - The data to be sorted.\n * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.\n * @returns {T[]} - The sorted data.\n *\n * @example\n * ```ts\n * import { orderBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const sortDesc: SortDescriptor[] = [{ field: \"name\", dir: \"asc\" }];\n *\n * const result = orderBy(data, sortDesc);\n * ```\n */\nexport const orderBy = (data, descriptors) => {\n    if (descriptors.some(x => isPresent(x.dir) || isPresent(x.compare))) {\n        data = data.slice(0);\n        const comparer = composeSortDescriptors(descriptors);\n        data.sort(comparer);\n    }\n    return data;\n};\nconst defaultComparer = (a, b) => a === b;\nconst normalizeComparer = (comparer) => {\n    if (isString(comparer)) {\n        const accessor = getter(comparer);\n        comparer = (a, b) => accessor(a) === accessor(b);\n    }\n    return comparer;\n};\nconst _distinct = (data, comparer) => data.filter((x, idx, xs) => xs.findIndex(comparer.bind(null, x)) === idx);\n/**\n * Reduces the provided array so it contains only unique values.\n *\n * @param {T[]} data - The array that will be reduced.\n * @param {(Comparer | string)} comparer - An optional custom comparer function or the field name that will be used for comparison.\n * @returns {T[]} - The reduced data.\n *\n * @example\n * ```ts\n * import { distinct } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = distinct(data, \"subcategory\");\n *\n * // output:\n * // result => [\n * //     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n * //     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" }\n * // ];\n * ```\n */\nexport const distinct = (data, comparer = defaultComparer) => _distinct(data, normalizeComparer(comparer));\n/**\n * @hidden\n */\nexport const count = (data, predicate) => {\n    let counter = 0;\n    for (let idx = 0, length = data.length; idx < length; idx++) {\n        if (predicate(data[idx])) {\n            counter++;\n        }\n    }\n    return counter;\n};\n/**\n * @hidden\n */\nexport const limit = (data, predicate) => {\n    if (predicate) {\n        return data.filter(predicate);\n    }\n    return data;\n};\n/**\n * Applies the specified operation descriptors to the data.\n *\n * @param {T[]} data - The data to be processed.\n * @param {State} state - The operation descriptors that will be applied to the data.\n * @returns {DataResult} - The processed data.\n *\n * @example\n * ```ts\n *\n * const result = process(data, {\n *     skip: 10,\n *     take: 20,\n *     group: [{\n *       field: 'category.categoryName',\n *             aggregates: [\n *                   { aggregate: \"sum\", field: \"unitPrice\" },\n *                   { aggregate: \"sum\", field: \"unitsInStock\" }\n *             ]\n *       }],\n *     sort: [{ field: 'productName', dir: 'desc' }],\n *     filter: {\n *         logic: \"or\",\n *         filters: [\n *           { field: \"discontinued\", operator: \"eq\", value: true },\n *           { field: \"unitPrice\", operator: \"lt\", value: 22 }\n *         ]\n *     }\n * });\n *\n * ```\n */\nexport const process = (data, state) => {\n    const { skip: skipCount, take: takeCount, filter: filterDescriptor, sort, group } = state;\n    const sortDescriptors = [...normalizeGroups(group || []), ...sort || []];\n    if (sortDescriptors.length) {\n        data = orderBy(data, sortDescriptors);\n    }\n    const hasFilters = isPresent(filterDescriptor) && filter.length;\n    const hasGroups = isPresent(group) && group.length;\n    if (!hasFilters && !hasGroups) {\n        return {\n            data: takeCount ? data.slice(skipCount, skipCount + takeCount) : data,\n            total: data.length\n        };\n    }\n    let total;\n    const transformers = [];\n    let predicate;\n    if (hasFilters) {\n        predicate = compileFilter(normalizeFilters(filterDescriptor));\n        total = count(data, predicate);\n        transformers.push(filter(predicate));\n    }\n    else {\n        total = data.length;\n    }\n    if (isPresent(skipCount) && isPresent(takeCount)) {\n        transformers.push(skip(skipCount));\n        transformers.push(take(takeCount));\n    }\n    if (transformers.length) {\n        const transform = compose(...transformers);\n        const result = hasGroups ?\n            groupBy(data, group, transform, limit(data, predicate)) :\n            exec(transform(concat), [], data);\n        return { data: result, total: total };\n    }\n    return {\n        data: hasGroups ? groupBy(data, group) : data,\n        total: total\n    };\n};\n","/**\n * Represents the list of supported [`FilterDescriptor`]({% slug api_kendo-data-query_filterdescriptor %}) operators.\n * Allows restricting `FilterDescriptor.operator` definition to available values only.\n */\nexport var FilterOperator;\n(function (FilterOperator) {\n    /**\n     * The `contains` operator.\n     */\n    FilterOperator[\"Contains\"] = \"contains\";\n    /**\n     * The `doesnotcontain` operator.\n     */\n    FilterOperator[\"DoesNotContain\"] = \"doesnotcontain\";\n    /**\n     * The `doesnotendwith` operator.\n     */\n    FilterOperator[\"DoesNotEndWith\"] = \"doesnotendwith\";\n    /**\n     * The `doesnotstartwith` operator.\n     */\n    FilterOperator[\"DoesNotStartWith\"] = \"doesnotstartwith\";\n    /**\n     * The `endswith` operator.\n     */\n    FilterOperator[\"EndsWith\"] = \"endswith\";\n    /**\n     * The `eq` operator.\n     */\n    FilterOperator[\"EqualTo\"] = \"eq\";\n    /**\n     * The `gt` operator.\n     */\n    FilterOperator[\"GreaterThan\"] = \"gt\";\n    /**\n     * The `gte` operator.\n     */\n    FilterOperator[\"GreaterThanOrEqual\"] = \"gte\";\n    /**\n     * The `isempty` operator.\n     */\n    FilterOperator[\"IsEmpty\"] = \"isempty\";\n    /**\n     * The `isnotempty` operator.\n     */\n    FilterOperator[\"IsNotEmpty\"] = \"isnotempty\";\n    /**\n     * The `isnotnull` operator.\n     */\n    FilterOperator[\"IsNotNull\"] = \"isnotnull\";\n    /**\n     * The `isnull` operator.\n     */\n    FilterOperator[\"IsNull\"] = \"isnull\";\n    /**\n     * The `lt` operator.\n     */\n    FilterOperator[\"LessThan\"] = \"lt\";\n    /**\n     * The `lte` operator.\n     */\n    FilterOperator[\"LessThanOrEqual\"] = \"lte\";\n    /**\n     * The `neq` operator.\n     */\n    FilterOperator[\"NotEqualTo\"] = \"neq\";\n    /**\n     * The `startswith` operator.\n     */\n    FilterOperator[\"StartsWith\"] = \"startswith\";\n})(FilterOperator || (FilterOperator = {}));\n","import { compileFilter } from '@progress/kendo-data-query';\nfunction forEachDesc(desc, callbackfn) {\n    if ('filters' in desc) {\n        desc.filters.map(child => forEachDesc(child, callbackfn));\n    }\n    else {\n        callbackfn(desc);\n    }\n}\nconst filterFields = (filter, callback) => {\n    const descriptors = Array.isArray(filter) ? filter : filter.filters;\n    descriptors.forEach(desc => forEachDesc(desc, callback));\n};\n/** @hidden */\nexport const initializeFiltering = (rows, columns, filter) => {\n    const compositeFilter = filter ?\n        (Array.isArray(filter) ? { logic: 'and', filters: filter } : filter) : undefined;\n    const predicate = compositeFilter ? compileFilter(compositeFilter) : () => true;\n    const axes = rows.concat(columns);\n    const fieldValues = [];\n    filterFields(filter || [], (desc) => {\n        if ('field' in desc && desc.field) {\n            fieldValues.push(desc.field);\n        }\n    });\n    const result = { hasFilter: false, predicate, filteringAxes: [] };\n    if (fieldValues.some(f => typeof f === 'function')) {\n        result.filteringAxes = axes.slice();\n    }\n    else if (fieldValues.length > 0) {\n        const filteringFields = Array.from(new Set(fieldValues).values());\n        const filteringAxes = axes.filter(a => filteringFields.indexOf(a.key) >= 0);\n        result.filteringAxes = filteringAxes;\n    }\n    result.hasFilter = result.filteringAxes.length > 0;\n    return result;\n};\n","/** @hidden */\nexport const subNode = (node, field, initialNode) => {\n    let childNode = node.get(field);\n    if (!childNode) {\n        childNode = initialNode || new Map();\n        node.set(field, childNode);\n    }\n    return childNode;\n};\nconst separator = '&';\n/** @hidden */\nexport const createKey = (key, value) => key + separator + value;\n/** @hidden */\nexport const splitKeyValue = (keyValue) => {\n    const separatorIndex = keyValue.indexOf(separator);\n    if (separatorIndex !== -1) {\n        const key = keyValue.substring(0, separatorIndex);\n        const value = keyValue.substring(separatorIndex + 1);\n        return [key, value];\n    }\n    else {\n        return [keyValue, undefined];\n    }\n};\n","import { initializeFiltering } from './filtering';\nimport { subNode, createKey } from './utils';\nconst calculateColumnData = (node, measures, dataField) => {\n    node.forEach((childNode, k) => {\n        if (k !== dataField) {\n            if (childNode.size > 0) {\n                calculateColumnData(childNode, measures, dataField);\n            }\n            const childData = childNode.get(dataField);\n            const parentData = subNode(node, dataField, {});\n            measures.forEach(m => {\n                m.aggregate.init(parentData);\n                m.aggregate.merge(childData, parentData);\n            });\n        }\n    });\n};\n/** @hidden */\nexport const mergeTrees = (src, dest, measures, dataField) => {\n    src.forEach((srcChild, k) => {\n        let destChild;\n        if (k !== dataField) {\n            destChild = subNode(dest, k);\n            mergeTrees(srcChild, destChild, measures, dataField);\n        }\n        else {\n            destChild = subNode(dest, k, {});\n            measures.forEach(m => {\n                m.aggregate.init(destChild);\n                m.aggregate.merge(srcChild, destChild);\n            });\n        }\n    });\n};\nconst calculateColumns = (node, measures, columnsData, dataField) => {\n    node.forEach((childNode, k) => {\n        if (k !== columnsData) {\n            if (childNode.size > 0) {\n                calculateColumns(childNode, measures, columnsData, dataField);\n            }\n            const srcColumns = subNode(childNode, columnsData);\n            const destColumns = subNode(node, columnsData);\n            mergeTrees(srcColumns, destColumns, measures, dataField);\n        }\n    });\n};\n/** @hidden */\nexport const createDataTree = (data, rows, columns, measures, fields, filter) => {\n    const result = new Map();\n    const cache = new Map();\n    const axes = rows.concat(columns);\n    const leafNodes = new Set();\n    const { dataField, columnsData } = fields;\n    const { hasFilter, predicate, filteringAxes } = initializeFiltering(rows, columns, filter);\n    const empty = '';\n    data.forEach(dataItem => {\n        if (hasFilter) {\n            const filteringDataItem = {};\n            filteringAxes.forEach((axis) => { filteringDataItem[axis.key] = axis.displayValue(dataItem); });\n            if (!predicate(filteringDataItem)) {\n                return;\n            }\n        }\n        const values = axes.map(a => a.displayValue(dataItem));\n        const dataKey = empty.concat(...values);\n        let nodeData = cache.get(dataKey);\n        if (!nodeData) {\n            let node = result;\n            const eachAxis = (axis) => {\n                node = subNode(node, createKey(axis.key, axis.displayValue(dataItem)));\n            };\n            rows.forEach(eachAxis);\n            node = subNode(node, columnsData);\n            leafNodes.add(node);\n            columns.forEach(eachAxis);\n            nodeData = {};\n            node.set(dataField, nodeData);\n            cache.set(dataKey, nodeData);\n            measures.forEach(m => {\n                m.aggregate.init(nodeData);\n            });\n        }\n        measures.forEach(m => {\n            m.aggregate.accumulate(nodeData, m.value(dataItem));\n        });\n    });\n    leafNodes.forEach(leaf => calculateColumnData(leaf, measures, dataField));\n    calculateColumns(result, measures, columnsData, dataField);\n    return result;\n};\n/** @hidden */\nexport const cloneDataTree = (dataTree, dataField, measures) => {\n    const result = new Map();\n    mergeTrees(dataTree, result, measures, dataField);\n    return result;\n};\n","import { mergeTrees } from './dataTree';\nimport { splitKeyValue } from './utils';\nconst createPath = (name, axes, path) => {\n    const [key, value] = splitKeyValue(name);\n    const result = path.slice();\n    if (key && value) {\n        const axis = axes.find(a => a.key === key);\n        const caption = axis ? axis.caption : '';\n        return result.map(p => p === caption ? name : p);\n    }\n    return result;\n};\nconst membersNode = (tree, members, field, axisSettings, measures, dataField, cache) => {\n    const cacheData = cache || new Map();\n    let path = axisSettings.map(a => a.caption);\n    while (members.length > 1 && axisSettings.some(a => a.caption === members[members.length - 1].caption)) {\n        members.pop();\n        path.pop();\n    }\n    let node = tree;\n    members.forEach((m, i) => {\n        path = createPath(m.name, axisSettings, path);\n        if (node && !axisSettings.some(a => a.caption === m.name)) {\n            if (!node.has(m.name) && !cacheData.has(path.slice(0, path.indexOf(m.name) + 1).join('-'))) {\n                const currentLevel = Array.from(node).find(n => n[0] !== field);\n                const currentLevelNode = currentLevel && currentLevel[0];\n                const levelField = currentLevelNode && splitKeyValue(currentLevelNode)[0];\n                const depth = levelField ? i - axisSettings.findIndex(a => a.key === levelField) : 0;\n                for (let t = 0; t < depth; t++) {\n                    const data = [];\n                    node.forEach((value, key) => {\n                        if (key !== field) {\n                            data.push(...Array.from(value).filter(d => d[0] !== field));\n                        }\n                    });\n                    const next = new Map();\n                    data.forEach(item => {\n                        if (next.has(item[0])) {\n                            const dest = next.get(item[0]);\n                            const src = item[1];\n                            const newDest = new Map();\n                            mergeTrees(dest, newDest, measures, dataField);\n                            mergeTrees(src, newDest, measures, dataField);\n                            next.set(item[0], newDest);\n                        }\n                        else {\n                            next.set(item[0], new Map(item[1]));\n                        }\n                    });\n                    const currentPath = path.slice(0, path.indexOf(m.name));\n                    next.forEach((value, key) => {\n                        cacheData.set(createPath(key, axisSettings, currentPath.concat([key])).join('-'), value);\n                    });\n                    next.set(field, node.get(field));\n                    node = next;\n                }\n            }\n            node = node.get(m.name) || cacheData.get(path.slice(0, path.indexOf(m.name) + 1).join('-'));\n        }\n    });\n    return node;\n};\n/** @hidden */\nexport const readData = (dataTree, rowTuples, columnTuples, fields, columnSettings, rowSettings, measures) => {\n    const data = [];\n    const { dataField, columnsData } = fields;\n    const rowsCache = new Map();\n    rowTuples.forEach(row => {\n        const rowNode = membersNode(dataTree, row.members.slice(), columnsData, rowSettings, measures, dataField, rowsCache);\n        const rowColumnsNode = rowNode && rowNode.get(columnsData);\n        columnTuples.forEach(col => {\n            const members = col.members.slice();\n            let measure = measures[0];\n            if (members[members.length - 1].levelName === \"[Measures].[MeasuresLevel]\") {\n                const measuresMember = members.pop();\n                measure = measures.find(m => String(m.name) === measuresMember.caption) || measure;\n            }\n            const colNode = rowColumnsNode && membersNode(rowColumnsNode, members, dataField, columnSettings, measures, dataField);\n            let value = '', fmtValue = '';\n            const ordinal = 0;\n            if (colNode && measure) {\n                const result = measure.aggregate.result(colNode.get(dataField));\n                value = String(result);\n                fmtValue = measure.aggregate.format(result);\n            }\n            data.push({\n                columnTuple: col,\n                data: { fmtValue, ordinal, value },\n                rowTuple: row\n            });\n        });\n    });\n    return data;\n};\n","import { copy, reverseColumnsByMeasures } from '../utils';\nimport { splitKeyValue, subNode } from './utils';\nimport { readData } from './dataReader';\nconst getTopMembersTuple = (parentFields, axesSettings) => {\n    const allTuple = { members: [] };\n    parentFields.forEach((topField) => {\n        const axis = axesSettings.find(a => a.key === topField);\n        const caption = axis ? axis.caption : \"\";\n        const member = {\n            caption: caption,\n            children: [],\n            hasChildren: true,\n            parentName: \"\",\n            levelNum: 0,\n            levelName: caption,\n            hierarchy: topField,\n            name: caption\n        };\n        allTuple.members.push(member);\n    });\n    return allTuple;\n};\nconst sortFunc = (descriptor, axe) => (a, b) => {\n    const order = descriptor.dir;\n    const sortableA = axe.sortValue(splitKeyValue(a[0])[1]);\n    const sortableB = axe.sortValue(splitKeyValue(b[0])[1]);\n    if (sortableA < sortableB) {\n        return order === \"asc\" ? -1 : 1;\n    }\n    if (sortableA > sortableB) {\n        return order === \"asc\" ? 1 : -1;\n    }\n    return 0;\n};\nconst mergeData = (src, dest, exclude) => {\n    src.forEach((srcChild, k) => {\n        if (!exclude[k]) {\n            const destChild = subNode(dest, k);\n            mergeData(srcChild, destChild, exclude);\n        }\n    });\n};\nconst childrenByKeys = (dataTree, keys, exclude) => {\n    const result = [];\n    const nodeData = (node) => Array.from(node).filter(n => !exclude[n[0]]);\n    let element = new Map(dataTree);\n    let next;\n    for (let i = 0; i < keys.length; i++) {\n        next = element.get(keys[i]);\n        if (next) {\n            element = new Map(next);\n        }\n        else if (i < keys.length - 1 && Array.from(element).some(e => splitKeyValue(e[0])[0] === keys[i])) {\n            const curLevel = [];\n            element.forEach((child, key) => {\n                if (!exclude[key]) {\n                    curLevel.push(...nodeData(new Map(child)));\n                }\n            });\n            element = new Map();\n            curLevel.forEach(item => {\n                if (element.has(item[0])) {\n                    const dest = element.get(item[0]);\n                    const src = item[1];\n                    const newDest = new Map();\n                    mergeData(dest, newDest, exclude);\n                    mergeData(src, newDest, exclude);\n                    element.set(item[0], newDest);\n                }\n                else {\n                    element.set(item[0], new Map(item[1]));\n                }\n            });\n        }\n        else if (i === 0 || i === keys.length - 1) {\n            if (Array.from(element).some(e => splitKeyValue(e[0])[0] === keys[i])) {\n                result.push(...nodeData(element));\n            }\n        }\n    }\n    return result;\n};\n/** @hidden */\nexport const rootFields = (definitions) => {\n    const fields = new Set();\n    definitions.forEach((item) => {\n        if (item.name.length === 1 && !splitKeyValue(item.name[0])[1]) {\n            fields.add(item.name[0]);\n        }\n    });\n    return fields;\n};\n/** @hidden */\nexport const createTuples = (axesSettings, definitions, dataTree, sortDescriptors, excludeFields) => {\n    const parentFields = rootFields(definitions);\n    const flatMembers = [];\n    const topTuple = getTopMembersTuple(parentFields, axesSettings);\n    flatMembers.push(topTuple);\n    for (let i = 0; i < definitions.length; i++) {\n        const currDef = definitions[i];\n        if (currDef.name.length === 1 && !currDef.expand && parentFields.has(currDef.name[0])) {\n            continue;\n        }\n        const keysToAdd = new Set(parentFields.keys());\n        const currDefMembers = [];\n        const keys = [];\n        const tuples = [];\n        let axe;\n        currDef.name.forEach((element, index) => {\n            const [field, value] = splitKeyValue(element);\n            axe = axesSettings.find(a => a.key === field);\n            if (value) {\n                keysToAdd.delete(field);\n                keys.push(element);\n                const member = {\n                    children: [],\n                    caption: value,\n                    hierarchy: field,\n                    levelNum: 1,\n                    levelName: field + \" \" + field,\n                    name: element,\n                    parentName: axe ? axe.caption : \"\"\n                };\n                currDefMembers.push(member);\n            }\n            else if (currDef.expand && currDef.name.length - 1 === index) {\n                keysToAdd.delete(element);\n                keys.push(element);\n                const children = childrenByKeys(dataTree, keys, excludeFields);\n                const descriptor = sortDescriptors.find(desc => desc.field === field);\n                if (descriptor && descriptor.dir) {\n                    children.sort(sortFunc(descriptor, axe));\n                }\n                for (let c = 0; c < children.length; c++) {\n                    const leafValue = children[c][0];\n                    const leafTuple = { members: [] };\n                    tuples.push(leafTuple);\n                    const caption = splitKeyValue(leafValue)[1];\n                    axe = axesSettings.find(a => a.key === element);\n                    const member = {\n                        caption: caption,\n                        children: [],\n                        levelName: element + \" \" + element,\n                        levelNum: 1,\n                        parentName: axe ? axe.caption : \"\",\n                        hierarchy: element,\n                        name: leafValue\n                    };\n                    leafTuple.members.push(...currDefMembers);\n                    leafTuple.members.push(member);\n                }\n            }\n            else if (currDef.expand) {\n                axe = axesSettings.find(a => a.key === element);\n                const axisCaption = axe ? axe.caption : \"\";\n                keysToAdd.delete(element);\n                keys.push(element);\n                const member = {\n                    children: [],\n                    caption: axisCaption,\n                    hierarchy: element,\n                    levelName: axisCaption,\n                    levelNum: 0,\n                    name: axisCaption,\n                    parentName: \"\"\n                };\n                currDefMembers.push(member);\n            }\n            keysToAdd.forEach(key => {\n                tuples.forEach((tuple) => {\n                    axe = axesSettings.find(a => a.key === key);\n                    const curCaption = axe ? axe.caption : \"\";\n                    const member = {\n                        children: [],\n                        hasChildren: true,\n                        caption: curCaption,\n                        hierarchy: key,\n                        levelName: curCaption,\n                        levelNum: 0,\n                        name: curCaption,\n                        parentName: \"\"\n                    };\n                    tuple.members.push(member);\n                });\n            });\n            flatMembers.push(...tuples);\n        });\n    }\n    return flatMembers;\n};\nconst measureToMember = (measure) => {\n    return {\n        caption: String(measure.name),\n        children: [],\n        hasChildren: false,\n        hierarchy: \"[Measures]\",\n        levelName: \"[Measures].[MeasuresLevel]\",\n        levelNum: 0,\n        name: \"[Measures].[\" + measure.name + \"]\",\n        parentName: \"\"\n    };\n};\nconst addMeasure = (tuple, measure) => {\n    const measureMember = measureToMember(measure);\n    const tupleCopy = copy(tuple);\n    tupleCopy.members.push(measureMember);\n    return tupleCopy;\n};\n/** @hidden */\nexport const addMultipleMeasures = (tuples, measures) => {\n    if (measures.length < 2) {\n        return tuples;\n    }\n    const result = tuples.slice();\n    for (let i = result.length - 1; i >= 0; i--) {\n        const tuple = result[i];\n        result[i] = addMeasure(result[i], measures[0]);\n        for (let m = 1; m < measures.length; m++) {\n            const tupleWithMeasure = addMeasure(tuple, measures[m]);\n            result.splice(i + m, 0, tupleWithMeasure);\n        }\n    }\n    return reverseColumnsByMeasures(result);\n};\n/** @hidden */\nexport const createLocalDataState = (args) => {\n    const { dataTree, rowSettings, columnSettings, rowAxes, columnAxes, measures, sort, fields } = args;\n    const exclude = { [fields.columnsData]: fields.columnsData, [fields.dataField]: fields.dataField };\n    const colTuples = columnAxes.length ?\n        createTuples(columnSettings, columnAxes, dataTree.get(fields.columnsData), sort, exclude) :\n        measures.map(m => ({ members: [measureToMember(m)] }));\n    const columnTuples = columnAxes.length > 0 ? addMultipleMeasures(colTuples, measures) : colTuples;\n    const rowTuples = rowAxes.length ? createTuples(rowSettings, rowAxes, dataTree, sort, exclude) : [{ members: [] }];\n    const resultData = readData(dataTree, rowTuples, columnTuples, fields, columnSettings, rowSettings, measures);\n    return {\n        columns: columnTuples,\n        data: resultData,\n        rows: rowTuples\n    };\n};\n","/** @hidden */\nexport const createFlatSchemaDimensions = (dimensions, measures) => {\n    const result = Object.keys(dimensions).map(dim => ({\n        caption: dim,\n        defaultHierarchy: dim,\n        description: '',\n        name: dim,\n        uniqueName: dim,\n        hierarchyUniqueName: dim,\n        measure: true,\n        type: 1 // https://github.com/telerik/kendo-pivotgrid-common/blob/develop/src/models/responseDiscover.ts#L12-L14\n    }));\n    if (measures.length) {\n        result.push({\n            caption: 'Measures',\n            children: measures.map(m => ({\n                aggregator: '1',\n                caption: String(m.name),\n                defaultFormat: '',\n                description: '',\n                displayFolder: '',\n                groupName: String(m.name),\n                name: String(m.name),\n                uniqueName: String(m.name)\n            })),\n            type: 2,\n            description: '',\n            name: 'Measures',\n            uniqueName: '[Measures]'\n        });\n    }\n    return result;\n};\n","export class Navigation {\n    get elements() {\n        return this.root ? Array.from(this.root.querySelectorAll(this.selectors.join(','))) : [];\n    }\n    get first() {\n        return (this.root && this.root.querySelector(this.selectors.join(','))) || null;\n    }\n    get last() {\n        const all = this.elements;\n        return all[all.length - 1] || null;\n    }\n    get current() {\n        return this.elements.find(el => el.matches(':focus'));\n    }\n    constructor(options) {\n        this.tabIndex = 0;\n        this.root = null;\n        this.eventHandlers = {};\n        this.update = () => { };\n        this.tabIndex = options.tabIndex;\n    }\n    start(root) {\n        this.root = root;\n        for (const eventType in this.mouseEvents) {\n            if (this.mouseEvents[eventType]) {\n                this.eventHandlers[eventType] = (ev => {\n                    const target = ev.target instanceof Element && ev.target.closest(this.selectors.join(','));\n                    if (target) {\n                        this.mouseEvents[eventType].call(undefined, target, this, ev);\n                    }\n                });\n                root.addEventListener(eventType, this.eventHandlers[eventType]);\n            }\n        }\n        for (const eventType in this.keyboardEvents) {\n            if (this.keyboardEvents[eventType]) {\n                this.eventHandlers[eventType] = (ev => {\n                    const target = ev.target instanceof Element && ev.target.closest(this.selectors.join(','));\n                    const key = ev.key === ' ' ? 'Space' : ev.key;\n                    if (target && this.keyboardEvents[eventType][key]) {\n                        this.keyboardEvents[eventType][key].call(undefined, target, this, ev);\n                    }\n                });\n                root.addEventListener(eventType, this.eventHandlers[eventType]);\n            }\n        }\n    }\n    stop() {\n        if (this.root) {\n            for (const eventType in this.eventHandlers) {\n                if (this.eventHandlers[eventType]) {\n                    this.root.removeEventListener(eventType, this.eventHandlers[eventType]);\n                }\n            }\n        }\n        this.root = null;\n    }\n    focusElement(element, previous) {\n        if (element) {\n            if (previous) {\n                previous.removeAttribute('tabindex');\n                previous.classList.remove('k-focus');\n            }\n            element.setAttribute('tabindex', String(this.tabIndex));\n            element.focus({ preventScroll: true });\n        }\n    }\n}\n","import { Navigation } from './navigation';\nconst scrollableValuesSel = '.k-pivotgrid .k-pivotgrid-values';\nconst scrollableColumnHeaderSel = '.k-pivotgrid .k-pivotgrid-column-headers';\nconst scrollableRowHeaderSel = '.k-pivotgrid .k-pivotgrid-row-headers';\nconst emptyCellSel = '.k-pivotgrid > .k-pivotgrid-empty-cell';\nconst tableSel = 'table.k-pivotgrid-table';\nconst cellSel = '.k-pivotgrid-cell';\nconst scrollables = [scrollableValuesSel, scrollableColumnHeaderSel, scrollableRowHeaderSel].join(',');\nconst selectors = [\n    emptyCellSel,\n    [scrollableColumnHeaderSel, tableSel, cellSel].join(' '),\n    [scrollableRowHeaderSel, tableSel, cellSel].join(' '),\n    [scrollableValuesSel, tableSel, cellSel].join(' ')\n];\nconst onEnter = (target, nav, ev) => {\n    const icon = target.querySelector('.k-icon, .k-svg-icon');\n    if (icon) {\n        const index = nav.elements.indexOf(target);\n        nav.update = () => {\n            nav.focusElement(nav.elements[index], null);\n            nav.update = () => { };\n        };\n        icon.click();\n        ev.preventDefault();\n    }\n};\nconst tryScrollLeft = (target, scrollable, elToScroll) => {\n    if (target.offsetLeft < scrollable.scrollLeft) {\n        elToScroll.scrollLeft = target.offsetLeft;\n    }\n};\nconst tryScrollRight = (target, scrollable, elToScroll) => {\n    if (target.offsetLeft + target.offsetWidth > scrollable.scrollLeft + scrollable.offsetWidth &&\n        target.offsetWidth < scrollable.offsetWidth) {\n        elToScroll.scrollLeft = target.offsetLeft + target.offsetWidth - scrollable.offsetWidth;\n    }\n};\nconst tryScrollUp = (target, scrollable, elToScroll) => {\n    if (scrollable.scrollTop && target.offsetTop < scrollable.scrollTop) {\n        elToScroll.scrollTop = target.offsetTop;\n    }\n};\nconst tryScrollDown = (target, scrollable, elToScroll) => {\n    if (target.offsetTop + target.offsetHeight > scrollable.scrollTop + scrollable.offsetHeight &&\n        target.offsetHeight < scrollable.offsetHeight) {\n        elToScroll.scrollTop = target.offsetTop + target.offsetHeight - scrollable.offsetHeight;\n    }\n};\nconst scrollTo = (target, root, scrollFunc) => {\n    const elToScroll = root.querySelector(scrollableValuesSel);\n    const scrollable = target && target.closest(scrollables);\n    if (!elToScroll || !scrollable || !target) {\n        return;\n    }\n    scrollFunc.forEach(scroll => scroll(target, scrollable, elToScroll));\n};\nconst tableMap = (table) => {\n    const rows = Array.from(table.rows);\n    const colsCount = Array.from((rows && rows[0] && rows[0].cells) || [])\n        .map(c => c.colSpan)\n        .reduce((prev, cur) => prev + cur, 0);\n    const map = rows.map(() => new Array(colsCount));\n    rows.forEach((row, r) => {\n        let curColSpan = 0;\n        Array.from(row.cells).forEach((c) => {\n            for (let colSp = 0; colSp < c.colSpan; colSp++) {\n                for (let rowSp = 0; rowSp < c.rowSpan; rowSp++) {\n                    const ind = map[r + rowSp].findIndex((val, curInd) => curInd >= curColSpan && !val);\n                    map[r + rowSp][ind] = c;\n                }\n                curColSpan++;\n            }\n        });\n    });\n    return map;\n};\nconst navigationMap = (root) => {\n    const columnHeader = tableMap(root.querySelector([scrollableColumnHeaderSel, tableSel].join(' ')));\n    const rowHeader = tableMap(root.querySelector([scrollableRowHeaderSel, tableSel].join(' ')));\n    const values = tableMap(root.querySelector([scrollableValuesSel, tableSel].join(' ')));\n    const emptyCell = root.querySelector(emptyCellSel);\n    const emptyCellRow = new Array(rowHeader[0].length).fill(emptyCell);\n    const map = [];\n    for (let i = 0; i < columnHeader.length; i++) {\n        map.push(emptyCellRow.concat(columnHeader[i]));\n    }\n    for (let i = 0; i < rowHeader.length; i++) {\n        map.push(rowHeader[i].concat(values[i]));\n    }\n    return map;\n};\nconst getTargetPos = (map, target) => {\n    for (let r = 0; r < map.length; r++) {\n        for (let c = 0; c < map[r].length; c++) {\n            if (map[r][c] === target) {\n                return [r, c];\n            }\n        }\n    }\n    return [-1, -1];\n};\nconst ctrlKey = (ev) => ev.ctrlKey || ev.metaKey;\nconst cellAt = (root, target, pos) => {\n    const map = navigationMap(root);\n    const targetPos = getTargetPos(map, target);\n    let nextPos = [targetPos[0] + pos[0], targetPos[1] + pos[1]];\n    let next = map[nextPos[0]] && map[nextPos[0]][nextPos[1]];\n    while (next && next === target) {\n        nextPos = [nextPos[0] + pos[0], nextPos[1] + pos[1]];\n        next = map[nextPos[0]] && map[nextPos[0]][nextPos[1]];\n    }\n    return next;\n};\nconst keyboardEvents = {\n    keydown: {\n        ArrowLeft: (target, nav, ev) => {\n            ev.preventDefault();\n            const next = cellAt(nav.root, target, [0, -1]);\n            nav.focusElement(next, target);\n            scrollTo(next, nav.root, [tryScrollRight, tryScrollLeft, tryScrollDown, tryScrollUp]);\n        },\n        ArrowRight: (target, nav, ev) => {\n            ev.preventDefault();\n            const next = cellAt(nav.root, target, [0, 1]);\n            nav.focusElement(next, target);\n            scrollTo(next, nav.root, [tryScrollLeft, tryScrollRight, tryScrollDown, tryScrollUp]);\n        },\n        ArrowUp: (target, nav, ev) => {\n            ev.preventDefault();\n            const next = cellAt(nav.root, target, [-1, 0]);\n            nav.focusElement(next, target);\n            scrollTo(next, nav.root, [tryScrollRight, tryScrollLeft, tryScrollDown, tryScrollUp]);\n        },\n        ArrowDown: (target, nav, ev) => {\n            ev.preventDefault();\n            const next = cellAt(nav.root, target, [1, 0]);\n            nav.focusElement(next, target);\n            scrollTo(next, nav.root, [tryScrollRight, tryScrollLeft, tryScrollUp, tryScrollDown]);\n        },\n        o: (_target, nav, _ev) => {\n            if (!nav.root) {\n                return;\n            }\n            const next = nav.root.nextElementSibling;\n            if (next && next instanceof HTMLElement && next.matches('div.k-pivotgrid-configurator-button')) {\n                next.click();\n                setTimeout(() => {\n                    if (nav.root.parentNode) {\n                        const confHeader = nav.root.parentNode.querySelector('.k-pivotgrid-configurator-content .k-form-field .k-fields-list-wrapper .k-treeview');\n                        if (confHeader instanceof HTMLElement) {\n                            confHeader.setAttribute('tabindex', String(nav.tabIndex));\n                            confHeader.focus();\n                        }\n                    }\n                }, 0);\n            }\n        },\n        Enter: onEnter,\n        Space: onEnter,\n        Home: (target, nav, ev) => {\n            const map = navigationMap(nav.root);\n            const ctrl = ctrlKey(ev);\n            const row = ctrl ? map[0] : (map.find(ro => Boolean(ro.find(x => x === target))) || []);\n            const next = row[0];\n            if (next) {\n                nav.focusElement(next, target);\n                scrollTo(next, nav.root, [tryScrollRight, tryScrollLeft, tryScrollDown, tryScrollUp]);\n                ev.preventDefault();\n            }\n        },\n        End: (target, nav, ev) => {\n            const map = navigationMap(nav.root);\n            const ctrl = ctrlKey(ev);\n            const row = ctrl ? map[map.length - 1] : (map.find(ro => Boolean(ro.find(x => x === target))) || []);\n            const next = row && row[row.length - 1] || null;\n            if (next) {\n                nav.focusElement(next, target);\n                scrollTo(next, nav.root, [tryScrollLeft, tryScrollRight, tryScrollUp, tryScrollDown]);\n                ev.preventDefault();\n            }\n        }\n    }\n};\nconst mouseEvents = {\n    click: (target, nav) => {\n        if (target && target instanceof HTMLElement) {\n            const prev = nav.elements.find(c => c.hasAttribute('tabindex')) || null;\n            nav.focusElement(target, prev);\n        }\n    }\n};\n/**\n * The PivotGrid keyboard navigation functionality.\n *\n * Usage:\n *\n * On Initialize\n * const navigation = new PivotGridNavigation({ tabindex: 0 });\n *\n * Turn on\n * navigation.start(rootDomElement);\n *\n * On After Update\n * navigation.update();\n *\n * On Destroy / Turn off\n * navigation.stop();\n */\nexport class PivotGridNavigation extends Navigation {\n    constructor() {\n        super(...arguments);\n        this.selectors = selectors;\n        this.mouseEvents = mouseEvents;\n        this.keyboardEvents = keyboardEvents;\n    }\n}\n","import { Navigation } from './navigation';\nconst selectors = [\n    '.k-pivotgrid-configurator-content .k-form-field .k-fields-list-wrapper .k-treeview',\n    '.k-pivotgrid-configurator-content .k-chip',\n    '.k-pivotgrid-configurator-actions button'\n];\nconst onEscape = (_target, nav, ev) => {\n    if (ev.target instanceof HTMLElement) {\n        if (nav.root) {\n            const pivot = nav.root.previousElementSibling;\n            const confButton = nav.root.nextElementSibling;\n            const pivotCell = Array.from(pivot instanceof HTMLElement ? pivot.querySelectorAll('[tabindex]') : []).find((c) => c.tabIndex >= 0);\n            if (pivotCell instanceof HTMLElement) {\n                pivotCell.focus();\n                if (confButton instanceof HTMLElement) {\n                    confButton.click();\n                }\n            }\n        }\n    }\n};\nconst navigate = (target, nav, ev, dir) => {\n    ev.preventDefault();\n    const all = nav.elements;\n    let index = all.indexOf(target) + dir;\n    if (index < 0) {\n        index = all.length - 1;\n    }\n    nav.focusElement(all[index % all.length], target);\n};\nconst onDelete = (target, nav, ev) => {\n    if (ev.target instanceof HTMLElement) {\n        const deleteButton = ev.target.querySelector('.k-icon.k-i-x-circle, .k-svg-icon.k-svg-i-x-circle');\n        if (deleteButton instanceof HTMLElement) {\n            ev.preventDefault();\n            navigate(target, nav, ev, -1);\n        }\n    }\n};\nconst keyboardEvents = {\n    keydown: {\n        Tab: (target, nav, ev) => {\n            navigate(target, nav, ev, ev.shiftKey ? -1 : 1);\n        },\n        Escape: onEscape,\n        Delete: onDelete,\n        Backspace: onDelete\n    }\n};\nconst mouseEvents = {\n    click: (target, nav) => {\n        if (target && target instanceof HTMLElement) {\n            const prev = nav.elements.find((c) => c.hasAttribute('tabindex')) || null;\n            nav.focusElement(target, prev);\n        }\n    }\n};\n/**\n * The PivotGrid Configurator keyboard navigation functionality.\n *\n * Usage:\n *\n * On Initialize\n * const navigation = new ConfiguratorNavigation({ tabindex: 0 });\n *\n * Turn on\n * navigation.start(rootDomElement);\n *\n * On After Update\n * navigation.update();\n *\n * On Destroy / Turn off\n * navigation.stop();\n */\nexport class ConfiguratorNavigation extends Navigation {\n    constructor() {\n        super(...arguments);\n        this.selectors = selectors;\n        this.mouseEvents = mouseEvents;\n        this.keyboardEvents = keyboardEvents;\n    }\n}\n","import \"./kendo.dom.js\";\nimport \"./kendo.html.chip.js\";\nimport \"./kendo.html.chiplist.js\";\nimport \"./kendo.treeview.js\";\nimport \"./kendo.treeview.draganddrop.js\";\nimport \"./kendo.icons.js\";\nimport { ConfiguratorNavigation, fetchDiscover, PIVOT_CONFIGURATOR_ACTION, configuratorReducer } from '@progress/kendo-pivotgrid-common';\n\nexport const __meta__ = {\n    id: \"pivot.configurator\",\n    name: \"PivotConfigurator\",\n    category: \"web\",\n    depends: [ \"dropdownlist\", \"treeview\", \"treeview.draganddrop\", \"pivot.fieldmenu\", \"html.chip\", \"html.chiplist\", \"icons\" ],\n    hidden: true\n};\n\n\n(function($, undefined) {\n    var kendo = window.kendo,\n        ui = kendo.ui,\n        encode = kendo.htmlEncode,\n        Widget = ui.Widget,\n        ns = \".kendoPivotConfigurator\",\n        HOVER_EVENTS = \"mouseenter\" + ns + \" mouseleave\" + ns,\n        SETTINGS_TEMPLATE = ({ title, headerTextId }) => '<div class=\"k-pivotgrid-configurator-header\">' +\n                                            `<div class=\"k-pivotgrid-configurator-header-text\" id=\"${headerTextId}\">${encode(title)}</div>` +\n                                          '</div>',\n        CONTENT_TEMPLATE = ({ formClass, horizontal, ariaId }) => '<div class=\"k-pivotgrid-configurator-content\">' +\n            `<form class=\"${encode(formClass)}\">` +\n                `${horizontal ? '<div class=\"k-form-field-wrapper\">' : ''}` +\n                '<div class=\"k-form-field\">' +\n                    `<label class=\"k-label\" id=\"${ariaId}-configurator-fields\">Fields</label>` +\n                '</div>' +\n                '<div class=\"k-form-field\">' +\n                  '<div class=\"k-fields-list-wrapper\"></div>' +\n                '</div>' +\n                `${horizontal ? '</div><div class=\"k-form-field-wrapper\">' : ''}` +\n                '<div class=\"k-form-field\">' +\n                    `<label class=\"k-label\" id=\"${ariaId}-configurator-columns\">Columns</label>` +\n                '</div>' +\n                '<div class=\"k-chip-list k-column-fields\"></div>' +\n                '<div class=\"k-form-field\">' +\n                    `<label class=\"k-label\" id=\"${ariaId}-configurator-rows\">Rows</label>` +\n                '</div>' +\n                '<div class=\"k-chip-list k-row-fields\"></div>' +\n                `${horizontal ? '</div><div class=\"k-form-field-wrapper\">' : ''}` +\n                '<div class=\"k-form-field\">' +\n                    `<label class=\"k-label\" id=\"${ariaId}-configurator-values\">Values</label>` +\n                '</div>' +\n                '<div class=\"k-chip-list k-column-fields\"></div>' +\n                `${horizontal ? '</div>' : ''}` +\n            '</form>' +\n        '</div>',\n        TARGET_ITEM_TEMPLATE = ({ name }) => '<span>' +\n                `<span class=\"k-chip-label\">${encode(name)}</span>` +\n            '</span>',\n        ACTIONS_TEMPLATE = ({ cancelText, applyText }) =>\n                '<div class=\"k-pivotgrid-configurator-actions k-actions k-hstack k-justify-content-end\">' +\n                  '<button class=\"k-button\" aria-disabled=\"false\">' +\n                    `<span class=\"k-button-text\">${encode(cancelText)}</span>` +\n                  '</button>' +\n                  '<button class=\"k-button k-button-primary\" aria-disabled=\"false\">' +\n                    `<span class=\"k-button-text\">${encode(applyText)}</span>` +\n                  '</button>' +\n                '</div>',\n        SETTING_CONTAINER_TEMPLATE = ({ name }) => `<div class=\"k-pivotgrid-target k-pivotgrid-configurator-section\"><strong>${encode(name)}</strong><div class=\"k-pivotgrid-target-wrap\"></div>`;\n\n    function addKPI(data) {\n        var found;\n        var idx = 0;\n        var length = data.length;\n\n        for (; idx < length; idx++) {\n            if (data[idx].type == 2) {\n                found = true;\n                break;\n            }\n        }\n\n        if (found) {\n            data.splice(idx + 1, 0, {\n                caption: \"KPIs\",\n                defaultHierarchy: \"[KPIs]\",\n                name: \"KPIs\",\n                uniqueName: \"[KPIs]\"\n            });\n        }\n    }\n\n    function kpiNode(node) {\n        return {\n            name: node.uniqueName,\n            type: node.type\n        };\n    }\n\n    function normalizeKPIs(data) {\n        for (var idx = 0, length = data.length; idx < length; idx++) {\n            data[idx].uniqueName = data[idx].name;\n            data[idx].type = \"kpi\";\n        }\n\n        return data;\n    }\n\n    function settingTargetFromNode(node) {\n        var target = $(node).closest(\".k-pivot-setting\");\n\n        if (target.length) {\n            return target.data(\"kendoPivotSettingTarget\");\n        }\n        return null;\n    }\n\n    function getIcons(sortIcon, options) {\n        var sortable = options.sortable;\n        var result = '';\n\n        if (sortable) {\n            result += sortIcon ? `<span class=\"k-chip-action k-chip-more-action\">${kendo.ui.icon(sortIcon + \"-sm\")}</span>` : '';\n        }\n\n        if (options.filterable || sortable) {\n            result += `<span class=\"k-setting-fieldmenu k-chip-action\">${kendo.ui.icon(\"more-vertical\")}</span>`;\n        }\n\n        result += `<span class=\"k-setting-delete k-chip-action\">${kendo.ui.icon(\"x\")}</span>`;\n\n        return result;\n    }\n\n    var PivotConfiguratorV2 = Widget.extend({\n        init: function(element, options) {\n            Widget.fn.init.call(this, element, options);\n\n            this._ariaId = this.element.attr(\"id\") || kendo.guid();\n            this.element.addClass(\"k-pivotgrid-configurator\");\n            this.element.attr({\n                \"role\": \"dialog\",\n                \"aria-hidden\": true,\n                \"aria-labelledby\": `${this._ariaId}-configurator-header`\n            });\n\n            this._dataSource();\n\n            if (this.options.navigatable) {\n                this._initPivotGridConfiguratorNavigation();\n            }\n\n            this._layout();\n\n            this.refresh();\n\n            if (options.height) {\n                this.element.height(options.height);\n            }\n\n            kendo.notify(this);\n        },\n\n        events: [],\n\n        options: {\n            name: \"PivotConfiguratorV2\",\n            orientation: \"vertical\",\n            filterable: false,\n            sortable: false,\n            messages: {\n                title: \"Settings\",\n                cancelButtonText: \"Cancel\",\n                applyButtonText: \"Apply\",\n                measures: \"Select some fields to begin setup\",\n                columns: \"Select some fields to begin setup\",\n                rows: \"Select some fields to begin setup\"\n            }\n        },\n\n        setDataSource: function(dataSource) {\n            this.options.dataSource = dataSource;\n\n            this._dataSource();\n\n            if (this.measures) {\n                this.measures.setDataSource(dataSource);\n            }\n\n            if (this.rows) {\n                this.rows.setDataSource(dataSource);\n            }\n\n            if (this.columns) {\n                this.columns.setDataSource(dataSource);\n            }\n\n            this.refresh();\n        },\n\n        _initPivotGridConfiguratorNavigation: function() {\n            var that = this;\n            that.configuratorNavigation = new ConfiguratorNavigation({ tabIndex: 0 });\n            that.configuratorNavigation.start(that.element[0]);\n\n            const firstCell = that.configuratorNavigation.first;\n\n            if (firstCell) {\n                firstCell.setAttribute('tabindex', '0');\n            }\n        },\n\n        _dataSource: function() {\n            var that = this;\n\n            if (that.dataSource && that._refreshHandler) {\n                that.dataSource.unbind(\"change\", that._refreshHandler)\n                               .unbind(\"error\", that._errorHandler)\n                               .unbind(\"progress\", that._progressHandler);\n            } else {\n                that._errorHandler = that._error.bind(that);\n                that._refreshHandler = that.refresh.bind(that);\n                that._progressHandler = that._requestStart.bind(that);\n            }\n\n            that.dataSource = kendo.data.PivotDataSourceV2.create(that.options.dataSource);\n            that.dataSource.bind(\"change\", that._refreshHandler)\n                           .bind(\"error\", that._errorHandler)\n                           .bind(\"progress\", that._progressHandler);\n        },\n\n        _layout: function() {\n\n            var that = this;\n            var options = that.options;\n            var messages = options.messages;\n            var horizontal = options.orientation == \"horizontal\";\n\n            var panel = $(\"<div class='k-pivotgrid-configurator-panel k-pivotgrid-configurator-push'></div>\");\n\n            panel.addClass(horizontal ? \"k-pivotgrid-configurator-horizontal\" : \"k-pivotgrid-configurator-vertical\");\n\n            that.element.append(panel);\n\n            that.panel = panel;\n\n            $(SETTINGS_TEMPLATE({ title: this.options.messages.title, headerTextId: `${that._ariaId}-configurator-header` })).appendTo(that.panel);\n\n            $(CONTENT_TEMPLATE({ formClass: horizontal ? \"k-form k-form-horizontal\" : \"k-form\", filterable: options.filterable, horizontal: horizontal, ariaId: that._ariaId }))\n                .appendTo(that.panel).find(\".k-chip-list\")\n                .each(function(index, elm) {\n                    kendo.html.renderChipList(elm, $.extend({}, options));\n                    $(elm).attr({\n                        \"role\": \"listbox\",\n                        \"aria-orientation\": \"horizontal\",\n                    });\n                });\n\n            that._fields();\n            $(ACTIONS_TEMPLATE({ cancelText: messages.cancelButtonText, applyText: messages.applyButtonText })).appendTo(that.panel);\n            that._targets();\n\n            that.element.on(\"click\" + ns, \".k-pivotgrid-configurator-actions > button\", that._actions.bind(that));\n        },\n\n        _actions: function(e) {\n            e.preventDefault();\n\n            var target = $(e.currentTarget).closest(\":not(path,svg)\");\n            if (target.index()) {\n                this.columns._applyState();\n                this.rows._applyState();\n                this.measures._applyState();\n                this.dataSource.read();\n            } else {\n                this.columns._cancelChanges();\n                this.rows._cancelChanges();\n                this.measures._cancelChanges();\n                this.treeView.dataSource.read();\n            }\n        },\n\n        _targets: function() {\n            var that = this;\n            var columns = that.panel.find(\".k-column-fields\").first();\n            var rows = that.panel.find(\".k-row-fields\");\n            var measures = that.panel.find(\".k-chip-list\").last();\n            var options = this.options;\n\n            var targetItemTemplate = ({ name, menuenabled }) => {\n                    var chip = kendo.html.renderChip(TARGET_ITEM_TEMPLATE({ name, menuenabled }), $.extend({}, options, {\n                        removable: true,\n                        removeIcon: \"x-circle\",\n                        actions: menuenabled ? [\n                            { icon: \"more-vertical\" }\n                        ] : null\n                    }));\n\n                    return chip;\n                };\n\n            this.columns = this._createTarget(columns, {\n                navigatable: options.navigatable,\n                filterable: options.filterable,\n                sortable: options.sortable,\n                template: targetItemTemplate,\n                connectWith: rows,\n                messages: {\n                    empty: options.messages.columns,\n                    fieldMenu: this.options.messages.fieldMenu\n                },\n                configuratorNavigation: that.configuratorNavigation\n            });\n            this.columns.element.attr(\"aria-labelledby\", `${this._ariaId}-configurator-header ${this._ariaId}-configurator-columns`);\n\n            this.rows = this._createTarget(rows, {\n                navigatable: options.navigatable,\n                filterable: options.filterable,\n                sortable: options.sortable,\n                template: targetItemTemplate,\n                setting: \"rows\",\n                connectWith: columns,\n                messages: {\n                    empty: this.options.messages.rows,\n                    fieldMenu: this.options.messages.fieldMenu\n                },\n                configuratorNavigation: that.configuratorNavigation\n            });\n            this.rows.element.attr(\"aria-labelledby\", `${this._ariaId}-configurator-header ${this._ariaId}-configurator-rows`);\n\n            this.measures = this._createTarget(measures, {\n                navigatable: options.navigatable,\n                filterable: false,\n                sortable: false,\n                setting: \"measures\",\n                template: targetItemTemplate,\n                messages: {\n                    empty: options.messages.measures,\n                    fieldMenu: this.options.messages.fieldMenu\n                },\n                configuratorNavigation: that.configuratorNavigation\n            });\n\n            this.measures.element.attr(\"aria-labelledby\", `${this._ariaId}-configurator-header ${this._ariaId}-configurator-values`);\n\n            [this.columns, this.rows, this.measures].forEach(x=> x.element.find(\".k-chip\").attr(\"role\", \"option\"));\n        },\n\n        _createTarget: function(element, options) {\n            var that = this;\n            return new kendo.ui.PivotSettingTargetV2(element, $.extend({\n                dataSource: this.dataSource,\n                hint: function(element) {\n                    return element.clone();\n                },\n                remove: function(e) {\n                    var item = that.treeView.wrapper\n                        .find(\"[data-name='\" + e.name + \"']\")\n                        .closest(\"li\");\n                    var id = item.attr(kendo.attr(\"uid\"));\n                    var dataItem = that.treeView.dataSource.getByUid(id);\n\n                    if (dataItem) {\n                        dataItem.checked = false;\n                        item.find(\"input\").attr(\"checked\", false);\n                    }\n                },\n                template: options.template\n            }, options));\n        },\n\n        _fields: function() {\n            var that = this;\n            var container = that.element.find(\".k-fields-list-wrapper\");\n\n            this.treeView = $(`<div aria-labelledby=\"${this._ariaId}-configurator-header ${this._ariaId}-configurator-fields\" />`).appendTo(container)\n                .kendoTreeView({\n                    checkboxes: {\n                        checkChildren: true,\n                        template: ({ item }) => {\n                            var result = '';\n\n                            if ((item.hasChildren || item.aggregator || item.local) && item.uniqueName !== \"[KPIs]\" && item.uniqueName !== \"[Measures]\" && item.uniqueName !== \"Measures\") {\n                                result += `<input type=\"checkbox\" data-name=\"${encode(item.uniqueName)}\" ${item.checked ? \"checked\" : \"\"} class=\"k-checkbox\" id=\"${encode(item.uid)}\" tabindex=\"-1\">`;\n                            }\n\n                            return result;\n                        }\n                    },\n                    dataTextField: \"caption\",\n                    autoBind: false,\n                    check: function(e) {\n                      var dataItem = e.sender.dataItem(e.node);\n                      var action = {\n                        type: PIVOT_CONFIGURATOR_ACTION.toggleSelection,\n                        payload: dataItem\n                      };\n                      var state = {\n                        columnAxes: that.columns._state(),\n                        rowAxes: that.rows._state(),\n                        measureAxes: that.measures._state()\n                      };\n                      var result = configuratorReducer(state, action);\n\n                      if (that.dataSource.cubeSchema && result.measureAxes && result.measureAxes.length &&\n                        result.measureAxes.length > state.measureAxes.length) {\n                          that.dataSource.cubeSchema.restoreMeasure(result.measureAxes, dataItem);\n                      }\n\n                      if (dataItem.defaultHierarchy && dataItem.items && dataItem.items.length) {\n                          that._checkMembers([{ name: dataItem.defaultHierarchy }], dataItem.items);\n                          dataItem.items.trigger(\"change\");\n                      }\n\n                      if (result.columnAxes) {\n                          that.columns._state(result.columnAxes);\n                          that.columns._redraw();\n                      }\n                      if (result.rowAxes) {\n                          that.rows._state(result.rowAxes);\n                          that.rows._redraw();\n                      }\n                      if (result.measureAxes) {\n                          that.measures._state(result.measureAxes);\n                          that.measures._redraw();\n                      }\n                    },\n                    dataSource: this._treeViewDataSource()\n                 })\n                .data(\"kendoTreeView\");\n\n            this.treeView.wrapper.off(\"click\", this.treeView._clickHandler);\n        },\n\n        _treeViewDataSource: function() {\n            var that = this;\n\n            return kendo.data.HierarchicalDataSource.create({\n                schema: {\n                    model: {\n                        id: \"uniqueName\",\n                        hasChildren: function(item) {\n                            if (that.dataSource.cubeSchema && item.uniqueName !== \"Measures\") {\n                                item.local = true;\n                                return false;\n                            }\n                            return !(\"hierarchyUniqueName\" in item) && !(\"aggregator\" in item);\n                        }\n                    }\n                },\n                transport: {\n                    read: function(options) {\n                        var node;\n                        var transport = that.dataSource.transport;\n                        var catalog = transport.catalog();\n                        var cube = transport.cube();\n                        var fetchOptions = {\n                            url: transport.options.read\n                        };\n                        var columns = that.columns._state();\n                        var rows = that.rows._state();\n                        var measures = that.measures._state();\n                        var members = columns.concat(rows).concat(measures);\n                        var fields;\n                        var dsMeasures;\n                        var fetchOpts;\n\n                        if ($.isEmptyObject(options.data)) {\n                            if (that.dataSource.cubeSchema) {\n                                fields = that.dataSource.cubeSchema.dimensions();\n                                that._checkMembers(members, fields);\n                                options.success(fields);\n                            } else {\n                                fetchOpts = {\n                                    connection: {\n                                        catalog: catalog,\n                                        cube: cube\n                                    },\n                                    restrictions: {\n                                        catalogName: catalog,\n                                        cubeName: cube\n                                    },\n                                    command: 'schemaDimensions'\n                                };\n\n                                fetchDiscover(fetchOptions, fetchOpts)\n                                    .then(function(newFields) {\n                                        that._checkMembers(members, newFields);\n                                        addKPI(newFields);\n                                        options.success(newFields);\n                                     });\n                            }\n                        } else {\n                            //Hack to get the actual node as the HierarchicalDataSource does not support passing it\n                            node = that.treeView.dataSource.get(options.data.uniqueName);\n\n                            if (that.dataSource.cubeSchema) {\n                                dsMeasures = that.dataSource.measures();\n                                that._checkMembers(members, dsMeasures);\n                                options.success(dsMeasures);\n                            } else {\n                                if (node.uniqueName === \"[KPIs]\") {\n                                    fetchDiscover(fetchOptions, that._getKPIOptions(catalog, cube))\n                                    .then(function(newFields) {\n                                        options.success(normalizeKPIs(newFields));\n                                    });\n                                } else if (node.type == \"kpi\") {\n                                    options.success(buildKPImeasures(node));\n                                } else {\n                                    fetchDiscover(fetchOptions ,that._loadFieldsCommand(node, catalog, cube))\n                                    .then(function(newFields) {\n                                        that._checkMembers(members, newFields);\n                                        options.success(newFields);\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n        },\n\n        _checkMembers: function(members, newData) {\n            var hash = {};\n            var index = 0;\n\n            for (index = 0; index < members.length; index++) {\n                hash[members[index].name] = true;\n            }\n\n            for (index = 0; index < newData.length; index++) {\n                if (hash[newData[index].uniqueName]) {\n                    newData[index].checked = true;\n                }\n            }\n        },\n\n        _getKPIOptions: function(catalog, cube) {\n            return {\n                connection: {\n                    catalog: catalog,\n                    cube: cube\n                },\n                restrictions: {\n                    catalogName: catalog,\n                    cubeName: cube\n                },\n                command: 'schemaKPIs'\n            };\n        },\n\n        _loadFieldsCommand: function(field, catalog, cube) {\n            var command;\n            var dimensionUniqueName;\n            var hierarchyUniqueName;\n\n            if (field.type === 2) {\n                command = 'schemaMeasures';\n            } else if (field.dimensionUniqueName) {\n                command = 'schemaLevels';\n                hierarchyUniqueName = field.uniqueName;\n            } else {\n                command = 'schemaHierarchies';\n                dimensionUniqueName = field.uniqueName;\n            }\n\n            var options = {\n                connection: {\n                    catalog: catalog,\n                    cube: cube\n                },\n                restrictions: {\n                    catalogName: catalog,\n                    cubeName: cube,\n                    hierarchyUniqueName: hierarchyUniqueName,\n                    dimensionUniqueName: dimensionUniqueName\n                },\n                command: command\n            };\n\n            return options;\n        },\n\n        _progress: function(toggle) {\n            kendo.ui.progress(this.element, toggle);\n        },\n\n        _error: function() {\n            this._progress(false);\n        },\n\n        _requestStart: function() {\n            this._progress(true);\n        },\n\n        destroy: function() {\n            Widget.fn.destroy.call(this);\n\n            this.dataSource.unbind(\"change\", this._refreshHandler);\n\n            this.element.off(ns);\n\n            this.rows.destroy();\n            this.columns.destroy();\n            this.measures.destroy();\n            this.treeView.destroy();\n\n            this.element = null;\n            this._refreshHandler = null;\n        },\n\n        refresh: function() {\n            if (this.treeView) {\n                this.treeView.dataSource.fetch();\n            }\n\n            this._progress(false);\n        }\n\n    });\n\n    ui.plugin(PivotConfiguratorV2);\n\n    var PivotConfigurator = Widget.extend({\n        init: function(element, options) {\n            Widget.fn.init.call(this, element, options);\n\n            this.element.addClass(\"k-pivotgrid-configurator-panel kendo-jquery\");\n\n            if (this.options.height) {\n                this.element.outerHeight(this.options.height);\n            }\n\n            this._dataSource();\n\n            this._layout();\n\n            this.refresh();\n\n            kendo.notify(this);\n        },\n\n        events: [],\n\n        options: {\n            name: \"PivotConfigurator\",\n            filterable: false,\n            sortable: false,\n            messages: {\n                measures: \"Drop Data Fields Here\",\n                columns: \"Drop Column Fields Here\",\n                rows: \"Drop Rows Fields Here\",\n                measuresLabel: \"Measures\",\n                columnsLabel: \"Columns\",\n                rowsLabel: \"Rows\",\n                fieldsLabel: \"Fields\"\n            }\n        },\n\n        _dataSource: function() {\n            var that = this;\n\n            if (that.dataSource && that._refreshHandler) {\n                that.dataSource.unbind(\"change\", that._refreshHandler)\n                               .unbind(\"error\", that._errorHandler)\n                               .unbind(\"progress\", that._progressHandler);\n            } else {\n                that._errorHandler = that._error.bind(that);\n                that._refreshHandler = that.refresh.bind(that);\n                that._progressHandler = that._requestStart.bind(that);\n            }\n\n            that.dataSource = kendo.data.PivotDataSource.create(that.options.dataSource);\n            that.dataSource.bind(\"change\", that._refreshHandler)\n                           .bind(\"error\", that._errorHandler)\n                           .bind(\"progress\", that._progressHandler);\n        },\n\n        setDataSource: function(dataSource) {\n            this.options.dataSource = dataSource;\n\n            this._dataSource();\n\n            if (this.measures) {\n                this.measures.setDataSource(dataSource);\n            }\n\n            if (this.rows) {\n                this.rows.setDataSource(dataSource);\n            }\n\n            if (this.columns) {\n                this.columns.setDataSource(dataSource);\n            }\n\n            this.refresh();\n        },\n\n        _treeViewDataSource: function() {\n            var that = this;\n\n            return kendo.data.HierarchicalDataSource.create({\n                schema: {\n                    model: {\n                        id: \"uniqueName\",\n                        hasChildren: function(item) {\n                            return !(\"hierarchyUniqueName\" in item) && !(\"aggregator\" in item);\n                        }\n                    }\n                },\n                transport: {\n                    read: function(options) {\n                        var promise;\n                        var node;\n                        var kpi;\n\n                        if ($.isEmptyObject(options.data)) {\n                            promise = that.dataSource.schemaDimensions();\n\n                            promise.done(function(data) {\n                                        if (!that.dataSource.cubeBuilder) {\n                                            addKPI(data);\n                                        }\n                                        options.success(data);\n                                    })\n                                    .fail(options.error);\n                        } else {\n                            //Hack to get the actual node as the HierarchicalDataSource does not support passing it\n                            node = that.treeView.dataSource.get(options.data.uniqueName);\n\n                            if (node.uniqueName === \"[KPIs]\") {\n                                kpi = true;\n                                promise = that.dataSource.schemaKPIs();\n                                promise.done(function(data) {\n                                            options.success(normalizeKPIs(data));\n                                       })\n                                       .fail(options.error);\n                            } else if (node.type == \"kpi\") {\n                                kpi = true;\n                                options.success(buildKPImeasures(node));\n                            }\n\n                            if (!kpi) {\n                                if (node.type == 2) { //measure\n                                    promise = that.dataSource.schemaMeasures();\n                                } else if (node.dimensionUniqueName) { // hierarchy\n                                    promise = that.dataSource.schemaLevels(options.data.uniqueName);\n                                } else { // dimension\n                                    promise = that.dataSource.schemaHierarchies(options.data.uniqueName);\n                                }\n\n                                promise.done(options.success)\n                                        .fail(options.error);\n                            }\n                        }\n                    }\n                }\n            });\n        },\n\n        _progress: function(toggle) {\n            kendo.ui.progress(this.element, toggle);\n        },\n\n        _error: function() {\n            this._progress(false);\n        },\n\n        _requestStart: function() {\n            this._progress(true);\n        },\n\n        _layout: function() {\n            $('<div class=\"k-pivotgrid-configurator\"><div class=\"k-pivotgrid-configurator-content\"></div></div>').appendTo(this.element);\n            this.form = this.element.find('.k-pivotgrid-configurator-content');\n\n            this._fields();\n            this._targets();\n        },\n\n        _fields: function() {\n            var container = $('<div class=\"k-pivotgrid-fields k-pivotgrid-configurator-section\"><strong>' + encode(this.options.messages.fieldsLabel) + '</strong><div class=\"k-fields-list-wrapper\"></div></div>').appendTo(this.form);\n\n            var template = ({ item }) => {\n                var result = '';\n\n                if (item.type == 2 || item.uniqueName == \"[KPIs]\") {\n                    result += kendo.ui.icon(item.type == 2 ? \"sum\" : \"caret-alt-expand\"/* \"kpi\" */);\n                } else if (item.type && item.type !== \"kpi\") {\n                    result += kendo.ui.icon(\"arrows-axes\");\n                }\n\n                result += `${encode(item.caption || item.name)}`;\n\n                return result;\n            };\n\n            this.treeView = $(\"<div/>\").appendTo(container.find('.k-fields-list-wrapper'))\n                .kendoTreeView({\n                    template: template,\n                    dataTextField: \"caption\",\n                    dragAndDrop: true,\n                    autoBind: false,\n                    dataSource: this._treeViewDataSource(),\n                    dragstart: function(e) {\n                        var dataItem = this.dataItem(e.sourceNode);\n\n                        if ((!dataItem.hasChildren && !dataItem.aggregator && !dataItem.measure) || (dataItem.type == 2) || dataItem.uniqueName === \"[KPIs]\") {\n                            e.preventDefault();\n                        }\n                    },\n                    drag: function(e) {\n                        var status = \"cancel\";\n                        var setting = settingTargetFromNode(e.dropTarget);\n\n                        if (setting && setting.validate(this.dataItem(e.sourceNode))) {\n                            status = \"plus\";\n                        }\n\n                        e.setStatusClass(status);\n                    },\n                    drop: function(e) {\n                        e.preventDefault();\n\n                        var setting = settingTargetFromNode(e.dropTarget);\n                        var node = this.dataItem(e.sourceNode);\n                        var idx, length, measures;\n                        var name;\n\n                        if (setting && setting.validate(node)) {\n                            name = node.defaultHierarchy || node.uniqueName;\n\n                            if (node.type === \"kpi\") {\n                                measures = buildKPImeasures(node);\n                                length = measures.length;\n                                name = [];\n\n                                for (idx = 0; idx < length; idx++) {\n                                    name.push(kpiNode(measures[idx]));\n                                }\n                            } else if (node.kpi) {\n                                name = [kpiNode(node)];\n                            }\n\n                            setting.add(name);\n                        }\n                    }\n                 })\n                .data(\"kendoTreeView\");\n        },\n\n        _createTarget: function(element, options) {\n            var template;\n\n            template = ({ name, sortIcon }) => ''\n                + `<div class=\"k-chip\" data-${kendo.ns}name=\"${name}\">`\n                    + '<span class=\"k-chip-content\">'\n                        + `<span class=\"k-chip-label\">${name}</span>`\n                    + '</span>'\n                    + '<span class=\"k-chip-actions k-field-actions\">'\n                    + getIcons(sortIcon, options)\n                    + '</span>'\n                + '</div>';\n\n            return new kendo.ui.PivotSettingTarget(element, $.extend({\n                dataSource: this.dataSource,\n                template: template,\n                emptyTemplate: (data) => `<span class=\"k-empty\">${data}</span>`\n            }, options));\n        },\n\n        _targets: function() {\n            var container = $('<div class=\"k-pivotgrid-targets\"/>').appendTo(this.form);\n\n            var columnsContainer = $(SETTING_CONTAINER_TEMPLATE({ name: this.options.messages.columnsLabel, icon: \"columns\" })).appendTo(container);\n            var columns = $('<div class=\"k-column-fields k-chip-list\" />').appendTo(columnsContainer.find('.k-pivotgrid-target-wrap'));\n\n            var rowsContainer = $(SETTING_CONTAINER_TEMPLATE({ name: this.options.messages.rowsLabel, icon: \"rows\" })).appendTo(container);\n            var rows = $('<div class=\"k-column-fields k-chip-list\" />').appendTo(rowsContainer.find('.k-pivotgrid-target-wrap'));\n\n            var measuresContainer = $(SETTING_CONTAINER_TEMPLATE({ name: this.options.messages.measuresLabel, icon: \"sum\" })).appendTo(container);\n            var measures = $('<div class=\"k-column-fields k-chip-list\" />').appendTo(measuresContainer.find('.k-pivotgrid-target-wrap'));\n\n            var options = this.options;\n\n            this.columns = this._createTarget(columns, {\n                filterable: options.filterable,\n                sortable: options.sortable,\n                connectWith: rows,\n                messages: {\n                    empty: options.messages.columns,\n                    fieldMenu: options.messages.fieldMenu\n                }\n            });\n\n            this.rows = this._createTarget(rows, {\n                filterable: options.filterable,\n                sortable: options.sortable,\n                setting: \"rows\",\n                connectWith: columns,\n                messages: {\n                    empty: this.options.messages.rows,\n                    fieldMenu: this.options.messages.fieldMenu\n                }\n            });\n\n            this.measures = this._createTarget(measures, {\n                setting: \"measures\",\n                messages: {\n                    empty: options.messages.measures\n                }\n            });\n\n            columns\n                .add(rows)\n                .add(measures)\n                .on(HOVER_EVENTS, \".k-item:not(.k-empty)\", this._toggleHover);\n        },\n\n        _toggleHover: function(e) {\n            $(e.currentTarget).closest(\":not(path,svg)\").toggleClass(\"k-hover\", e.type === \"mouseenter\");\n        },\n\n        _resize: function() {\n            var element = this.element;\n            var height = this.options.height;\n\n            if (!height) {\n                return;\n            }\n\n            element.outerHeight(height);\n        },\n\n        refresh: function() {\n            var dataSource = this.dataSource;\n\n            if (dataSource.cubeBuilder || this._cube !== dataSource.cube() || this._catalog !== dataSource.catalog()) {\n                this.treeView.dataSource.fetch();\n            }\n\n            this._catalog = this.dataSource.catalog();\n            this._cube = this.dataSource.cube();\n\n            this._resize();\n\n            this._progress(false);\n        },\n\n        destroy: function() {\n            Widget.fn.destroy.call(this);\n\n            this.dataSource.unbind(\"change\", this._refreshHandler);\n\n            this.form.find(\".k-pivot-setting\").off(ns);\n\n            this.rows.destroy();\n            this.columns.destroy();\n            this.measures.destroy();\n            this.treeView.destroy();\n\n            this.element = null;\n            this._refreshHandler = null;\n        }\n    });\n\n    function kpiMeasure(name, measure, type) {\n        return {\n            hierarchyUniqueName: name,\n            uniqueName: measure,\n            caption: measure,\n            measure: measure,\n            name: measure,\n            type: type,\n            kpi: true\n        };\n    }\n\n    function buildKPImeasures(node) {\n        var name = node.name;\n        return [\n            kpiMeasure(name, node.value, \"value\"),\n            kpiMeasure(name, node.goal, \"goal\"),\n            kpiMeasure(name, node.status, \"status\"),\n            kpiMeasure(name, node.trend, \"trend\")\n        ];\n    }\n\n    kendo.cssProperties.registerPrefix(\"HTMLChip\", \"k-chip-\");\n\n    kendo.cssProperties.registerValues(\"HTMLChip\", [{\n        prop: \"rounded\",\n        values: kendo.cssProperties.roundedValues.concat([['md', 'md']])\n    }]);\n\n    ui.plugin(PivotConfigurator);\n\n})(window.kendo.jQuery);\nexport default kendo;\n\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42],"mappings":"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"}