{"version":3,"file":"kendo.virtuallist.min.js","names":[],"sources":["../../src/utils/valueMapper.js","../../src/kendo.virtuallist.js"],"sourcesContent":["import \"../kendo.core.js\";\n\nlet $ = kendo.jQuery;\n\nexport function valueMapperOptions(options, value, callback) {\n    return {\n        value: (options.selectable === \"multiple\" || options.checkboxes) ? value : value[0],\n        success: function(response) {\n            callback(response);\n        }\n    };\n}\n","import \"./kendo.data.js\";\nimport { valueMapperOptions } from \"./utils/valueMapper.js\";\n\nexport const __meta__ = {\n    id: \"virtuallist\",\n    name: \"VirtualList\",\n    category: \"framework\",\n    depends: [ \"data\" ],\n    hidden: true\n};\n\n(function($, undefined) {\n    const kendo = window.kendo,\n        ui = kendo.ui,\n        encode = kendo.htmlEncode,\n        Widget = ui.Widget,\n        DataBoundWidget = ui.DataBoundWidget,\n        percentageUnitsRegex = /^\\d+(\\.\\d+)?%$/i,\n        LIST_CONTENT = \"k-list-content\",\n        TABLE_CONTENT = \"k-table-body k-table-scroller\",\n        HEADER = \"k-list-group-sticky-header\",\n        TABLE_HEADER = \"k-table-group-sticky-header\",\n        LIST_ITEM = \"k-list-item\",\n        TABLE_ITEM = \"k-table-row\",\n        HEIGHTCONTAINER = \"k-height-container\",\n        GROUPITEM = \"k-list-item-group-label\",\n        GROUP_HEADER_ITEM = \"k-list-group-item\",\n        LIST_UL = \"k-list-ul\",\n        TABLE = \"k-table\",\n\n        SELECTED = \"k-selected\",\n        FOCUSED = \"k-focus\",\n        HOVER = \"k-hover\",\n        CHANGE = \"change\",\n        CLICK = \"click\",\n        LISTBOUND = \"listBound\",\n        ITEMCHANGE = \"itemChange\",\n        ACTION = \"action\",\n\n        ACTIVATE = \"activate\",\n        DEACTIVATE = \"deactivate\",\n\n        GROUP_ROW_SEL = \".k-table-group-row\",\n\n        VIRTUAL_LIST_NS = \".VirtualList\";\n\n    function lastFrom(array) {\n        return array[array.length - 1];\n    }\n\n    function toArray(value) {\n        return value instanceof Array ? value : [value];\n    }\n\n    function isPrimitive(dataItem) {\n        return typeof dataItem === \"string\" || typeof dataItem === \"number\" || typeof dataItem === \"boolean\";\n    }\n\n    function getItemCount(screenHeight, listScreens, itemHeight) {\n        return Math.ceil(screenHeight * listScreens / itemHeight);\n    }\n\n    function appendChild(parent, className, tagName) {\n        const element = document.createElement(tagName || \"div\");\n        if (className) {\n            element.className = className;\n        }\n        parent.appendChild(element);\n\n        return element;\n    }\n\n    function getDefaultItemHeight(listSize) {\n        const mockList = $('<div class=\"k-list ' + listSize + ' k-virtual-list\">' +\n                '<div class=\"k-list-content\">' +\n                    '<ul class=\"k-list-ul\">' +\n                        '<li class=\"k-list-item\">' +\n                            '<span class=\"k-list-item-text\">test</span>' +\n                        '</li>' +\n                    '</ul>' +\n                '</div>' +\n            '</div>');\n\n        mockList.css({\n            position: \"absolute\",\n            left: \"-200000px\",\n            visibility: \"hidden\"\n        });\n        mockList.appendTo(document.body);\n\n        const itemHeight = parseFloat(kendo.getComputedStyles(mockList.find(\".k-list-item\")[0], [\"height\"]).height);\n\n        mockList.remove();\n\n        return itemHeight;\n    }\n\n    /**\n     * Gets the CSS gap value from an existing UL element in the DOM,\n     * or creates a temporary one to measure if no UL exists.\n     * @param {jQuery|HTMLElement} containerElement - The container element in the DOM (for creating temp UL)\n     * @param {jQuery} existingUl - An existing UL element in the DOM (optional)\n     * @returns {number} - The gap value in pixels (0 if not found)\n     */\n    function getCssGap(containerElement, existingUl) {\n        // If we have an existing UL, measure directly from it\n        if (existingUl && existingUl.length) {\n            let computedStyle = window.getComputedStyle(existingUl[0]);\n            let gap = computedStyle.gap || computedStyle.rowGap || \"0\";\n            return parseFloat(gap) || 0;\n        }\n\n        // Create a temporary UL in the container to measure the gap\n        const container = containerElement instanceof $ ? containerElement[0] : containerElement;\n        if (!container || !container.parentNode) {\n            return 0;\n        }\n\n        const tempUl = document.createElement(\"ul\");\n        tempUl.className = LIST_UL;\n        tempUl.style.cssText = \"position:absolute;visibility:hidden;left:-9999px;\";\n        container.appendChild(tempUl);\n\n        const computedStyle = window.getComputedStyle(tempUl);\n        const gap = computedStyle.gap || computedStyle.rowGap || \"0\";\n        const gapValue = parseFloat(gap) || 0;\n\n        container.removeChild(tempUl);\n\n        return gapValue;\n    }\n\n    function bufferSizes(screenHeight, listScreens, opposite) { //in pixels\n        return {\n            down: screenHeight * opposite,\n            up: screenHeight * (listScreens - 1 - opposite)\n        };\n    }\n\n    function listValidator(options, screenHeight) {\n        const downThreshold = (options.listScreens - 1 - options.threshold) * screenHeight;\n        const upThreshold = options.threshold * screenHeight;\n\n        return function(list, scrollTop, lastScrollTop) {\n            if (scrollTop > lastScrollTop) {\n                return scrollTop - list.top < downThreshold;\n            } else {\n                return list.top === 0 || scrollTop - list.top > upThreshold;\n            }\n        };\n    }\n\n    function scrollCallback(element, callback) {\n        return function(force) {\n            return callback(element.scrollTop, force);\n        };\n    }\n\n    function syncList(reorder) {\n        return function(list, force) {\n            reorder(list.items, list.index, force);\n            return list;\n        };\n    }\n\n    function position(element, y) {\n        element.style.webkitTransform = 'translateY(' + y + \"px)\";\n        element.style.transform = 'translateY(' + y + \"px)\";\n    }\n\n    // ============ Grouped Virtual List Helpers ============\n\n    /**\n     * Calculates the absolute position (in pixels) of a flat index in a grouped list.\n     * Takes into account group headers that appear before each group and CSS gap.\n     * @param {number} flatIndex - The flat index of an item (0-based, counting only data items)\n     * @param {number} itemHeight - Height of each item in pixels\n     * @param {Array} groupRanges - Array of group range objects with startIndex and itemCount\n     * @param {number} cssGap - CSS gap between items in pixels (default 0)\n     * @returns {number} - The absolute pixel position\n     */\n    function getGroupedItemPosition(flatIndex, itemHeight, groupRanges, cssGap) {\n        let position = 0;\n        cssGap = cssGap || 0;\n        const effectiveItemHeight = itemHeight + cssGap;\n\n        for (let i = 0; i < groupRanges.length; i++) {\n            const group = groupRanges[i];\n            const { startIndex, itemCount } = group;\n\n            if (flatIndex < startIndex + itemCount) {\n                // Item is in this group - add header height (except first group)\n                if (i > 0) {\n                    position += effectiveItemHeight;\n                }\n                // Add position within group (including gap for each item)\n                position += (flatIndex - startIndex) * effectiveItemHeight;\n                break;\n            } else {\n                // Item is in a later group - add this group's total height\n                if (i > 0) {\n                    position += effectiveItemHeight; // group header\n                }\n                position += itemCount * effectiveItemHeight;\n            }\n        }\n\n        return position;\n    }\n\n    /**\n     * Calculates the total height of the grouped list including all group headers and CSS gaps.\n     * First group uses the sticky header (not inline), so we subtract one header height.\n     * @param {number} totalItems - Total number of data items\n     * @param {number} itemHeight - Height of each item\n     * @param {number} groupCount - Number of groups\n     * @param {number} cssGap - CSS gap between items in pixels (default 0)\n     * @returns {number} - Total height in pixels\n     */\n    function getGroupedTotalHeight(totalItems, itemHeight, groupCount, cssGap) {\n        cssGap = cssGap || 0;\n        // Each group is a separate UL with flex layout and gap between children\n        // First group uses sticky header, subsequent groups have inline headers\n        // Total elements = totalItems + (groupCount - 1) inline headers\n        const inlineHeaders = Math.max(0, groupCount - 1);\n        const totalElements = totalItems + inlineHeaders;\n\n        // Within each group, there are (elements - 1) gaps between children\n        // Total gaps across all groups = totalElements - groupCount\n        // (each group has one fewer gap than its element count)\n        const totalGaps = Math.max(0, totalElements - groupCount);\n\n        return (totalElements * itemHeight) + (totalGaps * cssGap);\n    }\n\n    /**\n     * Builds the group ranges array from the dataSource's group info.\n     * For paged/server-side grouping, this builds ranges relative to the current range.\n     * @param {Object} dataSource - The Kendo DataSource\n     * @param {number} rangeStart - The start index of the current data range (for offset calculation)\n     * @param {number} firstGroupIndex - The global index of the first group in this view (0-based, used as fallback)\n     * @param {Map} groupValueMap - Optional map of groupValue -> globalGroupIndex for consistent indexing\n     * @returns {Array} - Array of { value, startIndex, itemCount, globalGroupIndex }\n     */\n    function buildGroupRanges(dataSource, rangeStart, firstGroupIndex, groupValueMap) {\n        const groups = dataSource.group() || [];\n        if (!groups.length) {\n            return [];\n        }\n\n        const view = dataSource.view() || [];\n        if (!view.length) {\n            return [];\n        }\n\n        const ranges = [];\n        // Start index is relative to the current range\n        let currentIndex = rangeStart || 0;\n\n        // For new groups, find the next available index after all existing map entries\n        // This ensures consistent numbering regardless of which page we're on\n        let nextNewGroupIndex = 0;\n        if (groupValueMap && groupValueMap.size > 0) {\n            for (const idx of groupValueMap.values()) {\n                if (idx >= nextNewGroupIndex) {\n                    nextNewGroupIndex = idx + 1;\n                }\n            }\n        }\n\n        for (const group of view) {\n            // Skip groups without items array\n            const groupItems = group.items || [];\n            if (!groupItems.length) {\n                continue;\n            }\n\n            let groupIndex;\n\n            // Use the group value map if provided to get consistent indices\n            if (groupValueMap) {\n                if (groupValueMap.has(group.value)) {\n                    groupIndex = groupValueMap.get(group.value);\n                } else {\n                    // New group value - assign the next available index\n                    groupIndex = nextNewGroupIndex++;\n                    groupValueMap.set(group.value, groupIndex);\n                }\n            } else {\n                // No map - use sequential numbering from firstGroupIndex\n                groupIndex = (firstGroupIndex || 0) + ranges.length;\n            }\n\n            ranges.push({\n                value: group.value,\n                startIndex: currentIndex,\n                itemCount: groupItems.length,\n                globalGroupIndex: groupIndex\n            });\n            currentIndex += groupItems.length;\n        }\n\n        return ranges;\n    }\n\n    // ============ End Grouped Virtual List Helpers ============\n\n    function map2(callback, templates) {\n        return function(arr1, arr2) {\n            for (let i = 0, len = arr1.length; i < len; i++) {\n                callback(arr1[i], arr2[i], templates);\n                if (arr2[i].item) {\n                    this.trigger(ITEMCHANGE, { item: $(arr1[i]), data: arr2[i].item, ns: kendo.ui });\n                }\n            }\n        };\n    }\n\n    function reshift(items, diff) {\n        let range;\n\n        if (diff > 0) { // down\n            range = items.splice(0, diff);\n            items.push(...range);\n        } else { // up\n            range = items.splice(diff, -diff);\n            items.unshift(...range);\n        }\n\n        return range;\n    }\n\n    function render(element, data, templates) {\n        const that = this;\n        const options = that.options;\n        const itemTemplate = data.item ? templates.template : templates.placeholderTemplate;\n        const hasColumns = options.columns?.length;\n        const altRow = data.index % 2 === 1 ? \"k-table-alt-row\" : \"\";\n\n        // Rich item options\n        const iconField = options.iconField;\n        const descriptionField = options.descriptionField;\n        const actionField = options.actionField;\n        const dataItem = data.item;\n        const hasIcon = iconField && dataItem && dataItem[iconField];\n        const hasDescription = descriptionField && dataItem && dataItem[descriptionField];\n        const hasAction = actionField && dataItem && dataItem[actionField];\n\n        element = $(element);\n\n        if (data.index === 0 && this.header && data.group) {\n            this.header.html(templates.fixedGroupTemplate(data.group));\n        }\n\n        element\n            .attr(\"data-uid\", dataItem ? dataItem.uid : \"\")\n            .attr(\"data-offset-index\", data.index);\n\n        if (hasAction) {\n            element.attr(\"data-action\", dataItem[actionField]);\n            element.addClass(\"k-list-item-action\");\n        } else {\n            element.removeAttr(\"data-action\");\n            element.removeClass(\"k-list-item-action\");\n        }\n\n        if (hasColumns && dataItem) {\n            if (altRow.length > 0) {\n                element.addClass(altRow);\n            } else {\n                element.removeClass(\"k-table-alt-row\");\n            }\n\n            const renderedColumns = $(renderColumns(options, dataItem, templates));\n            kendo.applyStylesFromKendoAttributes(renderedColumns, [\"width\", \"max-width\"]);\n            element.empty().append(renderedColumns);\n        } else {\n            element.find(\".\" + GROUPITEM).remove();\n\n            const textContainer = element.find(\".k-list-item-text\");\n            textContainer.html(itemTemplate(dataItem || {}));\n\n            let iconWrapper = element.find(\".k-list-item-icon-wrapper\");\n            if (hasIcon) {\n                const iconHtml = kendo.ui.icon({ icon: dataItem[iconField], iconClass: \"k-list-item-icon\", attr: { \"aria-hidden\": \"true\" } });\n                if (iconWrapper.length === 0) {\n                    textContainer.before(`<span class=\"k-list-item-icon-wrapper\" role=\"presentation\">${iconHtml}</span>`);\n                } else {\n                    iconWrapper.attr(\"role\", \"presentation\").html(iconHtml);\n                }\n            } else {\n                iconWrapper.remove();\n            }\n\n            let descElement = element.find(\".k-list-item-description\");\n            if (hasDescription) {\n                if (descElement.length === 0) {\n                    textContainer.after(`<span class=\"k-list-item-description\">${encode(dataItem[descriptionField])}</span>`);\n                } else {\n                    descElement.html(encode(dataItem[descriptionField]));\n                }\n            } else {\n                descElement.remove();\n            }\n        }\n\n        element.toggleClass(FOCUSED, data.current);\n        element.toggleClass(SELECTED, data.selected);\n        element.toggleClass(\"k-first\", data.newGroup);\n        element.toggleClass(\"k-last\", data.isLastGroupedItem);\n        element.toggleClass(\"k-loading-item\", !dataItem);\n\n        if (data.index !== 0 && data.newGroup) {\n            if (hasColumns) {\n                $(`<span class=\"k-table-td k-table-group-td\"><span>${templates.groupTemplate(data.group)}</span></span>`)\n                    .appendTo(element);\n            } else {\n                $(`<div class=\"${GROUPITEM}\"></div>`)\n                    .appendTo(element)\n                    .html(templates.groupTemplate(data.group));\n            }\n        } else if (data.group && hasColumns) {\n            element.append($('<span class=\"k-table-td k-table-spacer-td\"></span>'));\n        }\n\n        if (data.top !== undefined) {\n            element.css(\"top\", data.top + \"px\");\n        }\n    }\n\n    function renderColumns(options, dataItem, templates) {\n        let item = \"\";\n\n        for (let i = 0; i < options.columns.length; i++) {\n            const currentWidth = options.columns[i].width;\n            const currentWidthInt = parseInt(currentWidth, 10);\n            let widthStyle = '';\n\n            if (currentWidth) {\n                const widthValue = `${currentWidthInt}${percentageUnitsRegex.test(currentWidth) ? \"%\" : \"px\"}`;\n                widthStyle = `${kendo.attr(\"style-width\")}=\"${widthValue}\" ${kendo.attr(\"style-max-width\")}=\"${widthValue}\"`;\n            }\n\n            item += `<span class='k-table-td' ${widthStyle}>`;\n            item += templates[\"column\" + i](dataItem);\n            item += \"</span>\";\n        }\n\n        return item;\n    }\n\n    function mapChangedItems(selected, itemsToMatch) {\n        const itemsLength = itemsToMatch.length;\n        const selectedLength = selected.length;\n        const changed = [];\n        const unchanged = [];\n\n        if (selectedLength) {\n            for (let i = 0; i < selectedLength; i++) {\n                const dataItem = selected[i];\n                let found = false;\n\n                for (let j = 0; j < itemsLength; j++) {\n                    if (dataItem === itemsToMatch[j]) {\n                        found = true;\n                        changed.push({ index: i, item: dataItem });\n                        break;\n                    }\n                }\n\n                if (!found) {\n                    unchanged.push(dataItem);\n                }\n            }\n        }\n\n        return { changed, unchanged };\n    }\n\n    function isActivePromise(promise) {\n        return promise && promise.state() !== \"resolved\";\n    }\n\n    const VirtualList = DataBoundWidget.extend({\n        init: function(element, options) {\n            const that = this;\n            const contentClasses = options.columns?.length ? TABLE_CONTENT : LIST_CONTENT;\n\n            that.bound(false);\n            that._fetching = false;\n\n            Widget.fn.init.call(that, element, options);\n\n            if (!that.options.itemHeight) {\n                that.options.itemHeight = getDefaultItemHeight(options.listSize);\n            }\n\n            that._cssGap = 0;\n            options = that.options;\n\n            that.element.attr(\"role\", \"listbox\");\n\n            if (that.options.columns?.length) {\n                const contentSelector = \".\" + contentClasses.split(' ').join('.');\n                that.content = that.wrapper = that.element.find(contentSelector);\n                if (!that.content.length) {\n                    that.content = that.wrapper = $(`<div unselectable='on' class='${contentClasses}'></div>`).appendTo(that.element);\n                }\n\n                const stickyHeader = $(`<div class=\"${that._getFixedGroupHeaderClass()}\"><span class=\"k-table-th\"></span></div>`);\n                that.content.before(stickyHeader);\n                that.header = stickyHeader.find(\".k-table-th\");\n            } else {\n                that.header = $(`<div class='${that._getFixedGroupHeaderClass()}'></div>`).appendTo(that.element);\n                that.content = that.wrapper = $(`<div unselectable='on' class='${contentClasses}'></div>`).appendTo(that.element);\n            }\n\n            that.element.children(\".k-list-footer, .k-table-footer\").appendTo(that.element);\n\n            if (options.ariaLabel) {\n                this.element.attr(\"aria-label\", options.ariaLabel);\n            } else if (options.ariaLabelledBy) {\n                this.element.attr(\"aria-labelledby\", options.ariaLabelledBy);\n            }\n\n            that.element.on(\"mouseenter\" + VIRTUAL_LIST_NS, \"li:not(.k-loading-item)\", function() { $(this).addClass(HOVER); })\n                        .on(\"mouseleave\" + VIRTUAL_LIST_NS, \"li\", function() { $(this).removeClass(HOVER); });\n\n            that._values = toArray(that.options.value);\n            that._selectedDataItems = [];\n            that._selectedIndexes = [];\n            that._rangesList = {};\n            that._promisesList = [];\n            that._optionID = kendo.guid();\n\n            that._templates();\n\n            that.setDataSource(options.dataSource);\n\n            that.content.on(\"scroll\" + VIRTUAL_LIST_NS, kendo.throttle(function() {\n                that._renderItems();\n                that._triggerListBound();\n            }, options.delay));\n\n            that._selectable();\n        },\n\n        options: {\n            name: \"VirtualList\",\n            autoBind: true,\n            delay: 100,\n            height: null,\n            listScreens: 4,\n            threshold: 0.5,\n            itemHeight: null,\n            oppositeBuffer: 1,\n            type: \"flat\",\n            selectable: false,\n            value: [],\n            dataValueField: null,\n            template: (data) => encode(data),\n            placeholderTemplate: () => \"loading...\",\n            groupTemplate: (data) => encode(data),\n            fixedGroupTemplate: (data) => encode(data),\n            fixedGroupHeader: true,\n            mapValueTo: \"index\",\n            valueMapper: null,\n            ariaLabel: null,\n            ariaLabelledBy: null,\n            id: null,\n            iconField: null,\n            descriptionField: null,\n            groupIconField: null,\n            actionField: null\n        },\n\n        events: [\n            CHANGE,\n            CLICK,\n            LISTBOUND,\n            ITEMCHANGE,\n            ACTIVATE,\n            DEACTIVATE,\n            ACTION\n        ],\n\n        _isTableVariant: function() {\n            return !!this.options.columns?.length;\n        },\n\n        _getItemClass: function() {\n            return this._isTableVariant() ? TABLE_ITEM : LIST_ITEM;\n        },\n\n        _getItemHeightStyle: function() {\n            return this.options.itemHeight + \"px\";\n        },\n\n        _getHeaderHeight: function() {\n            return this.header?.is(\":visible\") ? this.header.outerHeight() : 0;\n        },\n\n        _toggleHeaderVisibility: function(show) {\n            const target = this.header.closest(GROUP_ROW_SEL).length\n                ? this.header.closest(GROUP_ROW_SEL)\n                : this.header;\n            target[show ? \"show\" : \"hide\"]();\n        },\n\n        _getHeaderTextSelector: function() {\n            return this._isTableVariant() ? \".k-table-th\" : \".k-list-item-text\";\n        },\n\n        _getGroupHeaderClass: function() {\n            return this._isTableVariant() ? \"k-table-group-row\" : GROUP_HEADER_ITEM;\n        },\n\n        _getFixedGroupHeaderClass: function() {\n            return this._isTableVariant() ? TABLE_HEADER : HEADER;\n        },\n\n        setOptions: function(options) {\n            Widget.fn.setOptions.call(this, options);\n\n            if (this._selectProxy && this.options.selectable === false) {\n                this.element.off(CLICK, \".\" + this._getItemClass(), this._selectProxy);\n            } else if (!this._selectProxy && this.options.selectable) {\n                this._selectable();\n            }\n\n            this._templates();\n            this.refresh();\n        },\n\n        items: function() {\n            return $(this._items);\n        },\n\n        /**\n         * Returns the UL elements in the virtual list.\n         * For flat (non-grouped) lists, returns the single UL element.\n         * For grouped lists, returns all currently rendered group UL elements.\n         * @returns {jQuery} - jQuery collection of UL elements\n         */\n        ulElements: function() {\n            const that = this;\n\n            if (that.options.type === \"flat\") {\n                // For flat lists, return the single UL\n                return that.ul || $();\n            } else {\n                // For grouped lists, return all group ULs\n                return that.content.find(\".\" + LIST_UL);\n            }\n        },\n\n        destroy: function() {\n            this.wrapper.off(VIRTUAL_LIST_NS);\n            this.dataSource.unbind(CHANGE, this._refreshHandler);\n            Widget.fn.destroy.call(this);\n        },\n\n        setDataSource: function(source) {\n            const that = this;\n            let dataSource = source || {};\n\n            dataSource = Array.isArray(dataSource) ? { data: dataSource } : dataSource;\n            dataSource = kendo.data.DataSource.create(dataSource);\n\n            if (that.dataSource) {\n                that.dataSource.unbind(CHANGE, that._refreshHandler);\n\n                that._clean();\n                that.bound(false);\n\n                that._deferValueSet = true;\n                const value = that.value();\n\n                that.value([]);\n                that.mute(function() {\n                    that.value(value);\n                });\n            } else {\n                that._refreshHandler = that.refresh.bind(that);\n            }\n\n            that.dataSource = dataSource.bind(CHANGE, that._refreshHandler);\n\n            that.setDSFilter(dataSource.filter());\n\n            if (dataSource.view().length !== 0) {\n                that.refresh();\n            } else if (that.options.autoBind) {\n                dataSource.fetch();\n            }\n        },\n\n        skip: function() {\n            return this.dataSource.currentRangeStart();\n        },\n\n        _triggerListBound: function() {\n            const that = this;\n            const skip = that.skip();\n\n            if (that.bound() && !that._selectingValue && that._skip !== skip) {\n                that._skip = skip;\n                that.trigger(LISTBOUND);\n            }\n        },\n\n        _getValues: function(dataItems) {\n            const getter = this._valueGetter;\n\n            return $.map(dataItems, (dataItem) => getter(dataItem));\n        },\n\n        _highlightSelectedItems: function() {\n            for (let i = 0; i < this._selectedDataItems.length; i++) {\n                const item = this._getElementByDataItem(this._selectedDataItems[i]);\n                if (item.length) {\n                    item.addClass(SELECTED);\n                }\n            }\n        },\n\n        _focusSelectedInFilteredData: function() {\n            const that = this;\n            const selectedDataItems = that._selectedDataItems;\n            const valueGetter = that._valueGetter;\n            let focusIndex = 0;\n\n            if (selectedDataItems.length) {\n                const data = that.dataSource.flatView();\n                const selectedValue = valueGetter(selectedDataItems[0]);\n\n                for (let i = 0; i < data.length; i++) {\n                    const item = that.options.type === \"group\" ? data[i].item : data[i];\n                    if (item && valueGetter(item) === selectedValue) {\n                        focusIndex = i;\n                        break;\n                    }\n                }\n            }\n\n            that.focus(focusIndex);\n        },\n\n        refresh: function(e) {\n            const that = this;\n            const action = e?.action;\n            const isItemChange = action === \"itemchange\";\n            const filtered = this.isFiltered();\n\n            if (that._mute) { return; }\n\n            that._deferValueSet = false;\n\n            if (!that._fetching) {\n                if (filtered) {\n                    that._focusSelectedInFilteredData();\n                }\n\n                that._createList();\n                if (!action && that._values.length && !filtered &&\n                     !that.options.skipUpdateOnBind && !that._emptySearch) {\n                    that._selectingValue = true;\n\n                    that.bound(true);\n                    that.value(that._values, true).done(function() {\n                        that._selectingValue = false;\n                        that._triggerListBound();\n                    });\n                } else {\n                    that.bound(true);\n                    that._highlightSelectedItems();\n                    that._triggerListBound();\n                }\n            } else {\n                if (that._renderItems) {\n                    that._renderItems(true);\n                }\n\n                that._triggerListBound();\n            }\n\n            if (isItemChange || action === \"remove\") {\n                const result = mapChangedItems(that._selectedDataItems, e.items);\n                if (result.changed.length) {\n                    if (isItemChange) {\n                        that.trigger(\"selectedItemChange\", {\n                            items: result.changed\n                        });\n                    } else {\n                        that.value(that._getValues(result.unchanged));\n                    }\n                }\n            }\n\n            that._fetching = false;\n        },\n\n        removeAt: function(position) {\n            const value = this._values.splice(position, 1)[0];\n\n            return {\n                position,\n                dataItem: this._removeSelectedDataItem(value)\n            };\n        },\n\n        _removeSelectedDataItem: function(value) {\n            const that = this;\n            const valueGetter = that._valueGetter;\n\n            for (const idx in that._selectedDataItems) {\n                if (valueGetter(that._selectedDataItems[idx]) === value) {\n                    that._selectedIndexes.splice(idx, 1);\n                    return that._selectedDataItems.splice(idx, 1)[0];\n                }\n            }\n        },\n\n        setValue: function(value) {\n            this._values = toArray(value);\n        },\n\n        value: function(value, _forcePrefetch) {\n            const that = this;\n\n            if (value === undefined) {\n                return that._values.slice();\n            }\n\n            if (value === null) {\n                value = [];\n            }\n\n            value = toArray(value);\n\n            if (!that._valueDeferred || that._valueDeferred.state() === \"resolved\") {\n                that._valueDeferred = $.Deferred();\n            }\n\n            const shouldClear = that.options.selectable === \"multiple\" && that.select().length && value.length;\n\n            if (shouldClear || !value.length) {\n                that.select(-1);\n            }\n\n            that._values = value;\n\n            if ((that.bound() && !that._mute && !that._deferValueSet) || _forcePrefetch) {\n                that._prefetchByValue(value);\n            }\n\n            return that._valueDeferred;\n        },\n\n        _checkValuesOrder: function(value) {\n            if (this._removedAddedIndexes?.length === value.length) {\n                const newValue = this._removedAddedIndexes.slice();\n                this._removedAddedIndexes = null;\n                return newValue;\n            }\n\n            return value;\n        },\n\n        _prefetchByValue: function(value) {\n            const that = this;\n            const dataView = that._dataView;\n            const valueGetter = that._valueGetter;\n            const mapValueTo = that.options.mapValueTo;\n            const forSelection = [];\n\n            //try to find the items in the loaded data\n            for (let i = 0; i < value.length; i++) {\n                for (let idx = 0; idx < dataView.length; idx++) {\n                    const item = dataView[idx].item;\n                    if (item) {\n                        const match = isPrimitive(item) ? value[i] === item : value[i] === valueGetter(item);\n\n                        if (match) {\n                            forSelection.push(dataView[idx].index);\n                        }\n                    }\n                }\n            }\n\n            if (forSelection.length === value.length) {\n                that._values = [];\n                that.select(forSelection);\n                return;\n            }\n\n            //prefetch the items\n            if (typeof that.options.valueMapper === \"function\") {\n                const callback = mapValueTo === 'index' ? that.mapValueToIndex : that.mapValueToDataItem;\n                that.options.valueMapper(valueMapperOptions(this.options, value, callback.bind(that)));\n            } else {\n                 if (!that.value()[0]) {\n                     that.select([-1]);\n                 } else {\n                    that._selectingValue = false;\n                    that._triggerListBound();\n                 }\n            }\n        },\n\n        mapValueToIndex: function(indexes) {\n            if (indexes === undefined || indexes === -1 || indexes === null) {\n                indexes = [];\n            } else {\n                indexes = toArray(indexes);\n            }\n\n            if (!indexes.length) {\n                indexes = [-1];\n            } else {\n                const removed = this._deselect([]).removed;\n                if (removed.length) {\n                    this._triggerChange(removed, []);\n                }\n            }\n\n            this.select(indexes);\n        },\n\n        mapValueToDataItem: function(dataItems) {\n            if (dataItems === undefined || dataItems === null) {\n                dataItems = [];\n            } else {\n                dataItems = toArray(dataItems);\n            }\n\n            if (!dataItems.length) {\n                this.select([-1]);\n            } else {\n                const removed = $.map(this._selectedDataItems, (item, index) => ({ index, dataItem: item }));\n                const added = $.map(dataItems, (item, index) => ({ index, dataItem: item }));\n\n                this._selectedDataItems = dataItems;\n                this._selectedIndexes = [];\n\n                for (let i = 0; i < this._selectedDataItems.length; i++) {\n                    const item = this._getElementByDataItem(this._selectedDataItems[i]);\n                    this._selectedIndexes.push(this._getIndecies(item)[0]);\n                    item.addClass(SELECTED);\n                }\n\n                this._triggerChange(removed, added);\n\n                if (this._valueDeferred) {\n                    this._valueDeferred.resolve();\n                }\n            }\n        },\n\n        deferredRange: function(index) {\n            const dataSource = this.dataSource;\n            const take = this.itemCount;\n            const ranges = this._rangesList;\n            const result = $.Deferred();\n            const defs = [];\n\n            const low = Math.floor(index / take) * take;\n            const high = Math.ceil(index / take) * take;\n\n            const pages = high === low ? [high] : [low, high];\n\n            $.each(pages, (_, skip) => {\n                const end = skip + take;\n                const existingRange = ranges[skip];\n                let deferred;\n\n                if (!existingRange || (existingRange.end !== end)) {\n                    deferred = $.Deferred();\n                    ranges[skip] = { end, deferred };\n\n                    dataSource._multiplePrefetch(skip, take, () => {\n                        deferred.resolve();\n                    });\n                } else {\n                    deferred = existingRange.deferred;\n                }\n\n                defs.push(deferred);\n            });\n\n            $.when(...defs).done(() => {\n                result.resolve();\n            });\n\n            return result;\n        },\n\n        prefetch: function(indexes) {\n            const that = this;\n            const take = this.itemCount;\n            const isEmptyList = !that._promisesList.length;\n\n            if (!isActivePromise(that._activeDeferred)) {\n                that._activeDeferred = $.Deferred();\n                that._promisesList = [];\n            }\n\n            $.each(indexes, (_, index) => {\n                that._promisesList.push(that.deferredRange(that._getSkip(index, take)));\n            });\n\n            if (isEmptyList) {\n                $.when(...that._promisesList).done(() => {\n                    that._promisesList = [];\n                    that._activeDeferred.resolve();\n                });\n            }\n\n            return that._activeDeferred;\n        },\n\n        _findDataItem: function(view, index) {\n            //find in grouped view\n            if (this.options.type === \"group\") {\n                for (let i = 0; i < view.length; i++) {\n                    const group = view[i].items;\n                    if (group.length <= index) {\n                        index = index - group.length;\n                    } else {\n                        return group[index];\n                    }\n                }\n            }\n\n            //find in flat view\n            return view[index];\n        },\n\n        _getRange: function(skip, take) {\n            return this.dataSource._findRange(skip, Math.min(skip + take, this.dataSource.total()));\n        },\n\n        dataItemByIndex: function(index) {\n            const that = this;\n            const take = that.itemCount;\n            const skip = that._getSkip(index, take);\n            let view = this._getRange(skip, take);\n\n            //should not return item if data is not loaded\n            if (!that._getRange(skip, take).length) {\n                return null;\n            }\n\n            if (that.options.type === \"group\") {\n                kendo.ui.progress($(that.wrapper), true);\n                that.mute(function() {\n                    that.dataSource.range(skip, take, () => {\n                        kendo.ui.progress($(that.wrapper), false);\n                    });\n                    view = that.dataSource.view();\n                });\n            }\n\n            return that._findDataItem(view, [index - skip]);\n        },\n\n        selectedDataItems: function() {\n            return this._selectedDataItems.slice();\n        },\n\n        scrollWith: function(value) {\n            this.content.scrollTop(this.content.scrollTop() + value);\n        },\n\n        scrollTo: function(y) {\n            this.content.scrollTop(y); //works only if the element is visible\n        },\n\n        scrollToIndex: function(index) {\n            // Use _getElementPosition to account for group headers\n            const position = this._getElementPosition ? this._getElementPosition(index) : index * (this.options.itemHeight + this._cssGap);\n            this.scrollTo(position);\n        },\n\n        focus: function(candidate) {\n            const that = this;\n            const itemHeight = that.options.itemHeight;\n            const id = that._optionID;\n            let element;\n            let index;\n            let current;\n            let triggerEvent = true;\n\n            if (candidate === undefined) {\n                current = that.content.find(\".\" + FOCUSED);\n                return current.length ? current : null;\n            }\n\n            if (typeof candidate === \"function\") {\n                const data = that.dataSource.flatView();\n                for (let idx = 0; idx < data.length; idx++) {\n                    if (candidate(data[idx])) {\n                        candidate = idx;\n                        break;\n                    }\n                }\n            }\n\n            if (candidate instanceof Array) {\n                candidate = lastFrom(candidate);\n            }\n\n            if (isNaN(candidate)) {\n                element = $(candidate);\n                index = parseInt($(element).attr(\"data-offset-index\"), 10);\n            } else {\n                index = candidate;\n                element = that._getElementByIndex(index);\n            }\n\n            if (index === -1) {\n                that.content.find(\".\" + FOCUSED).removeClass(FOCUSED);\n                that._focusedIndex = undefined;\n                return;\n            }\n\n            if (element.length) { /*focus rendered item*/\n                if (element.hasClass(FOCUSED)) {\n                    triggerEvent = false;\n                }\n\n                const previousIndex = that._focusedIndex;\n                if (previousIndex !== undefined) {\n                    current = that._getElementByIndex(previousIndex);\n                    current\n                        .removeClass(FOCUSED)\n                        .removeAttr(\"id\");\n\n                    if (triggerEvent) {\n                        that.trigger(DEACTIVATE);\n                    }\n                }\n\n                that._focusedIndex = index;\n\n                element\n                    .addClass(FOCUSED)\n                    .attr(\"id\", id);\n\n                // Use actual DOM position for rendered elements - more accurate than calculated position\n                // especially at page boundaries where virtual positioning may have slight offsets\n                // Fall back to calculated position if DOM position is invalid (e.g., container is hidden)\n                let elementPosition = that._getRenderedElementPosition(element);\n                if (elementPosition === 0 && index > 0) {\n                    elementPosition = that._getElementPosition(index);\n                }\n                const headerHeight = that._getHeaderHeight();\n                const goingUp = previousIndex !== undefined && index < previousIndex;\n                const goingDown = previousIndex !== undefined && index > previousIndex;\n\n                // Determine element's location relative to visible viewport\n                const scrollTop = this.content.scrollTop();\n                const visibleTop = scrollTop + headerHeight;\n                const screenEnd = scrollTop + this._screenHeight;\n                const elementBottom = elementPosition + itemHeight;\n\n                let position;\n                if (elementPosition < visibleTop && elementBottom > scrollTop) {\n                    position = \"top\";\n                } else if (elementPosition === screenEnd || (elementPosition < screenEnd && screenEnd < elementBottom)) {\n                    position = \"bottom\";\n                } else if (elementPosition >= visibleTop && elementBottom <= screenEnd) {\n                    position = \"inScreen\";\n                } else {\n                    position = \"outScreen\";\n                }\n\n                if (position === \"top\") {\n                    // Item is under sticky header or above viewport - scroll to show at top (just below header)\n                    that.scrollTo(Math.max(0, elementPosition - headerHeight));\n                } else if (position === \"bottom\") {\n                    // Item is at the bottom edge - scroll to show at bottom (last visible)\n                    that.scrollTo((elementPosition + itemHeight) - that._screenHeight);\n                } else if (position === \"outScreen\") {\n                    // Item is completely outside viewport\n                    if (goingUp) {\n                        // Going up via keyboard - scroll to show item at top (just below header)\n                        that.scrollTo(Math.max(0, elementPosition - headerHeight));\n                    } else if (goingDown) {\n                        // Going down via keyboard - scroll to show item at bottom (last visible)\n                        that.scrollTo((elementPosition + itemHeight) - that._screenHeight);\n                    } else {\n                        // Programmatic focus - show at top\n                        that.scrollTo(Math.max(0, elementPosition - headerHeight));\n                    }\n                }\n\n                if (triggerEvent) {\n                    that.trigger(ACTIVATE);\n                }\n            } else { /*focus non rendered item*/\n                // Remove focus from any currently focused item\n                const previousIndex = that._focusedIndex;\n                if (previousIndex !== undefined) {\n                    current = that._getElementByIndex(previousIndex);\n                    current\n                        .removeClass(FOCUSED)\n                        .removeAttr(\"id\");\n                }\n\n                that._focusedIndex = index;\n                that.items().removeClass(FOCUSED);\n\n                const elementPosition = that._getElementPosition(index);\n                const headerHeight = that._getHeaderHeight();\n                const goingUp = previousIndex !== undefined && index < previousIndex;\n                const goingDown = previousIndex !== undefined && index > previousIndex;\n\n                if (goingUp) {\n                    that.scrollTo(Math.max(0, elementPosition - headerHeight));\n                } else if (goingDown) {\n                    that.scrollTo((elementPosition + itemHeight) - that._screenHeight);\n                } else {\n                    that.scrollTo(Math.max(0, elementPosition - headerHeight));\n                }\n            }\n        },\n\n        focusIndex: function() {\n            return this._focusedIndex;\n        },\n\n        focusFirst: function() {\n            this.scrollTo(0);\n            this.focus(0);\n        },\n\n        focusLast: function() {\n            const lastIndex = this.dataSource.total();\n            this.scrollTo(this.heightContainer.offsetHeight);\n            this.focus(lastIndex - 1);\n        },\n\n        focusPrev: function() {\n            let index = this._focusedIndex;\n\n            if (!isNaN(index) && index > 0) {\n                index -= 1;\n                this.focus(index);\n\n                const current = this.focus();\n                if (current?.hasClass(\"k-loading-item\")) {\n                    index += 1;\n                    this.focus(index);\n                }\n\n                return index;\n            } else {\n                index = this.dataSource.total() - 1;\n                this.focus(index);\n                return index;\n            }\n        },\n\n        focusNext: function() {\n            let index = this._focusedIndex;\n            const lastIndex = this.dataSource.total() - 1;\n\n            if (!isNaN(index) && index < lastIndex) {\n                index += 1;\n                this.focus(index);\n\n                const current = this.focus();\n                if (current?.hasClass(\"k-loading-item\")) {\n                    index -= 1;\n                    this.focus(index);\n                }\n\n                return index;\n            } else {\n                index = 0;\n                this.focus(index);\n                return index;\n            }\n        },\n\n        _triggerChange: function(removed = [], added = []) {\n            if (removed.length || added.length) {\n                 this.trigger(CHANGE, { removed, added });\n            }\n        },\n\n        select: function(candidate) {\n            const that = this;\n            const singleSelection = that.options.selectable !== \"multiple\";\n            let prefetchStarted = isActivePromise(that._activeDeferred);\n            const filtered = this.isFiltered();\n\n            if (candidate === undefined) {\n                return that._selectedIndexes.slice();\n            }\n\n            if (!that._selectDeferred || that._selectDeferred.state() === \"resolved\") {\n                that._selectDeferred = $.Deferred();\n            }\n\n            let indices = that._getIndecies(candidate);\n            const isAlreadySelected = singleSelection && !filtered && lastFrom(indices) === lastFrom(this._selectedIndexes);\n            let removed = that._deselectCurrentValues(indices);\n\n            if (removed.length || !indices.length || isAlreadySelected) {\n                that._triggerChange(removed);\n\n                if (that._valueDeferred) {\n                    that._valueDeferred.resolve().promise();\n                }\n\n                return that._selectDeferred.resolve().promise();\n            }\n\n            if (indices.length === 1 && indices[0] === -1) {\n                indices = [];\n            }\n\n            const initialIndices = indices;\n            const result = that._deselect(indices);\n            removed = result.removed;\n            indices = result.indices;\n\n            if (singleSelection) {\n                prefetchStarted = false;\n                if (indices.length) {\n                    indices = [lastFrom(indices)];\n                }\n            }\n\n            const done = function() {\n                const added = that._select(indices);\n\n                if (initialIndices.length === indices.length || singleSelection) {\n                    that.focus(indices);\n                }\n\n                that._triggerChange(removed, added);\n\n                if (that._valueDeferred) {\n                    that._valueDeferred.resolve();\n                }\n\n                that._selectDeferred.resolve();\n            };\n\n            const deferred = that.prefetch(indices);\n\n            if (!prefetchStarted) {\n                if (deferred) {\n                    deferred.done(done);\n                } else {\n                    done();\n                }\n            }\n\n            return that._selectDeferred.promise();\n        },\n\n        bound: function(bound) {\n            if (bound === undefined) {\n                return this._listCreated;\n            }\n\n            this._listCreated = bound;\n        },\n\n        mute: function(callback) {\n            this._mute = true;\n            callback();\n            this._mute = false;\n        },\n\n        setDSFilter: function(filter) {\n            this._lastDSFilter = $.extend({}, filter);\n        },\n\n        isFiltered: function() {\n            if (!this._lastDSFilter) {\n                this.setDSFilter(this.dataSource.filter());\n            }\n\n            return !kendo.data.Query.compareFilters(this.dataSource.filter(), this._lastDSFilter);\n        },\n\n        skipUpdate: $.noop,\n\n        _getElementByIndex: function(index) {\n            return this.items().filter((idx, element) =>\n                index === parseInt($(element).attr(\"data-offset-index\"), 10)\n            );\n        },\n\n        _getElementByDataItem: function(dataItem) {\n            const dataView = this._dataView;\n            const valueGetter = this._valueGetter;\n            let element;\n\n            for (let i = 0; i < dataView.length; i++) {\n                const match = dataView[i].item && isPrimitive(dataView[i].item)\n                    ? dataView[i].item === dataItem\n                    : dataView[i].item && dataItem && valueGetter(dataView[i].item) == valueGetter(dataItem);\n                if (match) {\n                    element = dataView[i];\n                    break;\n                }\n            }\n\n            return element ? this._getElementByIndex(element.index) : $();\n        },\n\n        _clean: function() {\n            this.result = undefined;\n            this._lastScrollTop = undefined;\n            this._skip = undefined;\n            $(this.heightContainer).remove();\n            this.heightContainer = undefined;\n\n            // Clean content children\n            if (this.content) {\n                this.content.empty();\n            }\n\n            // Clean flat UL reference\n            this._flatUl = null;\n            this.ul = null;\n\n            // Clean grouped resources\n            if (this._groupUlCache) {\n                for (const key in this._groupUlCache) {\n                    const cached = this._groupUlCache[key];\n                    if (cached?.ul?.parentNode) {\n                        cached.ul.parentNode.removeChild(cached.ul);\n                    }\n                }\n            }\n            this._groupContainers = [];\n            this._groupUlCache = {};\n            this._groupRanges = null;\n            this._items = [];\n\n            // Reset group value map (shared across buildGroupRanges and _buildGroupedPageData)\n            this._groupValueMap = null;\n        },\n\n        _height: function() {\n            const hasData = !!this.dataSource.view().length;\n            let height = this.options.height;\n            const itemHeight = this.options.itemHeight;\n            const cssGap = this._cssGap || 0;\n            const effectiveItemHeight = itemHeight + cssGap;\n            const total = this.dataSource.total();\n\n            if (!hasData) {\n                height = 0;\n            } else if (height / effectiveItemHeight > total) {\n                height = total * effectiveItemHeight;\n            }\n\n            return height;\n        },\n\n        setScreenHeight: function() {\n            const height = this._height();\n\n            this.content.height(height);\n            this._screenHeight = height;\n        },\n\n        screenHeight: function() {\n            return this._screenHeight;\n        },\n\n        /**\n         * Gets the actual DOM position of a rendered element relative to the scroll container.\n         * This is more accurate than _getElementPosition for rendered items because it uses\n         * the actual DOM layout rather than calculated positions.\n         * @param {jQuery} element - The rendered element\n         * @returns {number} - The pixel position relative to the scroll container's content\n         */\n        _getRenderedElementPosition: function(element) {\n            if (!element || !element.length) {\n                return 0;\n            }\n\n            const el = element[0];\n            const parentUl = element.closest(\"ul\")[0];\n\n            if (!parentUl) {\n                return el.offsetTop;\n            }\n\n            // Get the UL's translateY transform value\n            const transform = parentUl.style.transform || parentUl.style.webkitTransform || \"\";\n            const match = transform.match(/translateY\\((-?\\d+(?:\\.\\d+)?)px\\)/);\n            const ulTranslateY = match ? parseFloat(match[1]) : 0;\n\n            // Element's position = UL's transform position + element's offset within UL\n            return ulTranslateY + el.offsetTop;\n        },\n\n        _getElementLocation: function(index) {\n            const scrollTop = this.content.scrollTop();\n            const screenHeight = this._screenHeight;\n            const itemHeight = this.options.itemHeight;\n            const yPosition = this._getElementPosition(index);\n            const yDownPostion = yPosition + itemHeight;\n            const screenEnd = scrollTop + screenHeight;\n            const headerHeight = this._getHeaderHeight();\n            const visibleTop = scrollTop + headerHeight;\n\n            if (yPosition < visibleTop && yDownPostion > scrollTop) {\n                return \"top\";\n            } else if (yPosition === screenEnd || (yPosition < screenEnd && screenEnd < yDownPostion)) {\n                return \"bottom\";\n            } else if ((yPosition >= visibleTop) && (yDownPostion <= screenEnd)) {\n                return \"inScreen\";\n            } else {\n                return \"outScreen\";\n            }\n        },\n\n        _getElementPosition: function(index) {\n            const itemHeight = this.options.itemHeight;\n            const groupRanges = this._groupRanges;\n            const cssGap = this._cssGap || 0;\n\n            // For grouped lists with known ranges, calculate accounting for headers\n            if (groupRanges && groupRanges.length) {\n                // Check if the index is within the known group ranges\n                const lastRange = groupRanges[groupRanges.length - 1];\n                const lastKnownIndex = lastRange.startIndex + lastRange.itemCount - 1;\n\n                if (index <= lastKnownIndex) {\n                    return getGroupedItemPosition(index, itemHeight, groupRanges, cssGap);\n                }\n\n                // Index is beyond known ranges - estimate position\n                // Use the position after all known groups plus estimated additional space\n                const knownPosition = getGroupedItemPosition(lastKnownIndex, itemHeight, groupRanges, cssGap);\n                const itemsBeyond = index - lastKnownIndex;\n\n                // Estimate: assume average group density continues\n                // Add a small factor for potential group headers\n                const avgItemsPerGroup = lastKnownIndex / groupRanges.length;\n                const estimatedNewHeaders = Math.floor(itemsBeyond / avgItemsPerGroup);\n\n                return knownPosition + (itemsBeyond * (itemHeight + cssGap)) + (estimatedNewHeaders * itemHeight);\n            }\n\n            // Non-grouped list: simple calculation including CSS gap\n            return index * (itemHeight + cssGap);\n        },\n\n        _templates: function() {\n            const options = this.options;\n            const templates = {\n                template: options.template,\n                placeholderTemplate: options.placeholderTemplate,\n                groupTemplate: options.groupTemplate,\n                fixedGroupTemplate: options.fixedGroupTemplate\n            };\n\n            if (options.columns) {\n                options.columns.forEach((column, i) => {\n                    const templateText = column.field ? column.field.toString() : \"text\";\n                    const templateFunc = data => encode(kendo.getter(templateText)(data));\n\n                    templates[\"column\" + i] = column.template || templateFunc;\n                });\n            }\n\n            for (const key in templates) {\n                if (typeof templates[key] !== \"function\") {\n                    templates[key] = kendo.template(templates[key] || \"\");\n                }\n            }\n\n            this.templates = templates;\n        },\n\n        _generateItems: function(element, count) {\n            const items = [];\n            const itemHeight = this._getItemHeightStyle();\n            const itemClass = this._getItemClass();\n\n            while (count-- > 0) {\n                const text = document.createElement(\"span\");\n                text.className = \"k-list-item-text\";\n\n                const item = document.createElement(\"li\");\n                item.tabIndex = -1;\n                item.className = itemClass;\n                item.setAttribute(\"role\", \"option\");\n                item.style.height = itemHeight;\n                item.style.minHeight = itemHeight;\n                item.style.position = \"absolute\";\n                item.style.width = \"100%\";\n                item.appendChild(text);\n\n                element.appendChild(item);\n\n                items.push(item);\n            }\n\n            return items;\n        },\n\n        // ============ Grouped List Generation Methods ============\n\n        /**\n         * Generates a unique ID for a group header element.\n         * @param {number} groupIndex - The global group index\n         * @param {string} groupValue - The group value\n         * @returns {string} - A unique ID for the group header\n         */\n        _generateGroupId: function(groupIndex, groupValue) {\n            // Use explicit null/undefined check to handle boolean false and 0 correctly\n            const stringValue = (groupValue === null || groupValue === undefined) ? \"\" : String(groupValue);\n            const safeValue = stringValue.replace(/\\s+/g, \"-\").replace(/[^a-zA-Z0-9-_]/g, \"\");\n            return this._optionID + \"-group-\" + groupIndex + \"-\" + safeValue;\n        },\n\n        /**\n         * Creates a group UL container with group header (except first group)\n         * Following Angular implementation pattern with role=\"group\" and aria-labelledby\n         * @param {boolean} hasHeader - Whether to include a group header li\n         * @param {string} groupValue - The group value for the header\n         * @param {number} groupIndex - The global group index (for generating unique IDs)\n         * @returns {Object} - { ul, header, items: [], groupId }\n         */\n        _createGroupUl: function(hasHeader, groupValue, groupIndex, firstDataItem) {\n            const that = this;\n            const options = that.options;\n            const itemHeight = that._getItemHeightStyle();\n            const ul = document.createElement(\"ul\");\n            const groupId = that._generateGroupId(groupIndex, groupValue);\n            const groupIconField = options.groupIconField;\n\n            ul.className = that._isTableVariant() ? `${LIST_UL} ${TABLE}` : LIST_UL;\n            ul.style.position = \"absolute\";\n            ul.style.width = \"100%\";\n            ul.style.top = \"0\";\n            ul.style.left = \"0\";\n\n            // Set the ID for accessibility (aria-controls) - use base id + group index\n            if (options.id) {\n                ul.id = `${options.id}-group-${groupIndex}`;\n            }\n\n            // Add role=\"group\" and aria-labelledby for accessibility (Angular pattern)\n            ul.setAttribute(\"role\", \"group\");\n            ul.setAttribute(\"aria-labelledby\", groupId);\n\n            if (options.ariaLive) {\n                ul.setAttribute(\"aria-live\", options.ariaLive);\n            }\n\n            const groupContainer = {\n                ul,\n                header: null,\n                items: [],\n                groupValue,\n                hasHeader,\n                groupId\n            };\n\n            // Add group header for non-first groups\n            if (hasHeader) {\n                const header = document.createElement(\"li\");\n                header.className = that._getGroupHeaderClass();\n                header.setAttribute(\"role\", \"presentation\");\n                header.setAttribute(\"id\", groupId);\n                header.style.height = itemHeight;\n                header.style.minHeight = itemHeight;\n                header.style.position = \"relative\";\n                header.style.transform = \"none\";\n                // Prevent the k-table-th border from bleeding outside the fixed height container\n                header.style.overflow = \"hidden\";\n\n                // Add group icon if groupIconField is set and first data item has the icon\n                if (groupIconField && firstDataItem && firstDataItem[groupIconField]) {\n                    const iconWrapper = document.createElement(\"span\");\n                    iconWrapper.className = \"k-list-item-icon-wrapper\";\n                    iconWrapper.setAttribute(\"role\", \"presentation\");\n                    const iconHtml = kendo.ui.icon({ icon: firstDataItem[groupIconField], iconClass: \"k-list-group-icon\", attr: { \"aria-hidden\": \"true\" } });\n                    $(iconWrapper).append(iconHtml);\n                    $(header).append(iconWrapper);\n                }\n\n                const headerText = document.createElement(\"span\");\n                headerText.className = that._isTableVariant() ? \"k-table-th\" : \"k-list-item-text\";\n                header.appendChild(headerText);\n\n                ul.appendChild(header);\n                groupContainer.header = header;\n            }\n\n            return groupContainer;\n        },\n\n        /**\n         * Adds items to a group UL\n         * @param {Object} groupContainer - The group container object\n         * @param {number} count - Number of items to add\n         */\n        _addGroupItems: function(groupContainer, count) {\n            const that = this;\n            const itemHeight = that._getItemHeightStyle();\n            const hasColumns = that._isTableVariant();\n            const itemClass = that._getItemClass();\n\n            for (let i = 0; i < count; i++) {\n                const item = document.createElement(\"li\");\n                item.tabIndex = -1;\n                item.className = itemClass;\n                item.setAttribute(\"role\", \"option\");\n                item.style.height = itemHeight;\n                item.style.minHeight = itemHeight;\n                // Items inside grouped ULs should NOT be absolutely positioned\n                // They flow naturally within the UL which is itself positioned\n                item.style.position = \"relative\";\n                item.style.transform = \"none\";\n\n                // For table variant (columns), we don't add k-list-item-text here\n                // The column cells will be rendered by _renderGroupItem\n                if (!hasColumns) {\n                    const text = document.createElement(\"span\");\n                    text.className = \"k-list-item-text\";\n                    item.appendChild(text);\n                }\n\n                groupContainer.ul.appendChild(item);\n                groupContainer.items.push(item);\n            }\n        },\n\n        /**\n         * Generates grouped UL structure based on visible groups\n         * @param {HTMLElement} container - The container element\n         * @param {Array} visibleGroups - Array of visible group info\n         * @param {number} itemsPerGroup - Max items to render per group\n         * @returns {Object} - { groupContainers: [...], allItems: [...] }\n         */\n        _generateGroupedItems: function(container, visibleGroups, itemsPerGroup) {\n            const that = this;\n            const groupContainers = [];\n            const allItems = [];\n\n            // Clear existing content\n            container.innerHTML = \"\";\n\n            for (const groupInfo of visibleGroups) {\n                const groupContainer = that._createGroupUl(groupInfo.hasHeader, groupInfo.groupValue, groupInfo.groupIndex);\n\n                // Calculate how many items to render for this group\n                const itemCount = Math.min(groupInfo.itemCount, itemsPerGroup);\n                that._addGroupItems(groupContainer, itemCount);\n\n                // Position the UL\n                position(groupContainer.ul, groupInfo.top);\n\n                // Store group info on the UL for later reference\n                groupContainer.ul.setAttribute(\"data-group-index\", groupInfo.groupIndex);\n                groupContainer.ul.setAttribute(\"data-start-index\", groupInfo.startIndex);\n                groupContainer.startIndex = groupInfo.startIndex;\n                groupContainer.itemCount = itemCount;\n                groupContainer.top = groupInfo.top;\n                groupContainer.groupIndex = groupInfo.groupIndex;\n\n                container.appendChild(groupContainer.ul);\n                groupContainers.push(groupContainer);\n                allItems.push(...groupContainer.items);\n            }\n\n            return { groupContainers, allItems };\n        },\n\n        // ============ End Grouped List Generation Methods ============\n\n        _saveInitialRanges: function() {\n            const ranges = this.dataSource._ranges;\n            const deferred = $.Deferred();\n            deferred.resolve();\n\n            this._rangesList = {};\n            for (let i = 0; i < ranges.length; i++) {\n                this._rangesList[ranges[i].start] = { end: ranges[i].end, deferred };\n            }\n        },\n\n        _createList: function() {\n            const that = this;\n            const content = that.content.get(0);\n            const options = that.options;\n            const dataSource = that.dataSource;\n\n            if (that.bound()) {\n                that._clean();\n            }\n\n            that._saveInitialRanges();\n            that._buildValueGetter();\n            that.setScreenHeight();\n            that.itemCount = getItemCount(that._screenHeight, options.listScreens, options.itemHeight);\n\n            if (that.itemCount > dataSource.total()) {\n                that.itemCount = dataSource.total();\n            }\n\n            that.options.type = (dataSource.group() || []).length ? \"group\" : \"flat\";\n\n            if (that.options.type === \"flat\") {\n                const ul = document.createElement(\"ul\");\n                ul.className = that._isTableVariant() ? `${LIST_UL} ${TABLE}` : LIST_UL;\n                ul.style.position = \"relative\";\n                that.content.get(0).appendChild(ul);\n                that._flatUl = ul;\n\n                // Set the ID for accessibility (aria-controls)\n                if (options.id) {\n                    ul.id = options.id;\n                }\n\n                if (options.ariaLive) {\n                    ul.setAttribute(\"aria-live\", options.ariaLive);\n                }\n\n                // Expose ul reference for flat (non-grouped) lists\n                that.ul = $(ul);\n\n                // Measure CSS gap from the UL for positioning calculations (only for non-table variants)\n                that._cssGap = that._isTableVariant() ? 0 : getCssGap(that.content, that.ul);\n\n                that._items = that._generateItems(ul, that.itemCount);\n\n                // Calculate total height including CSS gap between items\n                const totalItems = dataSource.total();\n                const effectiveItemHeight = options.itemHeight + that._cssGap;\n                const totalHeight = totalItems * effectiveItemHeight;\n                that._setHeight(totalHeight);\n\n                that._toggleHeaderVisibility(false);\n\n                that.getter = that._getter(() => {\n                    that._renderItems(true);\n                });\n\n                that._onScroll = (scrollTop, force) => {\n                    const getList = that._listItems(that.getter);\n                    return that._fixedHeader(scrollTop, getList(scrollTop, force));\n                };\n\n                that._renderItems = that._whenChanged(\n                    scrollCallback(content, that._onScroll),\n                    syncList(that._reorderList(that._items, render.bind(that)))\n                );\n            } else {\n                // Grouped list rendering (new behavior with multiple ULs)\n                that._toggleHeaderVisibility(options.fixedGroupHeader !== false);\n\n                // Initialize group value map for consistent group indices across pages\n                that._groupValueMap = new Map();\n\n                that._cssGap = getCssGap(that.content, null);\n\n                // Build group ranges from dataSource (initial load, firstGroupIndex = 0)\n                that._groupRanges = buildGroupRanges(dataSource, 0, 0, that._groupValueMap);\n\n                // Determine total group count:\n                let estimatedTotalGroups = options.groupCount;\n                const isServerOperations = dataSource.options.serverGrouping === true;\n\n                if (!estimatedTotalGroups && that._groupRanges.length > 0) {\n                    if (isServerOperations) {\n                        estimatedTotalGroups = that._groupRanges.length;\n                    } else {\n                        const groupDescriptor = dataSource.group();\n                        const allData = dataSource.data();\n                        if (allData?.length && groupDescriptor?.length) {\n                            const fullGrouped = new kendo.data.Query(allData).group(groupDescriptor).data;\n                            estimatedTotalGroups = fullGrouped.length;\n                        } else {\n                            estimatedTotalGroups = that._groupRanges.length;\n                        }\n                    }\n                }\n                that._totalGroupCount = estimatedTotalGroups || that._groupRanges.length;\n                that._initialGroupRanges = that._groupRanges.slice(); // Keep a copy\n\n                // Calculate total height including CSS gap\n                // Include space for group headers (all groups except the first have inline headers)\n                const groupCount = that._totalGroupCount;\n\n                // Item count for height calculation:\n                // - Server grouping: use dataSource.total() (server knows the total)\n                // - Client grouping: use dataSource.data().length (all data loaded locally)\n                const isServerGrouping = dataSource.options.serverGrouping === true;\n                const itemCount = isServerGrouping ? dataSource.total() : (dataSource.data().length || dataSource.total());\n\n                const totalHeight = getGroupedTotalHeight(itemCount, options.itemHeight, groupCount, that._cssGap);\n                that._setHeight(totalHeight);\n\n                // Initialize grouped rendering\n                that._initGroupedRendering();\n            }\n\n            that._renderItems();\n            that._calculateGroupPadding(that._screenHeight);\n            that._calculateColumnsHeaderPadding();\n        },\n\n        _initGroupedRendering: function() {\n            const that = this;\n            const content = that.content.get(0);\n\n            // State tracking\n            that._currentPageStart = 0;\n            that._renderedPageStart = null;\n            that._groupUls = []; // Array of rendered UL elements\n            that._items = [];\n\n            // Create the grouped getter (handles data fetching)\n            that.getter = that._groupedGetter(() => {\n                that._renderItems(true);\n            });\n\n            // Scroll handler - determines which page to show\n            that._onScroll = (scrollTop, force) => that._handleGroupedScroll(scrollTop, force);\n\n            // Render function with smart change detection\n            that._renderItems = that._whenChangedGrouped(\n                scrollCallback(content, that._onScroll),\n                (list, force) => {\n                    that._renderGroupedPage(list, force);\n                    return list;\n                }\n            );\n        },\n\n        /**\n         * Handles scroll events for grouped list.\n         * Determines which page of data should be displayed based on scroll position.\n         */\n        _handleGroupedScroll: function(scrollTop, force) {\n            const that = this;\n            const itemHeight = that.options.itemHeight;\n            const dataSource = that.dataSource;\n            const pageSize = that.itemCount;\n            const total = dataSource.total();\n            const screenHeight = that._screenHeight || 300;\n            const totalGroupCount = that._totalGroupCount || 1;\n            const isServerOperations = dataSource.options.serverGrouping === true;\n\n            // For client-side operations, all data is loaded - no paging logic needed\n            if (!isServerOperations) {\n                return that._buildGroupedPageData(0, scrollTop);\n            }\n\n            // Server-side operations: calculate total content height including group headers\n            const totalHeight = (total * itemHeight) + (Math.max(0, totalGroupCount - 1) * itemHeight);\n\n            // Calculate which page we should be on based on scroll position\n            const pageInfo = that._scrollPositionToPageInfo(scrollTop);\n            let pageStart = pageInfo.pageStart;\n\n            // Constrain to valid range\n            const maxPageStart = Math.max(0, total - pageSize);\n\n            // IMPORTANT: If scroll is near the end of the list (within 2x screen height of bottom),\n            // use maxPageStart to ensure we have all the final items loaded\n            const scrollBottom = scrollTop + screenHeight;\n            const nearEnd = scrollBottom >= totalHeight - (screenHeight * 2);\n            if (nearEnd && pageStart < maxPageStart) {\n                pageStart = maxPageStart;\n            }\n\n            let constrainedPageStart = Math.min(Math.max(0, pageStart), maxPageStart);\n\n            // Check if page changed\n            const pageChanged = that._currentPageStart !== constrainedPageStart;\n\n            if (pageChanged || force) {\n                // Need to load new page data\n                if (!dataSource.inRange(constrainedPageStart, pageSize)) {\n                    // Data not available - fetch it\n                    if (that._pageDeferred) {\n                        that._pageDeferred.reject();\n                    }\n\n                    that._pageDeferred = that.deferredRange(constrainedPageStart);\n                    that._pageDeferred.then(() => {\n                        that._pageDeferred = null;\n                        that.mute(() => {\n                            dataSource.range(constrainedPageStart, pageSize);\n                        });\n                        const firstGroupIdx = that._estimateFirstGroupIndex(constrainedPageStart);\n                        that._groupRanges = buildGroupRanges(dataSource, constrainedPageStart, firstGroupIdx, that._groupValueMap);\n                        that._updateGroupCountAndHeight();\n                        that._currentPageStart = constrainedPageStart;\n                        that._renderItems(true);\n                    });\n\n                    // Return placeholder data while loading to fill the visible area\n                    return that._buildPlaceholderPageData(constrainedPageStart, scrollTop);\n                }\n\n                // Data is available - switch to it\n                if (dataSource.currentRangeStart() !== constrainedPageStart) {\n                    that.mute(() => {\n                        dataSource.range(constrainedPageStart, pageSize);\n                    });\n                    const firstGroupIdx = that._estimateFirstGroupIndex(constrainedPageStart);\n                    that._groupRanges = buildGroupRanges(dataSource, constrainedPageStart, firstGroupIdx, that._groupValueMap);\n                    that._updateGroupCountAndHeight();\n                    that._currentPageStart = constrainedPageStart;\n\n                    // Force re-render since data range changed\n                    const list = that._buildGroupedPageData(constrainedPageStart, scrollTop);\n                    that._renderGroupedPage(list, true, scrollTop);\n                    return list;\n                }\n\n                that._currentPageStart = constrainedPageStart;\n            }\n\n            return that._buildGroupedPageData(constrainedPageStart, scrollTop);\n        },\n\n        /**\n         * Calculates aggregate info about the known initial ranges.\n         * @returns {Object} - { knownPosition, lastKnownIndex, lastKnownGroupIndex, avgGroupHeight, avgItemsPerGroup }\n         */\n        _getKnownRangeInfo: function(initialRanges, itemHeight) {\n            let knownPosition = 0;\n            for (let i = 0; i < initialRanges.length; i++) {\n                const range = initialRanges[i];\n                const headerSlots = (i > 0) ? 1 : 0;\n                knownPosition += (headerSlots + range.itemCount) * itemHeight;\n            }\n\n            const lastRange = initialRanges[initialRanges.length - 1];\n            const lastKnownIndex = lastRange.startIndex + lastRange.itemCount - 1;\n            const lastKnownGroupIndex = initialRanges.length - 1;\n            const avgGroupHeight = knownPosition / initialRanges.length;\n            const avgItemsPerGroup = (lastKnownIndex + 1) / initialRanges.length;\n\n            return { knownPosition, lastKnownIndex, lastKnownGroupIndex, avgGroupHeight, avgItemsPerGroup };\n        },\n\n        /**\n         * Estimates viewport indices when scroll position is beyond known ranges.\n         */\n        _estimateViewportIndicesBeyondKnown: function(scrollTop, viewportEnd, rangeInfo, total) {\n            const { knownPosition, lastKnownGroupIndex, avgGroupHeight, avgItemsPerGroup } = rangeInfo;\n\n            const positionBeyondKnown = scrollTop - knownPosition;\n            const groupsBeyondKnown = Math.floor(positionBeyondKnown / avgGroupHeight);\n            const targetGroupIndex = lastKnownGroupIndex + 1 + groupsBeyondKnown;\n\n            let viewportStartIndex = Math.floor(targetGroupIndex * avgItemsPerGroup);\n            viewportStartIndex = Math.min(viewportStartIndex, total - 1);\n\n            const endPositionBeyondKnown = viewportEnd - knownPosition;\n            const endGroupsBeyondKnown = Math.ceil(endPositionBeyondKnown / avgGroupHeight);\n            const endGroupIndex = lastKnownGroupIndex + 1 + endGroupsBeyondKnown;\n\n            let viewportEndIndex = Math.floor(endGroupIndex * avgItemsPerGroup);\n            viewportEndIndex = Math.min(viewportEndIndex, total - 1);\n\n            return { viewportStartIndex, viewportEndIndex, targetGroupIndex };\n        },\n\n        /**\n         * Finds viewport indices within known ranges using precise calculation.\n         */\n        _findViewportIndicesInKnownRanges: function(scrollTop, viewportEnd, initialRanges, itemHeight, rangeInfo, total) {\n            const { knownPosition, lastKnownGroupIndex, avgGroupHeight, avgItemsPerGroup } = rangeInfo;\n\n            let viewportStartIndex = 0;\n            let viewportEndIndex = 0;\n            let targetGroupIndex = 0;\n            let position = 0;\n\n            for (let i = 0; i < initialRanges.length; i++) {\n                const range = initialRanges[i];\n                const headerSlots = (i > 0) ? 1 : 0;\n                const groupHeight = (headerSlots + range.itemCount) * itemHeight;\n                const groupEnd = position + groupHeight;\n\n                if (scrollTop >= position && scrollTop < groupEnd) {\n                    const posInGroup = scrollTop - position;\n                    const slotsIntoGroup = Math.floor(posInGroup / itemHeight);\n                    const itemsIntoGroup = Math.max(0, slotsIntoGroup - headerSlots);\n                    viewportStartIndex = range.startIndex + Math.min(itemsIntoGroup, range.itemCount - 1);\n                    targetGroupIndex = i;\n                }\n\n                if (viewportEnd >= position && viewportEnd < groupEnd) {\n                    const posInGroup = viewportEnd - position;\n                    const slotsIntoGroup = Math.ceil(posInGroup / itemHeight);\n                    const itemsIntoGroup = Math.max(0, slotsIntoGroup - headerSlots);\n                    viewportEndIndex = range.startIndex + Math.min(itemsIntoGroup, range.itemCount - 1);\n                }\n\n                position += groupHeight;\n            }\n\n            if (viewportEnd >= knownPosition && viewportEndIndex === 0) {\n                const endPositionBeyondKnown = viewportEnd - knownPosition;\n                const endGroupsBeyondKnown = Math.ceil(endPositionBeyondKnown / avgGroupHeight);\n                const endGroupIndex = lastKnownGroupIndex + 1 + endGroupsBeyondKnown;\n                viewportEndIndex = Math.floor(endGroupIndex * avgItemsPerGroup);\n                viewportEndIndex = Math.min(viewportEndIndex, total - 1);\n            }\n\n            return { viewportStartIndex, viewportEndIndex, targetGroupIndex };\n        },\n\n        /**\n         * Calculates page start that centers the page around the viewport.\n         */\n        _calculateCenteredPageStart: function(viewportStartIndex, viewportEndIndex, pageSize, total) {\n            const viewportItemCount = viewportEndIndex - viewportStartIndex + 1;\n            const bufferItems = Math.floor((pageSize - viewportItemCount) / 2);\n            const maxPageStart = Math.max(0, total - pageSize);\n\n            let pageStart = Math.max(0, viewportStartIndex - bufferItems);\n            pageStart = Math.min(pageStart, maxPageStart);\n\n            const pageEnd = pageStart + pageSize - 1;\n            if (viewportEndIndex > pageEnd) {\n                pageStart = Math.min(maxPageStart, viewportEndIndex - pageSize + 1);\n                pageStart = Math.max(0, pageStart);\n            }\n\n            return pageStart;\n        },\n\n        /**\n         * Converts a scroll position to the required data page start.\n         * Returns a pageStart that ensures the visible groups have data loaded.\n         */\n        _scrollPositionToPageInfo: function(scrollTop) {\n            const that = this;\n            const itemHeight = that.options.itemHeight;\n            const pageSize = that.itemCount;\n            const initialRanges = that._initialGroupRanges;\n            const screenHeight = that._screenHeight || 300;\n            const total = that.dataSource.total();\n\n            if (!initialRanges || !initialRanges.length) {\n                const itemIndex = Math.floor(scrollTop / itemHeight);\n                const maxPageStart = Math.max(0, total - pageSize);\n                let pageStart = Math.max(0, itemIndex - Math.floor(pageSize / 2));\n                pageStart = Math.min(pageStart, maxPageStart);\n                return { pageStart, groupIndex: 0 };\n            }\n\n            const rangeInfo = that._getKnownRangeInfo(initialRanges, itemHeight);\n            const viewportEnd = scrollTop + screenHeight;\n\n            let result;\n            if (scrollTop >= rangeInfo.knownPosition) {\n                result = that._estimateViewportIndicesBeyondKnown(scrollTop, viewportEnd, rangeInfo, total);\n            } else {\n                result = that._findViewportIndicesInKnownRanges(scrollTop, viewportEnd, initialRanges, itemHeight, rangeInfo, total);\n            }\n\n            let { viewportStartIndex, viewportEndIndex, targetGroupIndex } = result;\n\n            if (viewportEndIndex === 0 || viewportEndIndex < viewportStartIndex) {\n                viewportEndIndex = Math.min(viewportStartIndex + Math.ceil(screenHeight / itemHeight), total - 1);\n            }\n\n            const pageStart = that._calculateCenteredPageStart(viewportStartIndex, viewportEndIndex, pageSize, total);\n\n            return { pageStart, groupIndex: targetGroupIndex };\n        },\n\n        /**\n         * Updates the total group count and height container based on discovered groups.\n         * Call this after buildGroupRanges to update height if new groups were discovered\n         * or if we've reached the end of data and can determine the exact group count.\n         */\n        _updateGroupCountAndHeight: function() {\n            const that = this;\n            const options = that.options;\n            const dataSource = that.dataSource;\n\n            if (!that._groupValueMap || options.type !== \"group\") {\n                return;\n            }\n\n            const discoveredGroupCount = that._groupValueMap.size;\n            const previousGroupCount = that._totalGroupCount || 0;\n            const total = dataSource.total();\n            const pageSize = that.itemCount;\n            const currentRangeStart = dataSource.currentRangeStart() || 0;\n            const isAtEnd = (currentRangeStart + pageSize) >= total;\n            const itemHeight = that.options.itemHeight;\n\n            // Update height if:\n            // 1. We've discovered more groups than we knew about, OR\n            // 2. We're at the end of data and the discovered count differs from estimated\n            if (discoveredGroupCount > previousGroupCount ||\n                (isAtEnd && discoveredGroupCount !== previousGroupCount)) {\n                that._totalGroupCount = discoveredGroupCount;\n                const totalHeight = getGroupedTotalHeight(total, itemHeight, discoveredGroupCount, that._cssGap);\n                that._setHeight(totalHeight);\n            }\n        },\n\n        /**\n         * Estimates which group index corresponds to a given data startIndex.\n         */\n        _estimateFirstGroupIndex: function(startIndex) {\n            const initialRanges = this._initialGroupRanges;\n            const totalGroups = this._totalGroupCount || 1;\n            const total = this.dataSource.total();\n            const avgGroupSize = total / totalGroups;\n\n            // First check if startIndex falls within the known initial ranges\n            if (initialRanges && initialRanges.length) {\n                const lastRange = initialRanges[initialRanges.length - 1];\n                const lastRangeEnd = lastRange.startIndex + lastRange.itemCount;\n\n                // Only use initial ranges if startIndex is within their bounds\n                if (startIndex < lastRangeEnd) {\n                    for (let i = 0; i < initialRanges.length; i++) {\n                        const range = initialRanges[i];\n                        const rangeEnd = range.startIndex + range.itemCount;\n                        if (startIndex < rangeEnd) {\n                            return i;\n                        }\n                    }\n                }\n            }\n\n            // Fallback: estimate based on average group size\n            // This handles cases where startIndex is beyond the initial ranges\n            return Math.floor(startIndex / avgGroupSize);\n        },\n\n        /**\n         * Builds placeholder data for the loading area.\n         * Creates placeholder items to fill the visible viewport while data is loading.\n         */\n        _buildPlaceholderPageData: function(pageStart, scrollTop) {\n            const that = this;\n            const itemHeight = that.options.itemHeight;\n            const screenHeight = that._screenHeight || 400;\n\n            // Calculate how many placeholder items we need to fill the visible area\n            const visibleItemCount = Math.ceil(screenHeight / itemHeight) + 2; // +2 for buffer\n\n            // Position placeholders starting at the scroll position\n            const startIndex = Math.floor(scrollTop / itemHeight);\n            const placeholderTop = startIndex * itemHeight;\n\n            // Create a single placeholder \"group\" with loading items\n            const items = [];\n            for (let i = 0; i < visibleItemCount; i++) {\n                const itemIndex = startIndex + i;\n                items.push({\n                    item: null, // null indicates placeholder/loading\n                    group: \"Loading...\",\n                    newGroup: i === 0,\n                    selected: false,\n                    current: false,\n                    index: itemIndex,\n                    top: itemIndex * itemHeight,\n                    trueGlobalIndex: itemIndex,\n                    globalGroupIndex: -1, // Special index for placeholder group\n                    localIndex: i,\n                    viewIndex: 0,\n                    isPlaceholder: true\n                });\n            }\n\n            // Use fixed key values for placeholders to prevent constant re-renders\n            // The placeholder itself will update its position dynamically\n            const pageGroups = [{\n                viewIndex: 0,\n                groupValue: \"Loading...\",\n                startIndex: 0, // Use fixed startIndex for caching key\n                actualGlobalStartIndex: startIndex, // Actual position for rendering\n                globalGroupIndex: -1, // Special index for placeholder\n                itemCount: visibleItemCount,\n                fullGroupItemCount: visibleItemCount,\n                hasHeader: false,\n                isPartialGroup: false,\n                top: placeholderTop,\n                height: visibleItemCount * itemHeight,\n                itemsBeforeLoad: 0,\n                isPlaceholder: true\n            }];\n\n            return {\n                pageStart,\n                pageGroups,\n                items,\n                isPlaceholder: true\n            };\n        },\n\n        /**\n         * Builds group info objects for all groups in client-side grouping.\n         */\n        _buildAllClientGroupInfos: function(view, itemHeight, cssGap) {\n            const that = this;\n            const allGroupInfos = [];\n            let globalItemIndex = 0;\n            let cumulativeHeight = 0;\n\n            for (let groupIdx = 0; groupIdx < view.length; groupIdx++) {\n                const viewGroup = view[groupIdx];\n                const groupValue = viewGroup.value;\n                const groupItems = viewGroup.items || [];\n                const groupItemCount = groupItems.length;\n\n                if (groupItemCount === 0) { continue; }\n\n                const hasHeader = groupIdx > 0 || that.options.fixedGroupHeader === false;\n                const groupTop = cumulativeHeight;\n                const elementCount = groupItemCount + (hasHeader ? 1 : 0);\n                const gapsInGroup = Math.max(0, elementCount - 1) * cssGap;\n                const visualHeight = (elementCount * itemHeight) + gapsInGroup;\n                const groupBottom = groupTop + visualHeight;\n\n                allGroupInfos.push({\n                    viewIndex: groupIdx,\n                    groupValue: groupValue,\n                    startIndex: globalItemIndex,\n                    actualGlobalStartIndex: globalItemIndex,\n                    globalGroupIndex: groupIdx,\n                    itemCount: groupItemCount,\n                    fullGroupItemCount: groupItemCount,\n                    hasHeader: hasHeader,\n                    isPartialGroup: false,\n                    top: groupTop,\n                    bottom: groupBottom,\n                    height: visualHeight,\n                    itemsBeforeLoad: 0,\n                    groupItems: groupItems\n                });\n\n                cumulativeHeight += visualHeight;\n                globalItemIndex += groupItemCount;\n            }\n\n            return allGroupInfos;\n        },\n\n        /**\n         * Filters visible groups and builds mapped items for client-side grouping.\n         */\n        _filterVisibleGroupsAndBuildItems: function(allGroupInfos, scrollTop, screenHeight, bufferSize) {\n            const that = this;\n            const visibleTop = Math.max(0, scrollTop - bufferSize);\n            const visibleBottom = scrollTop + screenHeight + bufferSize;\n            const pageGroups = [];\n            const items = [];\n\n            for (const groupInfo of allGroupInfos) {\n                if (groupInfo.bottom >= visibleTop && groupInfo.top <= visibleBottom) {\n                    pageGroups.push(groupInfo);\n\n                    const groupItems = groupInfo.groupItems || [];\n                    for (let j = 0; j < groupInfo.itemCount; j++) {\n                        const dataItem = groupItems[j];\n                        if (!dataItem) { continue; }\n\n                        const itemIndex = groupInfo.startIndex + j;\n                        const mappedItem = that._itemMapper(\n                            { item: dataItem, group: groupInfo.groupValue },\n                            itemIndex,\n                            that._values.slice()\n                        );\n                        mappedItem.trueGlobalIndex = itemIndex;\n                        mappedItem.globalGroupIndex = groupInfo.globalGroupIndex;\n                        mappedItem.localIndex = j;\n                        mappedItem.viewIndex = groupInfo.viewIndex;\n                        items.push(mappedItem);\n                    }\n                }\n\n                delete groupInfo.groupItems;\n            }\n\n            return { pageGroups, items };\n        },\n\n        /**\n         * Builds page data for client-side grouping.\n         */\n        _buildClientGroupedPageData: function(pageStart, scrollTop) {\n            const that = this;\n            const dataSource = that.dataSource;\n            const itemHeight = that.options.itemHeight;\n            const cssGap = that._cssGap || 0;\n\n            const groupDescriptor = dataSource.group();\n            const allData = dataSource.data();\n\n            if (!allData || !allData.length || !groupDescriptor || !groupDescriptor.length) {\n                return { pageStart, pageGroups: [], items: [] };\n            }\n\n            const view = new kendo.data.Query(allData).group(groupDescriptor).data;\n\n            if (!view || !view.length) {\n                return { pageStart, pageGroups: [], items: [] };\n            }\n\n            const screenHeight = that._screenHeight || 400;\n            const bufferSize = screenHeight;\n\n            const allGroupInfos = that._buildAllClientGroupInfos(view, itemHeight, cssGap);\n            const { pageGroups, items } = that._filterVisibleGroupsAndBuildItems(allGroupInfos, scrollTop, screenHeight, bufferSize);\n\n            that._updateFixedHeaderClientGrouped(scrollTop, pageGroups, itemHeight);\n\n            return { pageStart, pageGroups, items };\n        },\n\n        /**\n         * Calculates the header offset for a section based on previous sections.\n         */\n        _calculateSectionHeaderOffset: function(viewIdx, groupRanges, view, pageStart, itemHeight) {\n            const that = this;\n            let headerOffset = 0;\n\n            for (let i = 0; i < viewIdx; i++) {\n                const prevRange = groupRanges[i];\n                const prevViewGroup = view[i];\n\n                if (prevRange && prevViewGroup) {\n                    const prevFirstItemInPage = Math.max(prevRange.startIndex, pageStart);\n                    const prevItemsBeforeLoad = prevFirstItemInPage - prevRange.startIndex;\n                    const prevHasHeader = (i > 0 || that.options.fixedGroupHeader === false) && prevItemsBeforeLoad === 0;\n\n                    if (prevHasHeader) {\n                        headerOffset += itemHeight;\n                    }\n                }\n            }\n\n            return headerOffset;\n        },\n\n        /**\n         * Builds a single server group section info and its items.\n         */\n        _buildServerGroupSection: function(viewIdx, viewGroup, groupRange, pageStart, pageEnd, itemHeight, headerOffset) {\n            const that = this;\n            const groupStartIndex = groupRange.startIndex;\n            const groupEndIndex = groupRange.startIndex + groupRange.itemCount;\n\n            if (groupEndIndex <= pageStart || groupStartIndex >= pageEnd) {\n                return null;\n            }\n\n            const firstItemInPage = Math.max(groupStartIndex, pageStart);\n            const lastItemInPage = Math.min(groupEndIndex, pageEnd);\n            const itemsInPage = lastItemInPage - firstItemInPage;\n\n            const itemOffset = firstItemInPage - groupStartIndex;\n            const viewGroupItems = viewGroup.items || [];\n            const groupItems = viewGroupItems.slice(itemOffset, itemOffset + itemsInPage);\n            const groupItemCount = groupItems.length;\n\n            if (groupItemCount === 0) {\n                return null;\n            }\n\n            const globalStartIndex = firstItemInPage;\n            const globalGroupIndex = groupRange.globalGroupIndex;\n            const sectionTop = globalStartIndex * itemHeight;\n            const itemsBeforeLoad = globalStartIndex - groupRange.startIndex;\n            const isPartialGroup = itemsBeforeLoad > 0;\n            const hasHeader = (viewIdx > 0 || that.options.fixedGroupHeader === false) && !isPartialGroup;\n\n            const groupTop = sectionTop + headerOffset;\n            const groupHeight = (hasHeader ? itemHeight : 0) + (groupItemCount * itemHeight);\n\n            const sectionItems = [];\n            for (let j = 0; j < groupItemCount; j++) {\n                const dataItem = groupItems[j];\n                if (!dataItem) { continue; }\n\n                const globalIndex = globalStartIndex + j;\n                const mappedItem = that._itemMapper(\n                    { item: dataItem, group: viewGroup.value },\n                    globalIndex,\n                    that._values.slice()\n                );\n                mappedItem.viewIndex = viewIdx;\n                mappedItem.globalGroupIndex = globalGroupIndex;\n                mappedItem.localIndex = j;\n                sectionItems.push(mappedItem);\n            }\n\n            const groupInfo = {\n                viewIndex: viewIdx,\n                groupValue: viewGroup.value,\n                startIndex: globalStartIndex,\n                actualGlobalStartIndex: groupRange.startIndex,\n                globalGroupIndex: globalGroupIndex,\n                sectionIndex: viewIdx,\n                itemCount: groupItemCount,\n                fullGroupItemCount: groupRange.itemCount,\n                hasHeader: hasHeader,\n                isPartialGroup: isPartialGroup,\n                top: groupTop,\n                height: groupHeight,\n                itemsBeforeLoad: itemsBeforeLoad\n            };\n\n            return { groupInfo, sectionItems };\n        },\n\n        /**\n         * Builds page data for server-side grouping.\n         */\n        _buildServerGroupedPageData: function(pageStart, scrollTop) {\n            const that = this;\n            const dataSource = that.dataSource;\n            const view = dataSource.view();\n            const groupRanges = that._groupRanges || [];\n            const itemHeight = that.options.itemHeight;\n            const pageSize = that.itemCount;\n            const pageEnd = pageStart + pageSize;\n\n            const pageGroups = [];\n            const items = [];\n\n            for (let viewIdx = 0; viewIdx < view.length; viewIdx++) {\n                const viewGroup = view[viewIdx];\n                const groupRange = groupRanges[viewIdx];\n\n                if (!groupRange) { continue; }\n\n                const headerOffset = that._calculateSectionHeaderOffset(viewIdx, groupRanges, view, pageStart, itemHeight);\n                const result = that._buildServerGroupSection(viewIdx, viewGroup, groupRange, pageStart, pageEnd, itemHeight, headerOffset);\n\n                if (result) {\n                    pageGroups.push(result.groupInfo);\n                    items.push(...result.sectionItems);\n                }\n            }\n\n            that._updateFixedHeader(scrollTop, pageGroups);\n\n            return { pageStart, pageGroups, items };\n        },\n\n        /**\n         * Builds the data structure for the current page.\n         * Delegates to client or server grouping handlers.\n         */\n        _buildGroupedPageData: function(pageStart, scrollTop) {\n            const that = this;\n            const isServerGrouping = that.dataSource.options.serverGrouping;\n\n            if (!isServerGrouping) {\n                return that._buildClientGroupedPageData(pageStart, scrollTop);\n            }\n\n            return that._buildServerGroupedPageData(pageStart, scrollTop);\n        },\n\n        /**\n         * Calculates the absolute pixel position for a group's UL.\n         * Position = (items before * itemHeight) + (headers before * itemHeight)\n         */\n        _calculateGroupTopPosition: function(startIndex, globalGroupIndex, itemHeight) {\n            // Items before this group = startIndex\n            // Headers before this group = max(0, globalGroupIndex - 1)\n            // (First group has no header, so groups 1,2,3... each add one header before the next)\n            const headersBefore = Math.max(0, globalGroupIndex - 1);\n            return (startIndex * itemHeight) + (headersBefore * itemHeight);\n        },\n\n        /**\n         * Updates the sticky header based on current scroll position.\n         */\n        _updateFixedHeader: function(scrollTop, pageGroups) {\n            const that = this;\n\n            if (!pageGroups.length) {return;}\n\n            // Find which group is at the scroll position\n            let currentGroup = null;\n            for (let i = pageGroups.length - 1; i >= 0; i--) {\n                const group = pageGroups[i];\n                if (scrollTop >= group.top) {\n                    currentGroup = group;\n                    break;\n                }\n            }\n\n            if (!currentGroup) {\n                currentGroup = pageGroups[0];\n            }\n\n            if (that.currentVisibleGroup !== currentGroup.groupValue) {\n                that.header.html(that.templates.fixedGroupTemplate(currentGroup.groupValue));\n                that.currentVisibleGroup = currentGroup.groupValue;\n                that._currentVisibleGroupIndex = currentGroup.globalGroupIndex;\n            }\n        },\n\n        /**\n         * Updates the sticky header for client-side grouped lists based on scroll position.\n         * Uses the pageGroups array to find which group is currently visible.\n         * Also hides inline group headers that match the sticky header to avoid duplication.\n         */\n        _updateFixedHeaderClientGrouped: function(scrollTop, pageGroups, itemHeight) {\n            const that = this;\n\n            if (!pageGroups.length) {return;}\n\n            // Find which group is at the scroll position\n            let currentGroup = null;\n            for (let i = pageGroups.length - 1; i >= 0; i--) {\n                const group = pageGroups[i];\n                if (scrollTop >= group.top) {\n                    currentGroup = group;\n                    break;\n                }\n            }\n\n            if (!currentGroup) {\n                currentGroup = pageGroups[0];\n            }\n\n            // Update sticky header if group changed\n            if (that.currentVisibleGroup !== currentGroup.groupValue) {\n                that.header.html(that.templates.fixedGroupTemplate(currentGroup.groupValue));\n                that.currentVisibleGroup = currentGroup.groupValue;\n                that._currentVisibleGroupIndex = currentGroup.globalGroupIndex;\n            }\n        },\n\n        _removeOrphanUls: function(content) {\n            const that = this;\n            const trackedUlSet = new Set(that._groupUls);\n            const domUls = content.querySelectorAll(\"ul[data-group-index]\");\n\n            for (const domUl of domUls) {\n                const groupIndex = parseInt(domUl.getAttribute(\"data-group-index\"), 10);\n                if (groupIndex === -1 || trackedUlSet.has(domUl)) {continue;}\n\n                if (domUl.parentNode) {\n                    domUl.parentNode.removeChild(domUl);\n                }\n            }\n        },\n\n        _buildExistingUlMap: function() {\n            const that = this;\n            const existingMap = new Map();\n            const cleanedGroupUls = [];\n\n            for (const ul of that._groupUls) {\n                const groupIndex = parseInt(ul.getAttribute(\"data-group-index\"), 10);\n                const sectionIndex = parseInt(ul.getAttribute(\"data-section-index\") || \"0\", 10);\n                const groupKey = groupIndex + \"_\" + sectionIndex;\n\n                if (!isNaN(groupIndex)) {\n                    if (existingMap.has(groupKey)) {\n                        if (ul.parentNode) {\n                            ul.parentNode.removeChild(ul);\n                        }\n                    } else {\n                        existingMap.set(groupKey, ul);\n                        cleanedGroupUls.push(ul);\n                    }\n                }\n            }\n\n            that._groupUls = cleanedGroupUls;\n            return existingMap;\n        },\n\n        _processExistingUl: function(existingUl, groupInfo, listItems, force, keptUls, newUls, existingMap) {\n            const that = this;\n            const groupIndex = groupInfo.globalGroupIndex;\n            const sectionIndex = groupInfo.sectionIndex !== undefined ? groupInfo.sectionIndex : 0;\n            const groupKey = groupIndex + \"_\" + sectionIndex;\n\n            const headerSelector = that._isTableVariant() ? \".k-table-group-row\" : \".k-list-group-item\";\n            const existingHasHeader = !!existingUl.querySelector(headerSelector);\n            const headerStatusChanged = existingHasHeader !== groupInfo.hasHeader;\n\n            if (headerStatusChanged) {\n                if (existingUl.parentNode) {\n                    existingUl.parentNode.removeChild(existingUl);\n                }\n                existingMap.delete(groupKey);\n                const newUl = that._createGroupUlElement(groupInfo, listItems);\n                if (sectionIndex > 0) {\n                    newUl.setAttribute(\"data-section-index\", sectionIndex);\n                }\n                newUls.push({ ul: newUl, groupIndex: groupIndex, sectionIndex: sectionIndex, groupKey: groupKey });\n                return;\n            }\n\n            const cachedStartIndex = parseInt(existingUl.getAttribute(\"data-start-index\"), 10);\n            const cachedItemCount = existingUl.querySelectorAll(\"li[data-offset-index]\").length;\n            const startIndexChanged = cachedStartIndex !== groupInfo.startIndex;\n            const itemCountChanged = cachedItemCount !== groupInfo.itemCount;\n\n            if (startIndexChanged || itemCountChanged || force) {\n                that._updateGroupUl(existingUl, groupInfo, listItems);\n                if (startIndexChanged) {\n                    existingUl.setAttribute(\"data-start-index\", groupInfo.startIndex);\n                }\n            }\n\n            const currentTop = existingUl._cachedTop;\n            if (currentTop !== groupInfo.top) {\n                position(existingUl, groupInfo.top);\n                existingUl._cachedTop = groupInfo.top;\n            }\n\n            keptUls.push(existingUl);\n            existingMap.delete(groupKey);\n\n            const items = existingUl.querySelectorAll(\"li[data-offset-index]\");\n            that._items.push(...Array.from(items));\n        },\n\n        _insertNewUlsInOrder: function(content, newUls) {\n            for (const { ul: newUl, sectionIndex: newSectionIndex } of newUls) {\n                let insertBefore = null;\n                const existingUls = content.querySelectorAll(\"ul[data-group-index]\");\n\n                for (const existingUl of existingUls) {\n                    const existingSectionIndex = parseInt(existingUl.getAttribute(\"data-section-index\") || \"0\", 10);\n                    if (existingSectionIndex > newSectionIndex) {\n                        insertBefore = existingUl;\n                        break;\n                    }\n                }\n\n                if (insertBefore) {\n                    content.insertBefore(newUl, insertBefore);\n                } else {\n                    content.appendChild(newUl);\n                }\n            }\n        },\n\n        _renderGroupedPage: function(list, force, targetScrollTop) {\n            const that = this;\n            const content = that.content.get(0);\n            const pageGroups = list.pageGroups || [];\n            const pageStart = list.pageStart;\n            const scrollTop = typeof targetScrollTop === 'number' ? targetScrollTop : content.scrollTop;\n\n            if (list.isPlaceholder) {\n                that._renderPlaceholderPage(list, scrollTop);\n                return;\n            }\n\n            if (that._placeholderUl && that._placeholderUl.parentNode) {\n                that._placeholderUl.parentNode.removeChild(that._placeholderUl);\n                that._placeholderUl = null;\n            }\n\n            that._lastRenderScrollTop = scrollTop;\n            that._removeOrphanUls(content);\n\n            const existingMap = that._buildExistingUlMap();\n            const keptUls = [];\n            const newUls = [];\n            that._items = [];\n\n            for (const groupInfo of pageGroups) {\n                const groupIndex = groupInfo.globalGroupIndex;\n                const sectionIndex = groupInfo.sectionIndex !== undefined ? groupInfo.sectionIndex : 0;\n                const groupKey = groupIndex + \"_\" + sectionIndex;\n                const existingUl = existingMap.get(groupKey);\n\n                if (existingUl) {\n                    that._processExistingUl(existingUl, groupInfo, list.items, force, keptUls, newUls, existingMap);\n                } else {\n                    const newUl = that._createGroupUlElement(groupInfo, list.items);\n                    if (sectionIndex > 0) {\n                        newUl.setAttribute(\"data-section-index\", sectionIndex);\n                    }\n                    newUls.push({ ul: newUl, groupIndex: groupIndex, sectionIndex: sectionIndex, groupKey: groupKey });\n                }\n            }\n\n            for (const ul of existingMap.values()) {\n                if (ul.parentNode) {\n                    ul.parentNode.removeChild(ul);\n                }\n            }\n\n            that._insertNewUlsInOrder(content, newUls);\n            that._groupUls = keptUls.concat(newUls.map(n => n.ul));\n            that._renderedPageStart = pageStart;\n            content.scrollTop = scrollTop;\n            that._dataView = list.items;\n        },\n\n        _calculateCoveredRange: function(visibleTop, visibleBottom, screenHeight) {\n            const that = this;\n            let coveredTop = Infinity;\n            let coveredBottom = 0;\n\n            for (const ul of that._groupUls) {\n                if (!ul || !ul.parentNode) {continue;}\n\n                const transform = ul.style.transform;\n                const yMatch = transform.match(/translateY\\((\\d+)px\\)/);\n                const ulTop = yMatch ? parseFloat(yMatch[1]) : 0;\n                const ulBottom = ulTop + ul.offsetHeight;\n\n                if (ulBottom >= visibleTop - screenHeight && ulTop <= visibleBottom + screenHeight) {\n                    coveredTop = Math.min(coveredTop, ulTop);\n                    coveredBottom = Math.max(coveredBottom, ulBottom);\n                }\n            }\n\n            return { coveredTop, coveredBottom };\n        },\n\n        _calculatePlaceholderPosition: function(visibleTop, visibleBottom, coveredTop, coveredBottom, screenHeight, totalContentHeight) {\n            let placeholderTop = 0;\n            let placeholderHeight = 0;\n\n            if (coveredTop === Infinity) {\n                placeholderTop = Math.max(0, visibleTop);\n                placeholderHeight = screenHeight;\n            } else if (visibleTop < coveredTop) {\n                placeholderTop = Math.max(0, visibleTop);\n                placeholderHeight = coveredTop - placeholderTop;\n            } else if (visibleBottom > coveredBottom && coveredBottom < totalContentHeight) {\n                placeholderTop = coveredBottom;\n                placeholderHeight = Math.min(visibleBottom, totalContentHeight) - coveredBottom;\n            }\n\n            return { placeholderTop, placeholderHeight };\n        },\n\n        _ensurePlaceholderUl: function(content) {\n            const that = this;\n\n            if (!that._placeholderUl) {\n                const ul = document.createElement(\"ul\");\n                const ulClass = that._isTableVariant() ? `${LIST_UL} ${TABLE}` : LIST_UL;\n                ul.className = ulClass + \" k-loading-placeholder\";\n                ul.style.position = \"absolute\";\n                ul.style.width = \"100%\";\n                ul.style.top = \"0\";\n                ul.style.left = \"0\";\n                ul.setAttribute(\"role\", \"group\");\n                ul.setAttribute(\"data-group-index\", \"-1\");\n\n                if (that.options.ariaLive) {\n                    ul.setAttribute(\"aria-live\", that.options.ariaLive);\n                }\n\n                that._placeholderUl = ul;\n                content.appendChild(ul);\n            }\n\n            return that._placeholderUl;\n        },\n\n        _updatePlaceholderItems: function(ul, placeholderItemCount) {\n            const that = this;\n            const templates = that.templates;\n            let currentCount = ul.querySelectorAll(\"li.k-list-item\").length;\n\n            while (currentCount < placeholderItemCount) {\n                const li = that._createItemLi();\n                li.classList.add(\"k-loading-item\");\n                const textSpan = li.querySelector(\".k-list-item-text\");\n                if (textSpan) {\n                    textSpan.innerHTML = templates.placeholderTemplate({});\n                }\n                ul.appendChild(li);\n                currentCount++;\n            }\n\n            while (ul.children.length > placeholderItemCount) {\n                ul.removeChild(ul.lastChild);\n            }\n        },\n\n        _renderPlaceholderPage: function(list, scrollTop) {\n            const that = this;\n            const content = that.content.get(0);\n            const itemHeight = that.options.itemHeight;\n            const screenHeight = that._screenHeight || 400;\n            const total = that.dataSource.total();\n\n            const groupCount = that._totalGroupCount || 1;\n            const totalContentHeight = getGroupedTotalHeight(total, itemHeight, groupCount, that._cssGap);\n\n            const visibleTop = scrollTop;\n            const visibleBottom = Math.min(scrollTop + screenHeight, totalContentHeight);\n\n            const { coveredTop, coveredBottom } = that._calculateCoveredRange(visibleTop, visibleBottom, screenHeight);\n            const { placeholderTop, placeholderHeight } = that._calculatePlaceholderPosition(\n                visibleTop, visibleBottom, coveredTop, coveredBottom, screenHeight, totalContentHeight\n            );\n\n            if (placeholderHeight <= 0) {\n                if (that._placeholderUl && that._placeholderUl.parentNode) {\n                    that._placeholderUl.style.display = \"none\";\n                }\n                return;\n            }\n\n            const placeholderItemCount = Math.ceil(placeholderHeight / itemHeight) + 1;\n            const ul = that._ensurePlaceholderUl(content);\n\n            ul.style.display = \"\";\n            position(ul, placeholderTop);\n\n            that._updatePlaceholderItems(ul, placeholderItemCount);\n            that.header.html(that.templates.fixedGroupTemplate(\"Loading...\"));\n        },\n\n        /**\n         * Creates a group UL element with all its items (does not add to DOM).\n         */\n        _createGroupUlElement: function(groupInfo, allItems) {\n            const that = this;\n            const templates = that.templates;\n\n            // Get items for this group/section\n            // For server paging, we may have multiple sections with the same globalGroupIndex\n            // Use viewIndex if available (set by _buildGroupedPageData for server grouping)\n            let groupItems;\n            if (groupInfo.sectionIndex !== undefined) {\n                // Server paging: filter by viewIndex (which equals sectionIndex)\n                groupItems = allItems.filter(item => item.viewIndex === groupInfo.sectionIndex);\n            } else {\n                // Client-side grouping: filter by globalGroupIndex\n                groupItems = allItems.filter(item => item.globalGroupIndex === groupInfo.globalGroupIndex);\n            }\n\n            // Get first data item for group icon\n            const firstDataItem = groupItems.length > 0 ? groupItems[0].item : null;\n\n            // Create the group UL container\n            const groupContainer = that._createGroupUl(groupInfo.hasHeader, groupInfo.groupValue, groupInfo.globalGroupIndex, firstDataItem);\n\n            // Update header content if present\n            if (groupContainer.header) {\n                const headerText = groupContainer.header.querySelector(that._getHeaderTextSelector());\n                if (headerText) {\n                    headerText.innerHTML = templates.groupTemplate(groupInfo.groupValue);\n                }\n            }\n\n            // Add and render items\n            that._addGroupItems(groupContainer, groupItems.length);\n\n            for (let i = 0; i < groupItems.length; i++) {\n                that._renderGroupItem(groupContainer.items[i], groupItems[i], templates);\n            }\n\n            // Position the UL\n            position(groupContainer.ul, groupInfo.top);\n            groupContainer.ul.setAttribute(\"data-group-index\", groupInfo.globalGroupIndex);\n            groupContainer.ul.setAttribute(\"data-start-index\", groupInfo.startIndex);\n            groupContainer.ul._cachedTop = groupInfo.top;\n\n            // Track items\n            that._items.push(...groupContainer.items);\n\n            return groupContainer.ul;\n        },\n\n        /**\n         * Updates an existing group UL with new items.\n         */\n        _updateGroupUl: function(ul, groupInfo, allItems) {\n            const that = this;\n            const templates = that.templates;\n            const globalGroupIndex = groupInfo.globalGroupIndex;\n\n            // Get items for this group/section\n            // For server paging, we may have multiple sections with the same globalGroupIndex\n            let groupItems;\n            if (groupInfo.sectionIndex !== undefined) {\n                // Server paging: filter by viewIndex (which equals sectionIndex)\n                groupItems = allItems.filter(item => item.viewIndex === groupInfo.sectionIndex);\n            } else {\n                // Client-side grouping: filter by globalGroupIndex\n                groupItems = allItems.filter(item => item.globalGroupIndex === globalGroupIndex);\n            }\n\n            // Get existing item LIs (exclude header)\n            const existingItems = Array.from(ul.querySelectorAll(\"li[data-offset-index]\"));\n\n            // First, remove extra LIs if we have fewer items now\n            while (existingItems.length > groupItems.length) {\n                const li = existingItems.pop();\n                if (li && li.parentNode) {\n                    li.parentNode.removeChild(li);\n                }\n            }\n\n            // Update existing items or add new ones as needed\n            for (let i = 0; i < groupItems.length; i++) {\n                const itemData = groupItems[i];\n                let li = existingItems[i];\n\n                if (!li) {\n                    // Need to add a new LI\n                    li = that._createItemLi();\n                    ul.appendChild(li);\n                }\n\n                that._renderGroupItem(li, itemData, templates);\n            }\n        },\n\n        /**\n         * Creates a single item LI element.\n         */\n        _createItemLi: function() {\n            const that = this;\n            const itemHeight = that._getItemHeightStyle();\n            const hasColumns = that._isTableVariant();\n            const itemClass = that._getItemClass();\n\n            const li = document.createElement(\"li\");\n            li.setAttribute(\"tabindex\", \"-1\");\n            li.setAttribute(\"role\", \"option\");\n            li.className = itemClass;\n            li.style.height = itemHeight;\n            li.style.minHeight = itemHeight;\n            li.style.position = \"relative\";\n            li.style.transform = \"none\";\n\n            if (!hasColumns) {\n                const textSpan = document.createElement(\"span\");\n                textSpan.className = \"k-list-item-text\";\n                li.appendChild(textSpan);\n            }\n\n            return li;\n        },\n\n        /**\n         * Removes all group ULs from the DOM.\n         */\n        _clearAllGroupUls: function() {\n            const that = this;\n\n            for (const ul of that._groupUls) {\n                if (ul && ul.parentNode) {\n                    ul.parentNode.removeChild(ul);\n                }\n            }\n\n            that._groupUls = [];\n            that._items = [];\n        },\n\n        /**\n         * Creates and renders a single group UL with all its items.\n         */\n        _createAndRenderGroupUl: function(groupInfo, allItems) {\n            const that = this;\n            const content = that.content.get(0);\n            const templates = that.templates;\n\n            // Get items for this group\n            const groupItems = allItems.filter(item => item.globalGroupIndex === groupInfo.globalGroupIndex);\n\n            // Create the group UL container\n            const groupContainer = that._createGroupUl(groupInfo.hasHeader, groupInfo.groupValue, groupInfo.globalGroupIndex);\n\n            // Update header content if present\n            if (groupContainer.header) {\n                const headerText = groupContainer.header.querySelector(that._getHeaderTextSelector());\n                if (headerText) {\n                    headerText.innerHTML = templates.groupTemplate(groupInfo.groupValue);\n                }\n            }\n\n            // Add and render items\n            that._addGroupItems(groupContainer, groupItems.length);\n\n            for (let i = 0; i < groupItems.length; i++) {\n                that._renderGroupItem(groupContainer.items[i], groupItems[i], templates);\n            }\n\n            // Position the UL\n            position(groupContainer.ul, groupInfo.top);\n            groupContainer.ul.setAttribute(\"data-group-index\", groupInfo.globalGroupIndex);\n            groupContainer.ul.setAttribute(\"data-start-index\", groupInfo.startIndex);\n            groupContainer.ul._cachedTop = groupInfo.top;\n\n            // Add to DOM and track\n            content.appendChild(groupContainer.ul);\n            that._groupUls.push(groupContainer.ul);\n            that._items.push(...groupContainer.items);\n        },\n\n        /**\n         * PAGE-BASED: Renders or updates a single group UL.\n         * Creates new UL if not cached, or updates existing one.\n         */\n        _renderGroupUlPaged: function(groupInfo, allItems) {\n            const that = this;\n            const content = that.content.get(0);\n            const templates = that.templates;\n            const viewIndex = groupInfo.viewIndex;\n\n            // Get items for this group from allItems\n            const groupItems = allItems.filter(item => item.viewIndex === viewIndex);\n            const cached = that._groupUlCache[viewIndex];\n\n            if (!cached) {\n                // Create new group UL\n                const groupContainer = that._createGroupUl(groupInfo.hasHeader, groupInfo.groupValue, groupInfo.viewIndex);\n\n                // Update header content if present\n                if (groupContainer.header) {\n                    const headerText = groupContainer.header.querySelector(that._getHeaderTextSelector());\n                    if (headerText) {\n                        headerText.innerHTML = templates.groupTemplate(groupInfo.groupValue);\n                    }\n                }\n\n                // Add item elements for visible items in this group\n                that._addGroupItems(groupContainer, groupItems.length);\n\n                // Render item content\n                for (let i = 0; i < groupItems.length; i++) {\n                    that._renderGroupItem(groupContainer.items[i], groupItems[i], templates);\n                }\n\n                // Position the UL\n                position(groupContainer.ul, groupInfo.top);\n                groupContainer.ul.setAttribute(\"data-view-index\", viewIndex);\n                groupContainer.ul.setAttribute(\"data-start-index\", groupInfo.startIndex);\n                groupContainer.startIndex = groupInfo.startIndex;\n                groupContainer.itemCount = groupItems.length;\n                groupContainer.top = groupInfo.top;\n                groupContainer.viewIndex = viewIndex;\n\n                content.appendChild(groupContainer.ul);\n                that._groupUlCache[viewIndex] = groupContainer;\n\n                // Track items\n                that._items.push(...groupContainer.items);\n            } else {\n                // Update existing UL - only update position and item content\n                const newTop = groupInfo.top;\n                position(cached.ul, newTop);\n                cached.top = newTop;\n\n                // Update item content\n                for (let k = 0; k < groupItems.length; k++) {\n                    const li = cached.items[k];\n                    if (li) {\n                        const itemData = groupItems[k];\n                        that._renderGroupItem(li, itemData, templates);\n                        li.style.display = \"\";\n                    }\n                }\n            }\n        },\n\n        /**\n         * Reorders group ULs in the DOM to match the expected order.\n         */\n        _reorderGroupUls: function(content, pageGroups) {\n            // Get current UL order\n            const currentUls = Array.from(content.querySelectorAll(\".\" + LIST_UL));\n\n            // Check if reordering is needed\n            let needsReorder = false;\n            let lastIndex = -1;\n            for (const ul of currentUls) {\n                const idx = parseInt(ul.getAttribute(\"data-view-index\"), 10);\n                if (idx < lastIndex) {\n                    needsReorder = true;\n                    break;\n                }\n                lastIndex = idx;\n            }\n\n            if (needsReorder) {\n                // Sort ULs by view index\n                const sortedUls = currentUls.sort((a, b) =>\n                    parseInt(a.getAttribute(\"data-view-index\"), 10) - parseInt(b.getAttribute(\"data-view-index\"), 10)\n                );\n\n                // Reinsert in correct order\n                for (const ul of sortedUls) {\n                    content.appendChild(ul);\n                }\n            }\n        },\n\n        /**\n         * Finds the first visible item based on scroll position\n         */\n        _findFirstVisibleItem: function(items, scrollTop, pageGroups) {\n            const itemHeight = this.options.itemHeight;\n\n            // Find which group is visible at scrollTop\n            if (pageGroups) {\n                for (let i = 0; i < pageGroups.length; i++) {\n                    const group = pageGroups[i];\n                    const groupBottom = group.top + (group.hasHeader ? itemHeight : 0) + (group.itemCount * itemHeight);\n                    if (scrollTop < groupBottom) {\n                        // This group is visible, find item in this group\n                        const groupItems = items.filter(item => item.viewIndex === group.viewIndex);\n                        return groupItems[0] || items[0];\n                    }\n                }\n            }\n\n            return items[0];\n        },\n\n        /**\n         * Renders a single item in a group\n         */\n        _renderGroupItem: function(element, data, templates) {\n            const that = this;\n            const options = that.options;\n            const $element = $(element);\n            const itemTemplate = data.item ? templates.template : templates.placeholderTemplate;\n            const hasColumns = options.columns?.length;\n            const dataItem = data.item;\n\n            $element\n                .attr(\"data-uid\", dataItem ? dataItem.uid : \"\")\n                .attr(\"data-offset-index\", data.index);\n\n            // Handle table variant with columns\n            if (hasColumns && dataItem) {\n                // Render column cells\n                const renderedColumns = $(renderColumns(options, dataItem, templates));\n                kendo.applyStylesFromKendoAttributes(renderedColumns, [\"width\", \"max-width\"]);\n                $element.empty().append(renderedColumns);\n\n                // Handle alternating rows\n                const altRow = data.index % 2 === 1;\n                $element.toggleClass(\"k-table-alt-row\", altRow);\n            } else if (hasColumns && !dataItem) {\n                // Placeholder for table variant - show empty cells\n                let placeholderHtml = '';\n                for (let i = 0; i < options.columns.length; i++) {\n                    const currentWidth = options.columns[i].width;\n                    const currentWidthInt = parseInt(currentWidth, 10);\n                    let widthStyle = '';\n                    if (currentWidth) {\n                        const widthValue = currentWidthInt + 'px';\n                        widthStyle = `${kendo.attr(\"style-width\")}=\"${widthValue}\" ${kendo.attr(\"style-max-width\")}=\"${widthValue}\"`;\n                    }\n                    placeholderHtml += `<span class='k-table-td' ${widthStyle}></span>`;\n                }\n                const renderedPlaceholder = $(placeholderHtml);\n                kendo.applyStylesFromKendoAttributes(renderedPlaceholder, [\"width\", \"max-width\"]);\n                $element.empty().append(renderedPlaceholder);\n            } else {\n                // Non-table variant - use k-list-item-text\n                const textSpan = $element.find(\".k-list-item-text\");\n                textSpan.html(itemTemplate(dataItem || {}));\n            }\n\n            $element.toggleClass(FOCUSED, data.current);\n            $element.toggleClass(SELECTED, data.selected);\n            $element.toggleClass(\"k-loading-item\", !dataItem);\n\n            element.style.display = \"\";\n        },\n\n        /**\n         * Creates a grouped data getter\n         */\n        _groupedGetter: function(callback) {\n            const that = this;\n            const dataSource = that.dataSource;\n            const pageSize = that.itemCount;\n            let lastRequestedRange = null;\n            let lastRangeStart = dataSource.skip();\n\n            if (dataSource.pageSize() < pageSize) {\n                that.mute(() => {\n                    dataSource.pageSize(pageSize);\n                });\n            }\n\n            return function(index, rangeStart) {\n                if (!dataSource.inRange(rangeStart, pageSize)) {\n                    if (lastRequestedRange !== rangeStart) {\n                        lastRequestedRange = rangeStart;\n                        lastRangeStart = rangeStart;\n\n                        if (that._getterDeferred) {\n                            that._getterDeferred.reject();\n                        }\n\n                        that._getterDeferred = that.deferredRange(rangeStart);\n                        that._getterDeferred.then(() => {\n                            that._getterDeferred = null;\n                            const firstGroupIdx = that._estimateFirstGroupIndex(rangeStart);\n                            that._groupRanges = buildGroupRanges(dataSource, rangeStart, firstGroupIdx, that._groupValueMap);\n                            that._updateGroupCountAndHeight();\n                            callback();\n                        });\n                    }\n\n                    return null;\n                } else {\n                    if (lastRangeStart !== rangeStart) {\n                        that.mute(() => {\n                            dataSource.range(rangeStart, pageSize);\n                            lastRangeStart = rangeStart;\n                        });\n                        const firstGroupIdx = that._estimateFirstGroupIndex(rangeStart);\n                        that._groupRanges = buildGroupRanges(dataSource, rangeStart, firstGroupIdx, that._groupValueMap);\n                        that._updateGroupCountAndHeight();\n                    }\n\n                    const view = dataSource.view();\n                    const flatIndex = index - rangeStart;\n                    let currentIndex = 0;\n\n                    for (const group of view) {\n                        const groupItems = group.items || [];\n                        if (flatIndex < currentIndex + groupItems.length) {\n                            return {\n                                item: groupItems[flatIndex - currentIndex],\n                                group: group.value\n                            };\n                        }\n                        currentIndex += groupItems.length;\n                    }\n\n                    return null;\n                }\n            };\n        },\n\n        _setHeight: function(height) {\n            let heightContainer = this.heightContainer;\n            let currentHeight;\n\n            if (!heightContainer) {\n                heightContainer = this.heightContainer = appendChild(this.content[0], HEIGHTCONTAINER);\n            } else {\n                currentHeight = heightContainer.offsetHeight;\n            }\n\n            if (height !== currentHeight) {\n                heightContainer.innerHTML = \"\";\n\n                while (height > 0) {\n                    const padHeight = Math.min(height, 250000); //IE workaround, should not create elements with height larger than 250000px\n                    appendChild(heightContainer).style.height = padHeight + \"px\";\n                    height -= padHeight;\n                }\n            }\n        },\n\n        _getter: function() {\n            const dataSource = this.dataSource;\n            const type = this.options.type;\n            const pageSize = this.itemCount;\n            const flatGroups = {};\n            let lastRequestedRange = null;\n            let lastRangeStart = dataSource.skip();\n\n            if (dataSource.pageSize() < pageSize) {\n                this.mute(function() {\n                    dataSource.pageSize(pageSize);\n                });\n            }\n\n            return function(index, rangeStart) {\n                const that = this;\n                if (!dataSource.inRange(rangeStart, pageSize)) {\n                    if (lastRequestedRange !== rangeStart) {\n                        lastRequestedRange = rangeStart;\n                        lastRangeStart = rangeStart;\n\n                        if (that._getterDeferred) {\n                            that._getterDeferred.reject();\n                        }\n\n                        that._getterDeferred = that.deferredRange(rangeStart);\n                        that._getterDeferred.then(() => {\n                            const firstItemIndex = that._indexConstraint(that.content[0].scrollTop);\n\n                            that._getterDeferred = null;\n\n                            if (rangeStart <= firstItemIndex && firstItemIndex <= (rangeStart + pageSize)) {\n                                that._fetching = true;\n                                dataSource.range(rangeStart, pageSize);\n                            }\n                        });\n                    }\n\n                    return null;\n                } else {\n                    if (lastRangeStart !== rangeStart) {\n                        this.mute(() => {\n                            dataSource.range(rangeStart, pageSize);\n                            lastRangeStart = rangeStart;\n                        });\n                    }\n\n                    let result;\n                    if (type === \"group\") { //grouped list\n                        if (!flatGroups[rangeStart]) {\n                            const flatGroup = flatGroups[rangeStart] = [];\n                            const groups = dataSource.view();\n                            for (const group of groups) {\n                                for (const item of group.items) {\n                                    flatGroup.push({ item, group: group.value });\n                                }\n                            }\n                        }\n\n                        result = flatGroups[rangeStart][index - rangeStart];\n                    } else { //flat list\n                        result = dataSource.view()[index - rangeStart];\n                    }\n\n                    return result;\n                }\n            };\n        },\n\n        _fixedHeader: function(scrollTop, list) {\n            const group = this.currentVisibleGroup;\n            const itemHeight = this.options.itemHeight;\n            const listItems = list.items || [];\n            const firstVisibleDataItemIndex = Math.floor((scrollTop - list.top) / itemHeight);\n            const firstVisibleDataItem = listItems[firstVisibleDataItemIndex];\n\n            if (firstVisibleDataItem?.item) {\n                const firstVisibleGroup = firstVisibleDataItem.group;\n\n                if (firstVisibleGroup !== group) {\n                    const fixedGroupText = firstVisibleGroup || \"\";\n                    this.header.html(this.templates.fixedGroupTemplate(fixedGroupText));\n                    this.currentVisibleGroup = firstVisibleGroup;\n                }\n            }\n\n            return list;\n        },\n\n        _itemMapper: function(item, index, value) {\n            const listType = this.options.type;\n            const itemHeight = this.options.itemHeight;\n            const cssGap = this._cssGap || 0;\n            const currentIndex = this._focusedIndex;\n            const valueGetter = this._valueGetter;\n            let selected = false;\n            let current = false;\n            let newGroup = false;\n            let group = null;\n\n            if (listType === \"group\") {\n                if (item) {\n                    newGroup = index === 0 || (this._currentGroup !== false && this._currentGroup !== item.group);\n                    this._currentGroup = item.group;\n                }\n\n                group = item ? item.group : null;\n                item = item ? item.item : null;\n            }\n\n            if (this.options.mapValueTo === \"dataItem\" && this._selectedDataItems.length && item) {\n                for (let i = 0; i < this._selectedDataItems.length; i++) {\n                    if (valueGetter(this._selectedDataItems[i]) === valueGetter(item)) {\n                        selected = true;\n                        break;\n                    }\n                }\n            } else if (!this.isFiltered() && value.length && item) {\n                for (let j = 0; j < value.length; j++) {\n                    const match = isPrimitive(item) ? value[j] === item : value[j] === valueGetter(item);\n                    if (match) {\n                        value.splice(j , 1);\n                        selected = true;\n                        break;\n                    }\n                }\n            }\n\n            if (currentIndex === index) {\n                current = true;\n            }\n\n            return {\n                item: item ? item : null,\n                group,\n                newGroup,\n                selected,\n                current,\n                index,\n                top: index * (itemHeight + cssGap)\n            };\n        },\n\n        _range: function(index) {\n            const itemCount = this.itemCount;\n            const value = this._values.slice();\n            const items = [];\n\n            this._view = {};\n            this._currentGroup = false;\n\n            for (let i = index, length = index + itemCount; i < length; i++) {\n                const item = this._itemMapper(this.getter(i, index), i, value);\n                if (items[items.length - 1]) {\n                    items[items.length - 1].isLastGroupedItem = item.newGroup;\n                }\n                items.push(item);\n                this._view[item.index] = item;\n            }\n\n            this._dataView = items;\n            return items;\n        },\n\n        _getDataItemsCollection: function(scrollTop, lastScrollTop) {\n            const items = this._range(this._listIndex(scrollTop, lastScrollTop));\n            return {\n                index: items.length ? items[0].index : 0,\n                top: items.length ? items[0].top : 0,\n                items\n            };\n        },\n\n        _listItems: function() {\n            const screenHeight = this._screenHeight;\n            const options = this.options;\n            const theValidator = listValidator(options, screenHeight);\n\n            return function(value, force) {\n                let result = this.result;\n                const lastScrollTop = this._lastScrollTop;\n\n                if (force || !result || !theValidator(result, value, lastScrollTop)) {\n                    result = this._getDataItemsCollection(value, lastScrollTop);\n                }\n\n                this._lastScrollTop = value;\n                this.result = result;\n\n                return result;\n            }.bind(this);\n        },\n\n        _whenChanged: function(getter, callback) {\n            let current;\n\n            return (force) => {\n                const theNew = getter(force);\n\n                if (theNew !== current) {\n                    current = theNew;\n                    callback(theNew, force);\n                }\n            };\n        },\n\n        /**\n         * Smart change detection for grouped mode.\n         * Only triggers callback when the page content actually changes.\n         */\n        _whenChangedGrouped: function(getter, callback) {\n            let currentPageStart = null;\n            let currentGroupKeys = null;\n\n            return (force) => {\n                const theNew = getter(force);\n\n                if (!theNew) {return;}\n\n                // Check if page content has changed by comparing:\n                // 1. pageStart\n                // 2. The set of group globalGroupIndices and their startIndices\n                const newPageStart = theNew.pageStart;\n                const newGroups = theNew.pageGroups || [];\n\n                // Build a key that represents the current page content\n                const newGroupKeys = newGroups.map(g =>\n                    `${g.globalGroupIndex}:${g.startIndex}:${g.itemCount}`\n                ).join(',');\n\n                const pageChanged = currentPageStart !== newPageStart;\n                const groupsChanged = currentGroupKeys !== newGroupKeys;\n\n                if (force || pageChanged || groupsChanged) {\n                    currentPageStart = newPageStart;\n                    currentGroupKeys = newGroupKeys;\n                    callback(theNew, force);\n                }\n            };\n        },\n\n        _reorderList: function(list, reorder) {\n            const that = this;\n            const length = list.length;\n            let currentOffset = -Infinity;\n            reorder = map2(reorder, this.templates).bind(this);\n\n            return function(list2, offset, force) {\n                const diff = offset - currentOffset;\n                let range, range2;\n\n                if (force || Math.abs(diff) >= length) { // full reorder\n                    range = list;\n                    range2 = list2;\n                } else { // partial reorder\n                    range = reshift(list, diff);\n                    range2 = diff > 0 ? list2.slice(-diff) : list2.slice(0, -diff);\n                }\n\n                reorder(range, range2, that.bound());\n\n                currentOffset = offset;\n            };\n        },\n\n        _bufferSizes: function() {\n            const options = this.options;\n\n            return bufferSizes(this._screenHeight, options.listScreens, options.oppositeBuffer);\n        },\n\n        _indexConstraint: function(position) {\n            const itemCount = this.itemCount;\n            const itemHeight = this.options.itemHeight;\n            const cssGap = this._cssGap || 0;\n            const effectiveItemHeight = itemHeight + cssGap;\n            const total = this.dataSource.total();\n\n            return Math.min(Math.max(total - itemCount, 0), Math.max(0, Math.floor(position / effectiveItemHeight)));\n        },\n\n        _listIndex: function(scrollTop, lastScrollTop) {\n            const buffers = this._bufferSizes();\n            const position = scrollTop - ((scrollTop > lastScrollTop) ? buffers.down : buffers.up);\n\n            return this._indexConstraint(position);\n        },\n\n        _selectable: function() {\n            if (this.options.selectable) {\n                this._selectProxy = this._clickHandler.bind(this);\n                this.element.on(CLICK + VIRTUAL_LIST_NS, \".\" + this._getItemClass(), this._selectProxy);\n            }\n        },\n\n        getElementIndex: function(element) {\n            if (!(element instanceof jQuery)) {\n                return undefined;\n            }\n\n            return parseInt(element.attr(\"data-offset-index\"), 10);\n        },\n\n        _getIndecies: function(candidate) {\n            let result = [];\n\n            if (typeof candidate === \"function\") {\n                const data = this.dataSource.flatView();\n                for (let idx = 0; idx < data.length; idx++) {\n                    if (candidate(data[idx])) {\n                        result.push(idx);\n                        break;\n                    }\n                }\n            }\n\n            if (typeof candidate === \"number\") {\n                result.push(candidate);\n            }\n\n            const elementIndex = this.getElementIndex(candidate);\n            if (!isNaN(elementIndex)) {\n                result.push(elementIndex);\n            }\n\n            if (candidate instanceof Array) {\n                result = candidate;\n            }\n\n            return result;\n        },\n\n        _deselect: function(indices) {\n            const selectedIndexes = this._selectedIndexes;\n            const selectedDataItems = this._selectedDataItems;\n            const selectable = this.options.selectable;\n            const valueGetter = this._valueGetter;\n            const removed = [];\n            let position = 0;\n            let removedindexesCounter = 0;\n\n            indices = indices.slice();\n\n            if (selectable === true || !indices.length) { //deselect everything\n                for (let idx = 0; idx < selectedIndexes.length; idx++) {\n                    if (selectedIndexes[idx] !== undefined) {\n                        this._getElementByIndex(selectedIndexes[idx]).removeClass(SELECTED);\n                    } else if (selectedDataItems[idx]) {\n                        this._getElementByDataItem(selectedDataItems[idx]).removeClass(SELECTED);\n                    }\n\n                    removed.push({\n                        index: selectedIndexes[idx],\n                        position: idx,\n                        dataItem: selectedDataItems[idx]\n                    });\n                }\n\n                this._values = [];\n                this._selectedDataItems = [];\n                this._selectedIndexes = [];\n            } else if (selectable === \"multiple\") {\n                let i = 0;\n                while (i < indices.length) {\n                    let result = null;\n                    position = $.inArray(indices[i], selectedIndexes);\n                    const dataItem = this.dataItemByIndex(indices[i]);\n\n                    if (position === -1 && dataItem) {\n                        for (let j = 0; j < selectedDataItems.length; j++) {\n                            const match = isPrimitive(dataItem) ? selectedDataItems[j] === dataItem : valueGetter(selectedDataItems[j]) === valueGetter(dataItem);\n                            if (match) {\n                                const item = this._getElementByIndex(indices[i]);\n                                result = this._deselectSingleItem(item, j, indices[i], removedindexesCounter);\n                            }\n                        }\n                    } else {\n                        const selectedIndex = selectedIndexes[position];\n\n                        if (selectedIndex !== undefined) {\n                            const item = this._getElementByIndex(selectedIndex);\n                            result = this._deselectSingleItem(item, position, selectedIndex, removedindexesCounter);\n                        }\n                    }\n\n                    if (result) {\n                        indices.splice(i, 1);\n                        removed.push(result);\n\n                        removedindexesCounter++;\n                        i--;\n                    }\n                    i++;\n                }\n            }\n\n            return { indices, removed };\n        },\n\n        _deselectSingleItem: function(item, position, selectedIndex, removedindexesCounter) {\n            if (!item.hasClass(SELECTED)) {\n                return;\n            }\n\n            item.removeClass(SELECTED);\n            this._values.splice(position, 1);\n            this._selectedIndexes.splice(position, 1);\n            const dataItem = this._selectedDataItems.splice(position, 1)[0];\n\n            return {\n                index: selectedIndex,\n                position: position + removedindexesCounter,\n                dataItem\n            };\n        },\n\n        _deselectCurrentValues: function(indices) {\n            const items = this._items || [];\n            const values = this._values;\n            const removed = [];\n\n            if (this.options.selectable !== \"multiple\" || !this.isFiltered()) {\n                return [];\n            }\n\n            if (indices[0] === -1) {\n                $(items).removeClass(SELECTED);\n                const removedItems = $.map(this._selectedDataItems.slice(0), (dataItem, idx) => ({\n                    dataItem,\n                    position: idx\n                }));\n                this._selectedIndexes = [];\n                this._selectedDataItems = [];\n                this._values = [];\n                return removedItems;\n            }\n\n            for (let idx = 0; idx < indices.length; idx++) {\n                let position = -1;\n                const index = indices[idx];\n                let value;\n                if (this.dataItemByIndex(index)) {\n                    value = this._valueGetter(this.dataItemByIndex(index));\n                }\n\n                for (let j = 0; j < values.length; j++) {\n                    if (value == values[j]) {\n                        position = j;\n                        break;\n                    }\n                }\n\n                if (position > -1) {\n                    removed.push(this.removeAt(position));\n                    $(items[index]).removeClass(SELECTED);\n                }\n            }\n\n            return removed;\n        },\n\n        _getSkip: function(index, take) {\n            const page = index < take ? 1 : Math.floor(index / take) + 1;\n\n            return (page - 1) * take;\n        },\n\n        _select: function(indexes) {\n            const that = this;\n            const singleSelection = this.options.selectable !== \"multiple\";\n            const dataSource = this.dataSource;\n            const take = this.itemCount;\n            const valueGetter = this._valueGetter;\n            const added = [];\n\n            if (singleSelection) {\n                that._selectedIndexes = [];\n                that._selectedDataItems = [];\n                that._values = [];\n            }\n\n            const oldSkip = dataSource.skip();\n\n            $.each(indexes, (_, index) => {\n                const skip = that._getSkip(index, take);\n\n                that.mute(() => {\n                    dataSource.range(skip, take); //switch the range to get the dataItem\n\n                    const dataItem = that._findDataItem(dataSource.view(), [index - skip]);\n                    that._selectedIndexes.push(index);\n                    that._selectedDataItems.push(dataItem);\n                    that._values.push(isPrimitive(dataItem) ? dataItem : valueGetter(dataItem));\n\n                    added.push({ index, dataItem });\n\n                    that._getElementByIndex(index).addClass(SELECTED);\n\n                    dataSource.range(oldSkip, take); //switch back the range\n                });\n            });\n\n            that._values = that._checkValuesOrder(that._values);\n\n            return added;\n        },\n\n        _clickHandler: function(e) {\n            const that = this;\n            const item = $(e.currentTarget);\n            const options = that.options;\n            const actionField = options.actionField;\n\n            if (!e.isDefaultPrevented() && item.attr(\"data-uid\")) {\n                if (actionField) {\n                    const dataItem = that.dataItemByIndex(that.getElementIndex(item));\n                    if (dataItem && dataItem[actionField]) {\n                        if (!that.trigger(\"action\", {\n                            item: item,\n                            dataItem: dataItem,\n                            action: dataItem[actionField]\n                        })) {\n                            return;\n                        }\n                    }\n                }\n\n                this.trigger(CLICK, { item });\n            }\n        },\n\n        _buildValueGetter: function() {\n            this._valueGetter = kendo.getter(this.options.dataValueField);\n        },\n\n        _calculateGroupPadding: function(height) {\n            const firstItem = this.items().first();\n            const groupHeader = this.header;\n            let padding = 0;\n\n            if (groupHeader[0] && groupHeader[0].style.display !== \"none\") {\n                if (height !== \"auto\") {\n                    padding = kendo.support.scrollbar();\n                }\n\n                padding += parseFloat(firstItem.css(\"border-right-width\"), 10) + parseFloat(firstItem.children(\".k-group\").css(\"right\"), 10);\n\n                groupHeader.css(\"padding-right\", padding);\n            }\n        },\n\n        _calculateColumnsHeaderPadding: function() {\n            if (this._isTableVariant()) {\n                const isRtl = kendo.support.isRtl(this.wrapper);\n                const scrollbar = kendo.support.scrollbar();\n                const columnsHeader = this.content.parent().parent().find(\".k-table-header\");\n                const total = this.dataSource.total();\n\n                columnsHeader.css((isRtl ? \"padding-left\" : \"padding-right\"), total ? scrollbar : 0);\n            }\n        }\n\n    });\n\n    kendo.ui.VirtualList = VirtualList;\n    kendo.ui.plugin(VirtualList);\n\n})(window.kendo.jQuery);\nexport default kendo;"],"mappings":"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"}